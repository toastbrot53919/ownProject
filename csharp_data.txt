public interface IStatsProvider
{
    CharacterStats GetCharacterStats();
}

﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "SkillTree", menuName = "SkillTree/SkillTree", order = 1)]
public class SkillTree : ScriptableObject
{
    public List<SkillNode> skillNodes;
    public SkillTree()
    {
        skillNodes = new List<SkillNode>();
    }

    public void AddSkillNode(SkillNode skillNode)
    {
        skillNodes.Add(skillNode);
    }
    internal bool IsVisible(SkillNode skillNode)
    {
        return true;
    }
    private void Awake()
    {
        resetAllNodes();
    }
    public void resetAllNodes()
    {
        foreach (SkillNode node in skillNodes)
        {
            node.isUnlocked = false;

        }
    }
}


﻿[System.Serializable]
public class StatsModifier
{
    public float attackSpeed;
    public float criticalChance;
    public float criticalDamage;
    public float spellCriticalChance;
    public float spellCriticalDamage;
    public float cooldown;
    public float dodgeChance;
    public float armor;
    public float magicResistance;
    public float maxLife;
    public float maxMana;
    public float lifeRegen;
    public float manaRegen;

    public void Add(StatsModifier other)
    {
        attackSpeed += other.attackSpeed;
        criticalChance += other.criticalChance;
        criticalDamage += other.criticalDamage;
        spellCriticalChance += other.spellCriticalChance;
        spellCriticalDamage += other.spellCriticalDamage;
        cooldown += other.cooldown;
        dodgeChance += other.dodgeChance;
        armor += other.armor;
        magicResistance += other.magicResistance;
        maxLife += other.maxLife;
        maxMana += other.maxMana;
        lifeRegen += other.lifeRegen;
        manaRegen += other.manaRegen;
    }
    public void Sub(StatsModifier other)
    {
        attackSpeed -= other.attackSpeed;
        criticalChance -= other.criticalChance;
        criticalDamage -= other.criticalDamage;
        spellCriticalChance -= other.spellCriticalChance;
        spellCriticalDamage -= other.spellCriticalDamage;
        cooldown -= other.cooldown;
        dodgeChance -= other.dodgeChance;
        armor -= other.armor;
        magicResistance -= other.magicResistance;
        maxLife -= other.maxLife;
        maxMana -= other.maxMana;
        lifeRegen -= other.lifeRegen;
        manaRegen -= other.manaRegen;
    }
}

﻿using UnityEngine;
public abstract class Ability : ScriptableObject
{
    public string abilityName;
    public float baseDamage;
    public float strengthScaling;
    public float intelligenceScaling;
    
    public string animationName;
    public abstract void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target);
    public abstract void Activate(AbilityData abilityData);
    protected virtual void StartActivation(AbilityData abilityData) { }
    protected virtual void UpdateActivation(AbilityData abilityData) { }
    protected virtual void EndActivation(AbilityData abilityData) { }

     public delegate void AbilityEvent(Ability ability);
     public delegate void AbilityObjectEvent(AbilityObject abilityObject, GameObject target);

     public event AbilityObjectEvent OnAbilityObjectSpawnedEvent;
     public event AbilityObjectEvent OnAbilityObjectHitEvent;
  
    public event AbilityEvent OnAbilityActivated;

    protected void RaiseOnObjectSpawned(AbilityObject abilityObject,GameObject target)
    {
        OnAbilityObjectSpawnedEvent?.Invoke(abilityObject,null);
    }
   
    protected void RaiseOnObjectHit(AbilityObject abilityObject, GameObject target)
    {
        OnAbilityObjectHitEvent?.Invoke(abilityObject, target);
    }
    protected void RaiseOnAbilityActivated()
    {
        OnAbilityActivated?.Invoke(this);
    }
    

}

public class AbilityData
{
    public GameObject Target;
    public CharacterStats CasterStats;
    public AbilityController CasterController;
    public float damage;
    public float projectileSpeed;
    public float stunDuration;

}
﻿using UnityEngine;
class AbilityControllData
{
    public string type;
    public Vector3 direction;
    public GameObject target;
    public Vector3 targetPosition;
}


﻿using System;
using UnityEngine;

public class AbilityObject : MonoBehaviour
{
    public event Action<GameObject> OnHit;
    public event Action OnUpdate;
    public event Action OnSpawn;
    public event Action OnDelete;
    public AbilityData data;

    public bool shouldDestroy=false;

    public bool deleteOnCollision = true;
    public bool deleteOnTimer = false;
    float timer = 0f;
    public float timerMax = 5f;

    

    public Ability ParentAbility { get; set; }

    protected virtual void HandleOnHit(GameObject target)
    {
        // Trigger OnHit event with target as parameter
        OnHit?.Invoke(target);
  
        if(deleteOnCollision){
            shouldDestroy = true;
        }
    }

    private void Update()
    {
        // Trigger OnHit event with target as parameter
        OnUpdate?.Invoke();
        if(deleteOnTimer){
            timer += Time.deltaTime;
            if(timer >= timerMax){
                timer = 0f;
                HandleOnDelete();
            }
        }
  
    }

    protected void HandleOnSpawn()
    {
        // Perform any initialization or setup for the ability object here
        // Trigger OnSpawn event
        OnSpawn?.Invoke();
        
  
    }

    protected void HandleOnDelete()
    {
        // Perform any cleanup or deactivation for the ability object here
        // Trigger OnDelete event
        OnDelete?.Invoke();
        Destroy(gameObject);
        
    }

    public void Awake()
    {
        HandleOnSpawn();
    }

    private void OnTriggerEnter(Collider collision)
    {
        // Get target HealthController from collided object
        if (data.CasterStats != null)
        {
            if (data.CasterStats.gameObject.name == collision.gameObject.name)
            {
                return;
            }
            if (gameObject.name == collision.gameObject.name)
            {
                return;
            }
        }

            
            // Call HandleOnHit method with target as parameter
            ParentAbility?.OnAbilityObjectHit(this, collision.gameObject);
            HandleOnHit(collision.gameObject);

    }
}
public interface IBouncingAbilityObject
{
     float BounceIntensity { get; set; }
    float BounceDuration { get; set; }
    void Bounce(GameObject target);
}

public interface IPiercingAbilityObject
{
    void Pierce(GameObject target);
}

public interface IHomingAbilityObject
{
    void Home(GameObject target);
}
using System.Collections;
using UnityEngine;
public class BaseProjectileObject : AbilityObject, IBouncingAbilityObject, IPiercingAbilityObject
{
    public float BounceIntensity { get; set; }
    public float BounceDuration { get; set; }

    public int bounceCount;
    public int pierceCount;


    protected override void HandleOnHit(GameObject target)
    {
    // Apply damage to the target
        if (data.CasterStats != null)
        {
            HealthController targetStats = target.GetComponent<HealthController>();
            if (targetStats != null)
            {
                float damage = data.damage;
                targetStats.TakeDamage(damage);
            }
        }

        // Handle Bounce and Pierce logic
        shouldDestroy = deleteOnCollision;
        if (bounceCount > 0)
        {
            Bounce(target);
        }
        else if (pierceCount > 0)
        {
            Pierce(target);
        }

        if (shouldDestroy)
        {
            HandleOnDelete();
        }
       
    }

    public void Bounce(GameObject target)
    {
        
        shouldDestroy = false;
        bounceCount--;

        Vector3 bounceDirection = Vector3.Reflect(transform.forward, target.transform.up);
        transform.forward = bounceDirection;

        Rigidbody rb = GetComponent<Rigidbody>();
        rb.velocity = bounceDirection * data.projectileSpeed;

        
    }

    public void Pierce(GameObject target)
    {

        pierceCount--;

        shouldDestroy = false;
    }

   
}
using System.Collections;
using UnityEngine;

// Base Projectile Ability class
[CreateAssetMenu(menuName = "Abilities/DefaultProjectileAbility")]
public class DefaultProjectileAbility : Ability
{
    public GameObject projectilePrefab;
    public float projectileSpeed = 5f;

    public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
    {
        if(abilityObject.data.CasterStats != null)
        {
            HealthController targetStats = target.GetComponent<HealthController>();
            if (targetStats != null)
            {
                float damage = abilityObject.data.damage;
                targetStats.TakeDamage(damage);
            }
        }
         RaiseOnObjectHit(abilityObject,target);
  

    }

    public override void Activate(AbilityData abilityData)
    {
        if (abilityData.CasterStats == null) return;

        Transform firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint;
        
        GameObject projectileInstance = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation);
        BaseProjectileObject abilityObject = projectileInstance.GetComponent<BaseProjectileObject>();
        RaiseOnObjectSpawned(abilityObject,null);

        Rigidbody rb = projectileInstance.GetComponent<Rigidbody>();
        rb.velocity = firePoint.forward * projectileSpeed;

        
        abilityObject.ParentAbility = this;
        abilityObject.data = abilityData;
        abilityData.projectileSpeed = projectileSpeed;
    }
}

// Base Projectile Object class


﻿
using UnityEngine;

[CreateAssetMenu(fileName = "Skill", menuName = "Skill/Skill", order = 1)]
public class DefaultSkill : Skill
{

}
using UnityEngine;
[CreateAssetMenu(menuName = "Abilities/Fireball")]
class FireBall : DefaultProjectileAbility {
    //Expecting BaseProjectileObject to be a prefab
  public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target) {
    if (abilityObject.data.CasterStats != null) {
      HealthController targetHealth = target.GetComponent<HealthController>();
      if (targetHealth != null) {
        float damage = abilityObject.data.damage;
        targetHealth.TakeDamage(damage);
      }
    }
    RaiseOnObjectHit(abilityObject, target);
  }

    public override void Activate(AbilityData abilityData) {
    if (abilityData.CasterStats == null) return;

    Transform firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint;

    GameObject projectileInstance = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation);
    BaseProjectileObject abilityObject = projectileInstance.GetComponent<BaseProjectileObject>();
    RaiseOnObjectSpawned(abilityObject, null);

    Rigidbody rb = projectileInstance.GetComponent<Rigidbody>();
    rb.velocity = firePoint.forward * projectileSpeed;

    abilityObject.ParentAbility = this;
    abilityObject.data = abilityData;
    abilityData.projectileSpeed = projectileSpeed;
  }
}

using UnityEngine;
[CreateAssetMenu(menuName = "Abilities/ShieldBash")]
public class ShieldBash : Ability
{
    public GameObject prefabAbilityObject;
    public float stunDuration = 2f;
    public ShieldBash(){
        abilityName = "Shield Bash";
        baseDamage = 50;
        strengthScaling = 0.5f;
        intelligenceScaling = 0.5f;
        animationName = "Shield Bash animation";
        
    }

    public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
    {
        if (abilityObject.data.CasterStats != null)
        {
            HealthController targetStats = target.GetComponent<HealthController>();
            if (targetStats != null)
            {
                float damage = abilityObject.data.damage;
                targetStats.TakeDamage(damage);

                if (abilityObject.data.stunDuration >= 0f)
                {
                    targetStats.GetComponent<IStunnable>().Stun(abilityObject.data.stunDuration);
                }
            }
        }
        RaiseOnObjectHit(abilityObject, target);
    }

    public override void Activate(AbilityData abilityData)
    {
        if (abilityData.CasterStats == null) return;

        Transform casterTransform = abilityData.CasterStats.transform;
        Vector3 forwardDirection = casterTransform.forward;

        GameObject abilityObjectInstance = Instantiate(prefabAbilityObject, casterTransform.position + forwardDirection, Quaternion.identity);
        AbilityObject abilityObject = abilityObjectInstance.GetComponent<AbilityObject>();
        RaiseOnObjectSpawned(abilityObject, null);

        Rigidbody rb = abilityObjectInstance.GetComponent<Rigidbody>();
        rb.velocity = forwardDirection * abilityData.projectileSpeed;

        abilityObject.data = abilityData;
        abilityData.Target = null;
        abilityData.projectileSpeed = 0f;
        abilityObject.ParentAbility = this;
        abilityData.stunDuration = stunDuration;
    }
}



﻿using UnityEngine;

[CreateAssetMenu(menuName = "Abilities/SimpleStrike")]
public class SimpleStrike : Ability
{
    // SimpleStrike specific properties, if any
    public GameObject MeelePrefab;
    public float lifeTime = 0.5f;

    public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
    {
        HealthController healthController = target.GetComponent<HealthController>();
        if (healthController != null)
        {

            healthController.TakeDamage(abilityObject.data.damage);
        }
    }


    public override void Activate(AbilityData abilityData)
    {
        GameObject meleeStrikeInstance = Instantiate(MeelePrefab, abilityData.CasterStats.transform.position, Quaternion.identity);
        MeleeStrikeObject abilityObject = meleeStrikeInstance.AddComponent<MeleeStrikeObject>();

        abilityObject.ParentAbility = this;
        abilityObject.data = abilityData;
        Destroy(meleeStrikeInstance, lifeTime);
    }


}

public class MeleeStrikeObject : AbilityObject
{
    private void OnTriggerEnter(Collider collision)
    {
        if (data.CasterStats != null)
        {
            if (data.CasterStats.gameObject.name == collision.gameObject.name)
            {
                return;
            }
            if (gameObject.name == collision.gameObject.name)
            {
                return;
            }
        }

        HandleOnHit(collision.gameObject);
        ParentAbility.OnAbilityObjectHit(this, collision.gameObject);

    }
}

﻿using System.Collections.Generic;
using UnityEngine;

public class Buff : ScriptableObject
{
    public string buffName;
    public float duration;
    public bool stackable;
    public int maxStacks;

    private event System.Action<BuffInstance> OnApply;
    private event System.Action<BuffInstance> OnFade;
    private event System.Action<BuffInstance> OnHit;

    public void InvokeOnApply(BuffInstance buffInstance)
    {
        OnApply?.Invoke(buffInstance);
    }

    public void InvokeOnFade(BuffInstance buffInstance)
    {
        OnFade?.Invoke(buffInstance);
    }

    public void InvokeOnHit(BuffInstance buffInstance)
    {
        OnHit?.Invoke(buffInstance);
    }

    public List<string> GetEventTypes()
    {
        List<string> eventTypes = new List<string>();

        if (OnApply != null)
        {
            eventTypes.Add("OnApply");
        }

        if (OnFade != null)
        {
            eventTypes.Add("OnFade");
        }

        if (OnHit != null)
        {
            eventTypes.Add("OnHit");
        }

        return eventTypes;
    }
}

﻿using UnityEngine;

public class BuffInstance
{
    public Buff buff;
    public GameObject target;
    public int currentStacks;
    public float remainingDuration;

    public BuffInstance(Buff buff, GameObject target, int initialStacks, float initialDuration)
    {
        this.buff = buff;
        this.target = target;
        this.currentStacks = initialStacks;
        this.remainingDuration = initialDuration;
    }

    public void Update()
    {
        remainingDuration -= Time.deltaTime;

        if (remainingDuration <= 0)
        {
            OnBuffFade();
            return;
        }

        // Perform any other update logic specific to the buff
    }

    public void Refresh(float duration)
    {
        remainingDuration = duration;
    }

    public void AddStack()
    {
        currentStacks++;
        OnBuffApply();
    }

    public void RemoveStack()
    {
        currentStacks--;

        if (currentStacks <= 0)
        {
            OnBuffFade();
        }
    }

    public void OnBuffApply()
    {
        // Perform any actions or apply stat changes when the buff is applied
    }

    public void OnBuffFade()
    {
        // Perform any actions or revert stat changes when the buff fades
    }

    public void OnBuffHit()
    {
        // Perform any actions or apply effects when the buff "hits" (e.g., dealing damage or applying a debuff)
    }
}

﻿using UnityEngine;

public abstract class Item : ScriptableObject
{
    public string itemName;
    public string description;
    public Sprite icon;
}


[System.Serializable]
public class EquipableItem : ScriptableObject
{
    public EquipManager.EquipmentType equipmentType;
    public float strengthBonus;
    public float intelligenceBonus;
    public float dexterityBonus;
    public float enduranceBonus;
    public float wisdomBonus;

    public StatsModifier subStatsModifier;
}


using UnityEngine;
[CreateAssetMenu(fileName = "FireBallMastery", menuName = "Skill/FireBallMastery", order = 1)]
public class FireballMasterySkill : Skill
{
    [SerializeField]
    private GameObject explosionPrefab;

    public override void ApplySkill(CharacterStats playerStats)
    {
        Debug.Log("Apply Skill");
        FireBall fireballAbility = GetFireballAbility(playerStats);
        if (fireballAbility != null)
        {
            Debug.Log("Fireball Ability found");
            fireballAbility.OnAbilityObjectHitEvent += ExplodeOnHit;
        }
    }

    public override void RemoveSkill(CharacterStats playerStats)
    {
        FireBall fireballAbility = GetFireballAbility(playerStats);
        if (fireballAbility != null)
        {
            fireballAbility.OnAbilityObjectHitEvent -= ExplodeOnHit;
        }
    }

    private FireBall GetFireballAbility(CharacterStats playerStats)
    {
        AbilityController abilityController = playerStats.GetComponent<AbilityController>();
        return abilityController.learnedAbilitys.Find(a => a is FireBall) as FireBall;
    }

    private void ExplodeOnHit(AbilityObject abilityObject, GameObject target)
    {
        Debug.Log("EXPLODE ON Hit");
        ApplyDamageToTargets(abilityObject.transform.position, 2f, abilityObject.data.damage * 0.5f);
        InstantiateExplosion(abilityObject.transform.position);
    }

    private void ApplyDamageToTargets(Vector3 position, float radius, float damage)
    {
        Collider[] colliders = Physics.OverlapSphere(position, radius);
        foreach (Collider col in colliders)
        {
            HealthController targetStats = col.GetComponent<HealthController>();
            if (targetStats != null)
            {
                targetStats.TakeDamage(damage);
            }
        }
    }

    private void InstantiateExplosion(Vector3 position)
    {
        if (explosionPrefab != null)
        {
            GameObject explosion = Instantiate(explosionPrefab, position, Quaternion.identity);
            // Add additional logic for the explosion, such as configuring the explosion's lifetime or assigning its parent
        }
        else
        {
            Debug.LogWarning("No explosion prefab assigned to FireballMasterySkill.");
        }
    }
}

﻿using System.Collections.Generic;
using UnityEngine;

public abstract class Skill : ScriptableObject
{
    public string skillName;
    public List<Archetype> archTypes;
    public StatsModifier statModifier;

    public virtual void ApplySkill(CharacterStats characterStats)
    {
        // Implement skill-specific behavior in derived classes
    }

    public virtual void RemoveSkill(CharacterStats characterStats)
    {
        // Implement skill-specific behavior in derived classes
    }
    public virtual void OnSpawnAbilityObject(AbilityObject abilityObject, AbilityData abilityData)
    {

    }
    
}


public enum Archetype
{
    Strength,
    Intelligence,
    Dexterity,
    Endurance,
    Wisdom
}
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "SkillNode", menuName = "SkillTree/SkillNode", order = 0)]
public class SkillNode : ScriptableObject
{
    public string skillName;
    public string skillDescription;
    public int skillPointCost;
    public Sprite icon;
    public List<Archetype> mainStatRequirement;
    public List<int> mainStatValue;
    public Skill skill;
    public SkillNode prerequisiteSkill;
    public bool isUnlocked = false;


}

using System.Collections.Generic;

using UnityEngine;
public class AbilityController : MonoBehaviour
{
    public Transform firePoint;
    public float projectileSpeed = 5f;
    public List<Ability> learnedAbilitys;
    private IStatsProvider statsProvider;

    private void Awake()
    {
        statsProvider = GetComponent<IStatsProvider>();
    }

    public void CastAbility(Ability ability, AbilityData abilityData)
    {
        ability.Activate(abilityData);
    }
}


using UnityEngine;

public class AIController : MonoBehaviour
{
    public AIState currentState;
    public IdleState idleState;
    public FollowState followState;
    public AssistState assistState;
    public PatrolState patrolState;


    public ChaseState chaseState;
    public AttackState attackState;

    public Transform target;

    private void Start()
    {
        currentState = idleState;
        PatrolStateMonoBehaviour patrolStateMonoBehaviour = GetComponent<PatrolStateMonoBehaviour>();
        if (patrolStateMonoBehaviour != null)
        {
            patrolState.waypoints = new System.Collections.Generic.List<Transform>();
            foreach (GameObject g in patrolStateMonoBehaviour.waypoints)
            {
                patrolState.waypoints.Add(g.transform);
            }
        }
    }

    private void Update()
    {
        currentState.UpdateState(this);
    }

    public void ChangeState(AIState newState)
    {
        currentState.ExitState(this);
        currentState = newState;
        newState.EnterState(this);
    }
}

public abstract class AIState : ScriptableObject
{
    public abstract void EnterState(AIController aiController);
    public abstract void UpdateState(AIController aiController);
    public abstract void ExitState(AIController aiController);
}


﻿using System.Collections.Generic;
using UnityEngine;

public class AnimationController : MonoBehaviour
{
    [SerializeField] private Animator animator;
    [SerializeField] private List<VisualEffectData> visualEffectDataList;

    private Dictionary<string, GameObject> visualEffects;

    private void Awake()
    {
        // Initialize the visualEffects dictionary.
        visualEffects = new Dictionary<string, GameObject>();
        foreach (VisualEffectData effectData in visualEffectDataList)
        {
            visualEffects.Add(effectData.name, effectData.visualEffectPrefab);
        }
    }

    public void PlayAnimation(string animationName)
    {
        // Play the specified animation.
        if (animationName == "attack")
        {
            animator.SetTrigger("attack");
            return;
        }

        animator.Play(animationName);
    }

    public void ApplyVisualEffect(string effectName, Vector3 position, Quaternion rotation)
    {
        // Instantiate the specified visual effect at the given position and rotation.
        if (visualEffects.TryGetValue(effectName, out GameObject effectPrefab))
        {
            Instantiate(effectPrefab, position, rotation);
        }
        else
        {
            Debug.LogWarning($"Visual effect '{effectName}' not found.");
        }
    }
}

[System.Serializable]
public class VisualEffectData
{
    public string name;
    public GameObject visualEffectPrefab;
}

﻿using System.Collections.Generic;
using UnityEngine;

public class BuffSystem : MonoBehaviour
{
    private Dictionary<string, BuffInstance> activeBuffs;
    private Dictionary<string, System.Action<BuffInstance>> eventHandlers;

    private void Awake()
    {
        activeBuffs = new Dictionary<string, BuffInstance>();
        eventHandlers = new Dictionary<string, System.Action<BuffInstance>>();
    }

    public void AddBuff(Buff buff, GameObject target)
    {
        if (activeBuffs.ContainsKey(buff.buffName))
        {
            BuffInstance existingBuff = activeBuffs[buff.buffName];

            if (buff.stackable && existingBuff.currentStacks < buff.maxStacks)
            {
                existingBuff.AddStack();
                existingBuff.Refresh(buff.duration);
            }
            else
            {
                existingBuff.Refresh(buff.duration);
            }
        }
        else
        {
            BuffInstance newBuff = new BuffInstance(buff, target, 1, buff.duration);
            activeBuffs.Add(buff.buffName, newBuff);
            AddEventHandlers(buff);
            newBuff.OnBuffApply();
        }
    }

    public void RemoveBuff(Buff buff)
    {
        if (activeBuffs.ContainsKey(buff.buffName))
        {
            BuffInstance existingBuff = activeBuffs[buff.buffName];
            existingBuff.RemoveStack();

            if (existingBuff.currentStacks <= 0)
            {
                RemoveEventHandlers(buff);
                activeBuffs.Remove(buff.buffName);
            }
        }
    }

    public BuffInstance GetBuffInstance(string buffName)
    {
        if (activeBuffs.ContainsKey(buffName))
        {
            return activeBuffs[buffName];
        }
        return null;
    }

    private void AddEventHandlers(Buff buff)
    {
        List<string> eventTypes = buff.GetEventTypes();

        foreach (string eventType in eventTypes)
        {
            if (!eventHandlers.ContainsKey(eventType))
            {
                eventHandlers.Add(eventType, (BuffInstance buffInstance) => { });
            }

            System.Action<BuffInstance> eventHandler = null;
            switch (eventType)
            {
                case "OnApply":
                    eventHandler = buff.InvokeOnApply;
                    break;
                case "OnFade":
                    eventHandler = buff.InvokeOnFade;
                    break;
                case "OnHit":
                    eventHandler = buff.InvokeOnHit;
                    break;
            }

            if (eventHandler != null)
            {
                eventHandlers[eventType] += eventHandler;
            }
        }
    }

    private void RemoveEventHandlers(Buff buff)
    {
        List<string> eventTypes = buff.GetEventTypes();

        foreach (string eventType in eventTypes)
        {
            System.Action<BuffInstance> eventHandler = null;
            switch (eventType)
            {
                case "OnApply":
                    eventHandler = buff.InvokeOnApply;
                    break;
                case "OnFade":
                    eventHandler = buff.InvokeOnFade;
                    break;
                case "OnHit":
                    eventHandler = buff.InvokeOnHit;
                    break;
            }

            if (eventHandler != null)
            {
                eventHandlers[eventType] -= eventHandler;
            }
        }
    }

    public void CallEventHandlers(string eventType, BuffInstance buffInstance)
    {
        if (eventHandlers.ContainsKey(eventType))
        {
            eventHandlers[eventType]?.Invoke(buffInstance);
        }
    }
}

﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ButtonWithToolTip : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    public SkillNode skillNode;
    public PlayerController playerController;
    public UIManager uiManager;
    public GameObject toolTipObject;
    public Text toolTipText;

    private Button button;

    private void Awake()
    {
        button = GetComponent<Button>();
        button.onClick.AddListener(TryLearn);
        GetComponent<Image>().sprite = skillNode.icon;
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        ShowToolTip();
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        HideToolTip();
    }

    private void ShowToolTip()
    {
        uiManager.OpenToolTipSkill(skillNode, gameObject.GetComponent<RectTransform>().position);
    }

    private void HideToolTip()
    {
        uiManager.CloseToolTipSkill();
    }

    private void TryLearn()
    {
        playerController.TryUnlockSkillNode(skillNode);
    }
}

﻿using UnityEngine;
public class CharacterCombatController : MonoBehaviour, IStatsProvider
{
    public CharacterStats characterStats;
    public AbilityController abilityController;
    public AnimationController animationController;
    public IStunnable stunnable;


    private void Start()
    {
        characterStats = GetComponent<CharacterStats>();
        stunnable = GetComponent<IStunnable>();
    }

    public void PerformAbility(Ability ability, GameObject target)
    {
        if(stunnable != null && stunnable.isStunned())
        {
            return;
        }
        float damageAbility = ability.baseDamage + (ability.strengthScaling * characterStats.strength) + (ability.intelligenceScaling * characterStats.intelligence);
        float critChance = characterStats.criticalChance;
        if (Random.Range(0f, 1f) <= critChance)
        {
            damageAbility *= 2;
        }

        animationController.PlayAnimation(ability.animationName);
        AbilityData abilityData = new AbilityData
        {
            CasterStats = characterStats,
            Target = target,
            damage = damageAbility,
            CasterController = abilityController,
           
            // ... other fields
        };

        abilityController.CastAbility(ability, abilityData);
    }
    public CharacterStats GetCharacterStats()
    {
        return characterStats;
    }
}

﻿using System;
using UnityEngine;

public class CharacterStats : MonoBehaviour
{
    // MainStats
    public float strength;
    public float intelligence;
    public float dexterity;
    public float endurance;
    public float wisdom;

    // SubStats

    public float criticalChance;
    public float criticalDamage;
    public float attackSpeed;

    public float spellCriticalChance;
    public float spellCriticalDamage;

    public float cooldown;

    public float maxLife;
    public float maxMana;
    public float lifeRegen;
    public float manaRegen;

    public float armor;
    public float magicResistance;

    public float dodgeChance;

    public int unspentStatPoints;

    public event Action StatsChanged;
    private EquipManager equipManager;
    private SkillController skillController;



    private void Start()
    {
        // Initialize unspentStatPoints or load from saved game data
        unspentStatPoints = 10;
        equipManager = GetComponent<EquipManager>();
        skillController = GetComponent<SkillController>();
    }

    public void AddStatPoints(int amount)
    {
        unspentStatPoints += amount;
        StatsChanged?.Invoke();
    }

    public void UpdateSubStats()
    {

        strength += equipManager.TotalStrength;
        intelligence += equipManager.TotalIntelligence;
        dexterity += equipManager.TotalDexterity;
        endurance += equipManager.TotalEndurance;
        wisdom += equipManager.TotalWisdom;


        criticalChance = 0.02f * dexterity;
        criticalDamage = 1.5f + (0.14f * dexterity);
        attackSpeed = 1 + (0.01f * strength * dexterity);

        spellCriticalChance = 0.02f * intelligence;
        spellCriticalDamage = 1.5f + (0.14f * intelligence);

        armor = 1.5f * endurance;
        magicResistance = 1.5f * endurance;


        // Calculate substats based on main stats + equipment bonuses.
        maxLife = 100 + 20 * endurance;
        maxMana = 100 + 20 * wisdom;
        lifeRegen = 1 + 0.25f * endurance;
        manaRegen = 0.5f + 0.25f * wisdom;

        dodgeChance = 0.009f * dexterity;

        AddStatBonuses(equipManager.TotalStatModier);
        AddStatBonuses(skillController.totalStatsModier);


        StatsChanged?.Invoke();
    }

    public void AddStatBonuses(StatsModifier statModifier)
    {

        attackSpeed += statModifier.attackSpeed;
        criticalChance += statModifier.criticalChance;
        criticalDamage += statModifier.criticalDamage;
        spellCriticalChance += statModifier.spellCriticalChance;
        spellCriticalDamage += statModifier.spellCriticalDamage;
        cooldown += statModifier.cooldown;
        dodgeChance += statModifier.dodgeChance;
        armor += statModifier.armor;
        magicResistance += statModifier.magicResistance;
        maxLife += statModifier.maxLife;
        maxMana += statModifier.maxMana;
        lifeRegen += statModifier.lifeRegen;
        manaRegen += statModifier.manaRegen;
    }


    public void IncreaseStat(Archetype stateType, int amount)
    {
        if (unspentStatPoints >= amount)
        {
            switch (stateType)
            {
                case Archetype.Strength:
                    strength += amount;
                    break;
                case Archetype.Intelligence:
                    intelligence += amount;
                    break;
                case Archetype.Dexterity:
                    dexterity += amount;
                    break;
                case Archetype.Endurance:
                    endurance += amount;
                    break;
                case Archetype.Wisdom:
                    wisdom += amount;
                    break;
                default:
                    Debug.LogWarning("Invalid stat name.");
                    return;
            }

            unspentStatPoints -= amount;
            UpdateSubStats();
        }
        else
        {
            Debug.LogWarning("Not enough stat points.");
        }
    }



}

﻿using System.Collections.Generic;
using UnityEngine;
public class EquipManager : MonoBehaviour
{
    public enum EquipmentType { Weapon, Shield, Helmet, ChestArmor, LegArmor, Boots, Ring, Wrist }

    public Dictionary<EquipmentType, EquipableItem> equippedItems = new Dictionary<EquipmentType, EquipableItem>();

    // Properties to store the total stats from all equipped items.
    public StatsModifier TotalStatModier;
    public float TotalStrength;
    public float TotalIntelligence;
    public float TotalDexterity;
    public float TotalEndurance;
    public float TotalWisdom;
    // Add more stat properties as needed.

    public void EquipItem(EquipmentType type, EquipableItem item)
    {
        if (equippedItems.ContainsKey(type))
        {
            UnequipItem(type);
        }

        equippedItems[type] = item;
        ApplyItemStats(item);
    }

    public void UnequipItem(EquipmentType type)
    {
        if (!equippedItems.ContainsKey(type)) return;

        EquipableItem item = equippedItems[type];
        RemoveItemStats(item);
        equippedItems.Remove(type);
    }

    private void ApplyItemStats(EquipableItem item)
    {
        TotalStrength += item.strengthBonus;
        TotalIntelligence += item.intelligenceBonus;
        TotalDexterity += item.dexterityBonus;
        TotalEndurance += item.enduranceBonus;
        TotalWisdom += item.wisdomBonus;

        TotalStatModier.Add(item.subStatsModifier);

        // Add more stat effects as needed.
    }

    private void RemoveItemStats(EquipableItem item)
    {
        TotalStrength -= item.strengthBonus;
        TotalIntelligence -= item.intelligenceBonus;
        TotalDexterity -= item.dexterityBonus;
        TotalEndurance -= item.enduranceBonus;
        TotalWisdom -= item.wisdomBonus;

        TotalStatModier.Sub(item.subStatsModifier);

        // Remove more stat effects as needed.
    }



}

﻿using System;

public class ExperienceSystem
{
    public int CurrentXP { get; private set; }
    public int Level { get; private set; }
    public int XpToNextLevel { get; private set; }

    public event Action LevelUpEvent;
    public event Action<int> ExperienceGained;

    public ExperienceSystem()
    {
        CurrentXP = 0;
        Level = 1;
        UpdateXpToNextLevel();
    }

    public void AddExperience(int amount)
    {
        CurrentXP += amount;
        ExperienceGained?.Invoke(amount);

        while (CurrentXP >= XpToNextLevel)
        {
            CurrentXP -= XpToNextLevel;
            LevelUp();
        }
    }

    private void LevelUp()
    {
        Level++;
        UpdateXpToNextLevel();
        LevelUpEvent?.Invoke();
    }

    private void UpdateXpToNextLevel()
    {
        XpToNextLevel = CalculateXpForLevel(Level);
    }

    private int CalculateXpForLevel(int level)
    {
        // Implement your custom XP calculation logic here
        return (int)Math.Floor(Math.Pow(level, 2) * 100);
    }
}

using UnityEngine;

public class HealthController : MonoBehaviour
{
    public string Name;
    public int maxHealth;
    public float currentHealth;
    public GameObject damageTextPrefab;
    private QuestSystem questSystem;


    private void Start()
    {
        currentHealth = maxHealth;
        damageTextPrefab = GameObject.Find("DamageTextTemplate");
        

    }

    public void TakeDamage(float damage)
    {
        currentHealth -= damage;
        ShowDamageNumbers(damage);
        if (currentHealth <= 0)
        {
            Die();
        }
    }

    private void Die()
    {
        // Implement death behavior, such as playing death animation, dropping loot, etc.
        if (questSystem != null)
        {
            questSystem.UpdateQuestObjective("kill:"+Name); // Call UpdateQuestObjective method with enemyId
        }
        Destroy(gameObject);
    }
    public void ShowDamageNumbers(float damage)
    {
        if (WorldSpaceCanvasController.Instance == null)
        {
            Debug.LogError("WorldSpaceCanvasController instance is not present in the scene.");
            return;
        }

        WorldSpaceCanvasController.Instance.SpawnDamageNumber(damage, transform.position + Vector3.up * 2f);
    }

}
public interface IInteractable
{
    void Interact();
}

﻿using System.Collections.Generic;
using UnityEngine;

public class Inventory : MonoBehaviour
{
    public List<Item> items;
    public QuestSystem questSystem;
      private void Start()
    {
        questSystem = GetComponent<QuestSystem>();

    }

    public void AddItem(Item item)
    {
        items.Add(item);
        if(questSystem!=null)  // Check if questSystem is not null
        {
            Debug.Log("collect:"+item.name);
            questSystem.UpdateQuestObjective("collect:"+item.name); // Call UpdateQuestObjective method with item id
        }
    }

    public void RemoveItem(Item item)
    {
        items.Remove(item);
    }

    public bool HasItem(Item item)
    {
        return items.Contains(item);
    }
}

using UnityEngine;
public class isStunnableController : MonoBehaviour,IStunnable{

    public bool stunned;

    float timeAtStunStart;
    float stunDuration;

    bool IStunnable.stunned { get => stunned ;}

    float IStunnable.timeAtStunStart => timeAtStunStart;

    float IStunnable.stunDuration => stunDuration;


    public void Stun(float duration){
        stunned = true;
        timeAtStunStart = Time.time;
        stunDuration = duration;
    }
    public bool isStunned(){
        
            if(Time.time - timeAtStunStart >= stunDuration){
                stunned = false;
            }
        return stunned;
        
    }
}
//Interface isStunnable if GameObject can be stunned,contain bool isStunned
// Path: Assets\Scripts\PlayerAndUnitsComponent\IStunnable.cs
using UnityEngine;
public interface IStunnable
{
    bool stunned { get; }

   
    float timeAtStunStart{ get; }
    float stunDuration{ get ;}


    void Stun(float duration);
    public bool isStunned();
}


using UnityEngine;
using UnityEngine.AI;

public class MovementController : MonoBehaviour
{
    IStunnable stunnable;
    public Transform target;
    public float stoppingDistance = 2f;

    private NavMeshAgent agent;

    private void Start()
    {
        agent = GetComponent<NavMeshAgent>();
        stunnable = GetComponent<IStunnable>();
        Debug.Log("stunnable: " + stunnable);
    }

    private void Update()
    {
        if (target != null)
        {
            agent.SetDestination(target.position);
            agent.stoppingDistance = stoppingDistance;
        }
        if(stunnable != null && stunnable.isStunned())
        {
            agent.isStopped = true;
        }
        else
        {
            agent.isStopped = false;
        }
    }
}

using System.Collections.Generic;
using UnityEngine;

public class Hotkey
{
    public Ability ability;
}

public class PlayerController : MonoBehaviour
{
    [Header("Controller")]
    BuffSystem buffSystem;
    ExperienceSystem experienceSystem;
    CharacterStats characterStats;
    CharacterCombatController combatController;
    SkillController skillController;
    SkillTree skillTree;
IStunnable stunnable;


    public Ability Ability1;

    public List<Hotkey> hotkeys;
    public Dictionary<KeyCode, Hotkey> hotkeyMapping;


    [Header("Movement")]
    public float moveSpeed = 5f;
    public float rotationSpeed = 720f;
    public float jumpForce = 1f;
    public LayerMask groundLayer;

    [Header("Camera")]
    public Transform cameraTarget;
    public float cameraDistance = 5f;
    public float cameraHeight = 2f;
    public float cameraRotationSpeed = 2f;


    private Rigidbody rb;
    private Animator animator;
    private Vector3 moveDirection;
    private bool isGrounded;
    private Transform mainCamera;
    private float cameraRotationY;


    private void Start()
    {
        combatController = GetComponent<CharacterCombatController>();
        characterStats = GetComponent<CharacterStats>();
        skillController = GetComponent<SkillController>();

        //EDITOR CODE
        skillController.skillTree.resetAllNodes();

        hotkeys = new List<Hotkey>();
        for (int i = 0; i < 9; i++)
        {
            hotkeys.Add(new Hotkey());
        }

        hotkeyMapping = new Dictionary<KeyCode, Hotkey>
    {
        { KeyCode.Alpha1, hotkeys[0] },
        { KeyCode.Alpha2, hotkeys[1] },
        { KeyCode.Alpha3, hotkeys[2] },
        { KeyCode.Alpha4, hotkeys[3] },
        { KeyCode.Alpha5, hotkeys[4] },
        { KeyCode.Alpha6, hotkeys[5] },
        { KeyCode.Alpha7, hotkeys[6] },
        { KeyCode.Alpha8, hotkeys[7] },
        { KeyCode.E, hotkeys[8] }
    };


        rb = GetComponent<Rigidbody>();
        animator = GetComponent<Animator>();
        mainCamera = Camera.main.transform;
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;

        Hotkey hotkeyTest = new Hotkey();
        hotkeyTest.ability = combatController.abilityController.learnedAbilitys[0];
        hotkeys[0].ability = combatController.abilityController.learnedAbilitys[0];

        skillController.OnSkillUnlocked += UpdateToSkillEvents;
        stunnable = GetComponent<IStunnable>();

    }


    private void Update()
    {
        
        HandleMovement();
        HandleJump();
        HandleCamera();
        HandleHotkey();
    }
    private void UpdateToSkillEvents(SkillNode node)
    {
        characterStats.UpdateSubStats();
    }


    private void HandleHotkey()
    {
        foreach (KeyValuePair<KeyCode, Hotkey> entry in hotkeyMapping)
        {
            if (Input.GetKeyDown(entry.Key))
            {
                Hotkey hotkey = entry.Value;
                if (hotkey.ability != null)
                {
                    combatController.PerformAbility(hotkey.ability, this.gameObject);
                }
                // else if (hotkey.item != null)
                {
                    // UseItem(hotkey.item);
                }
            }
        }
    }
    private void HandleMovement()
    {
        if(stunnable != null && stunnable.isStunned())
        {
            return;
        }
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");

        moveDirection = mainCamera.forward * vertical + mainCamera.right * horizontal;
        moveDirection.y = 0f;
        moveDirection.Normalize();

        if (moveDirection != Vector3.zero)
        {
            Quaternion targetRotation = Quaternion.LookRotation(moveDirection);
            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);

        }

        animator.SetFloat("Speed", moveDirection.magnitude);
    }

    private void HandleJump()
    {
        if(stunnable != null && stunnable.isStunned())
        {
            return;
        }
        isGrounded = Physics.Raycast(transform.position, Vector3.down, 0.4f, groundLayer);

        if (Input.GetButtonDown("Jump") && isGrounded)
        {
            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }

        // animator.SetBool("IsGrounded", isGrounded);
    }

    private void HandleCamera()
    {
        float mouseX = Input.GetAxis("Mouse X");
        float mouseY = Input.GetAxis("Mouse Y");

        cameraRotationY -= mouseY * cameraRotationSpeed;
        cameraRotationY = Mathf.Clamp(cameraRotationY, -80f, 80f);

        mainCamera.RotateAround(cameraTarget.position, Vector3.up, mouseX * cameraRotationSpeed);
        mainCamera.localRotation = Quaternion.Euler(cameraRotationY, mainCamera.localEulerAngles.y, 0f);

        Vector3 cameraOffset = new Vector3(0f, cameraHeight, -cameraDistance);
        Vector3 targetPosition = cameraTarget.position + mainCamera.TransformDirection(cameraOffset);

        mainCamera.position = Vector3.Lerp(mainCamera.position, targetPosition, Time.deltaTime * rotationSpeed);
        mainCamera.LookAt(cameraTarget);
    }

    private void FixedUpdate()
    {
        rb.MovePosition(rb.position + moveDirection * moveSpeed * Time.fixedDeltaTime);
    }


    // Your existing code...

    public bool TryUnlockSkillNode(SkillNode skillNode)
    {
        if (skillNode == null)
        {
            Debug.LogWarning("Invalid skill node.");
            return false;
        }
        if (skillNode.isUnlocked)
        {
            Debug.LogWarning("Already learned.");
            return false;
        }

        // Check if the character has enough skill points to unlock the node.
        if (skillController.availableSkillPoints < skillNode.skillPointCost)
        {
            Debug.LogWarning("Not enough skill points.");
            return false;
        }

        // Check if the required main stat meets the node's requirement.
        bool statRequirementsMet = true;
        for (int i = 0; i < skillNode.mainStatRequirement.Count; i++)
        {
            Archetype statName = skillNode.mainStatRequirement[i];
            int requiredValue = skillNode.mainStatValue[i];

            switch (statName)
            {
                case Archetype.Strength:
                    if (characterStats.strength < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Intelligence:
                    if (characterStats.intelligence < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Dexterity:
                    if (characterStats.dexterity < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Endurance:
                    if (characterStats.endurance < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Wisdom:
                    if (characterStats.wisdom < requiredValue) statRequirementsMet = false;
                    break;
                default:
                    Debug.LogWarning("Invalid stat name in the skill node.");
                    break;
            }
        }

        if (!statRequirementsMet)
        {
            Debug.LogWarning("Main stat requirement not met.");
            return false;
        }

        // Check if the required prerequisite skill has been unlocked.
        if (skillNode.prerequisiteSkill != null && !skillNode.prerequisiteSkill.isUnlocked)
        {
            Debug.LogWarning("Prerequisite skill not unlocked.");
            return false;
        }

        // Check if the skill node is visible based on the fog of war mechanic.
        if (!skillController.skillTree.IsVisible(skillNode))
        {
            Debug.LogWarning("Skill node is not visible.");
            return false;
        }

        // Unlock the skill node.
        skillNode.isUnlocked = true;

        skillController.LearnSkill(skillNode);


        return true;
    }
    public bool TryUnLearnSkillNode(SkillNode skillNode)
    {
        if (skillNode.isUnlocked == false)
        {
            return false;
        }
        skillNode.isUnlocked = false;
        skillController.UnlearnSkill(skillNode);
        return true;
    }

}

﻿using System.Collections.Generic;
using UnityEngine;

class SkillController : MonoBehaviour
{
    public List<Skill> activeSkills;
    public SkillTree skillTree;
    public int availableSkillPoints;
    public StatsModifier totalStatsModier;
    public delegate void SkillEvent(SkillNode skillNode);
    public event SkillEvent OnSkillUnlocked;
    public event SkillEvent OnSkillUnlearnd;



    public void LearnSkill(SkillNode skillNode)
    {

        // Call event to update the UI, etc.

        activeSkills.Add(skillNode.skill);
        skillNode.skill.ApplySkill(this.gameObject.GetComponent<CharacterStats>());
        totalStatsModier.Add(skillNode.skill.statModifier);
        availableSkillPoints -= skillNode.skillPointCost;
        OnSkillUnlocked?.Invoke(skillNode);

    }
    public void UnlearnSkill(SkillNode skillNode)
    {
        if (activeSkills.Remove(skillNode.skill))
        {
            totalStatsModier.Sub(skillNode.skill.statModifier);
        }
        availableSkillPoints += skillNode.skillPointCost;
        skillNode.skill.RemoveSkill(this.gameObject.GetComponent<CharacterStats>());
        OnSkillUnlearnd?.Invoke(skillNode);
    }

}


﻿using UnityEngine;

public class TargetingSystem : MonoBehaviour
{
    public Camera playerCamera;
    public LayerMask targetLayerMask;
    public GameObject currentTarget;
    public GameObject crosshair;
    public float maxTargetingDistance = 100f;
    public Material highlightMaterial;
    private GameObject lastTarget;
    private Material originalMaterial;
    public OutlineHighlight outlineHighlightController;

    private void Update()
    {
        HandleCrosshairTargeting();
        HandleMouseClickTargeting();
        HighlightTarget();
    }
    private void Start()
    {

    }

    private void HandleCrosshairTargeting()
    {
        RaycastHit hit;
        Ray ray = playerCamera.ScreenPointToRay(crosshair.transform.position);

        if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask))
        {
            currentTarget = hit.collider.gameObject;
        }
        else
        {
            currentTarget = null;
        }
    }

    private void HandleMouseClickTargeting()
    {
        if (Input.GetMouseButtonDown(0))
        {
            RaycastHit hit;
            Ray ray = playerCamera.ScreenPointToRay(Input.mousePosition);

            if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask))
            {
                currentTarget = hit.collider.gameObject;
            }
        }
    }

    public GameObject GetTarget()
    {
        return currentTarget;
    }
    private void HighlightTarget()
    {
        if (currentTarget != null)
        {
            outlineHighlightController.target = currentTarget.transform;
            lastTarget = currentTarget;
        }
        else
        {
            outlineHighlightController.target = null;
        }
    }

}

﻿using UnityEngine;
using UnityEngine.UI;

public class ToolTipUiController : MonoBehaviour
{
    public Text SkillName;
    public Text SkillDescription;
    public Text AlreadySkilled;
    public Text SkillpointCost;
    public Text AttrbuteReq;
    public Image SkillIcon;

    private void Start()
    {
    }

    private void Awake()
    {
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
    }

    public void UpdateUI(SkillNode node)
    {
        SkillName.text = node.skillName;
        SkillDescription.text = node.skillDescription;
        if (node.isUnlocked)
        {
            AlreadySkilled.gameObject.SetActive(true);
        }
        else
        {
            AlreadySkilled.gameObject.SetActive(false);
        }
        SkillpointCost.text = "Cost: " + node.skillPointCost;

        AttrbuteReq.text = "Requiment:";

        for (int a = 0; a < node.mainStatRequirement.Count; a++)
        {

            AttrbuteReq.text += " " + node.mainStatRequirement[a] + ": " + node.mainStatValue[a];
        }

        if (node.prerequisiteSkill != null)
        {
            AttrbuteReq.text += "Skill Requiment: " + node.prerequisiteSkill.skillName;
        }

        SkillIcon.sprite = node.icon;




    }

}

﻿using UnityEngine;

[CreateAssetMenu(menuName = "AI/States/AssistState")]
public class AssistState : AIState
{
    public Transform target;
    public Ability assistAbility;
    public float assistRange = 10f;

    public override void EnterState(AIController aiController)
    {
    }

    public override void UpdateState(AIController aiController)
    {
        float distanceToTarget = Vector3.Distance(aiController.transform.position, target.position);

        if (distanceToTarget <= assistRange)
        {
            // aiController.GetComponent<AbilityController>().UseAbility(assistAbility);
        }
        else
        {
            aiController.ChangeState(aiController.followState);
        }
    }

    public override void ExitState(AIController aiController)
    {
    }
}

﻿using UnityEngine;
[CreateAssetMenu(menuName = "AI/States/AttackState")]
public class AttackState : AIState
{
    public Transform target;
    public Ability attackAbility;
    public float attackRange = 5f;
    public float attackInterval = 1f;

    private float nextAttackTime;

    public override void EnterState(AIController aiController)
    {
        nextAttackTime = Time.time;
    }

    public override void UpdateState(AIController aiController)
    {
        if (target != null)
        {
            float distanceToTarget = Vector3.Distance(aiController.transform.position, target.position);

            if (distanceToTarget <= attackRange)
            {
                if (Time.time >= nextAttackTime)
                {
                    // Use attack ability
                    aiController.GetComponent<CharacterCombatController>().PerformAbility(attackAbility, target.gameObject);
                    nextAttackTime = Time.time + attackInterval;
                }
            }
            else
            {
                // Transition to another state if needed, for example, Chase
                aiController.ChangeState(aiController.chaseState);
            }
        }
    }

    public override void ExitState(AIController aiController)
    {
        // Clean up or reset any variables if needed
    }
}

﻿using UnityEngine;
[CreateAssetMenu(menuName = "AI/States/ChaseState")]
public class ChaseState : AIState
{
    public float chaseSpeed = 6f;
    public float stoppingDistance = 2f;

    public override void EnterState(AIController aiController)
    {
        aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().speed = chaseSpeed;
    }

    public override void UpdateState(AIController aiController)
    {
        Transform target = aiController.target;

        if (target != null)
        {
            float distanceToTarget = Vector3.Distance(aiController.transform.position, target.position);

            if (distanceToTarget > stoppingDistance)
            {
                aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().SetDestination(target.position);
            }
            else
            {
                // Transition to another state if needed, for example, Attack
                aiController.ChangeState(aiController.attackState);
            }
        }
    }

    public override void ExitState(AIController aiController)
    {
        // Clean up or reset any variables if needed
    }
}

﻿using UnityEngine;

[CreateAssetMenu(menuName = "AI/States/FollowState")]
public class FollowState : AIState
{
    public Transform target;
    public float stoppingDistance = 2f;

    public override void EnterState(AIController aiController)
    {
    }

    public override void UpdateState(AIController aiController)
    {
        float distanceToTarget = Vector3.Distance(aiController.transform.position, target.position);

        if (distanceToTarget > stoppingDistance)
        {
            aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().SetDestination(target.position);
        }
        else
        {
            aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().ResetPath();
        }
    }

    public override void ExitState(AIController aiController)
    {
    }
}

﻿using UnityEngine;

[CreateAssetMenu(menuName = "AI/States/IdleState")]
public class IdleState : AIState
{
    public float idleDuration = 3f;

    private float idleTime;

    public override void EnterState(AIController aiController)
    {
        idleTime = Time.time + idleDuration;
    }

    public override void UpdateState(AIController aiController)
    {
        if (Time.time > idleTime)
        {
            aiController.ChangeState(aiController.patrolState);
        }
    }

    public override void ExitState(AIController aiController)
    {
    }
}

﻿using System.Collections.Generic;
using UnityEngine;
[CreateAssetMenu(menuName = "AI/States/PatrolState")]
public class PatrolState : AIState
{
    public List<Transform> waypoints;
    public float patrolSpeed = 3f;
    public float waitTime = 3f;

    private int currentWaypoint;
    private float waitEndTime;

    public override void EnterState(AIController aiController)
    {
        aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().speed = patrolSpeed;
        currentWaypoint = 0;
    }

    public override void UpdateState(AIController aiController)
    {
        UnityEngine.AI.NavMeshAgent agent = aiController.GetComponent<UnityEngine.AI.NavMeshAgent>();

        if (waypoints.Count > 0)
        {
            if (!agent.pathPending && agent.remainingDistance < 0.5f)
            {
                if (Time.time > waitEndTime)
                {
                    currentWaypoint = (currentWaypoint + 1) % waypoints.Count;
                    agent.SetDestination(waypoints[currentWaypoint].position);
                    waitEndTime = Time.time + waitTime;
                }
            }
        }
    }

    public override void ExitState(AIController aiController)
    {
        // Clean up or reset any variables if needed
    }
}
﻿using UnityEngine;

public class PatrolStateMonoBehaviour : MonoBehaviour
{
    public GameObject[] waypoints;
}

using UnityEngine.Events;

[System.Serializable]
public class GameEvent : UnityEvent<string> { }
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "Quest", menuName = "ScriptableObjects/Quest", order = 1)]
public class Quest : ScriptableObject
{
    public int id;
    public string title;
    public string description;
    public List<QuestObjective> objectives;
    public List<Reward> rewards;
    public QuestStatus status;

    public Quest(int id, string title, string description)
    {
        this.id = id;
        this.title = title;
        this.description = description;
        this.objectives = new List<QuestObjective>();
        this.rewards = new List<Reward>();
        this.status = QuestStatus.NotStarted;
    }

    public void AddObjective(QuestObjective objective)
    {
        objectives.Add(objective);
    }

    public void AddReward(Reward reward)
    {
        rewards.Add(reward);
    }

    // The missing CheckAndUpdateObjectives method
    public void CheckAndUpdateObjectives(string objectiveId)
    {
        foreach (QuestObjective objective in objectives)
        {
            if ( objective.status == ObjectiveStatus.Incomplete)
            {
                objective.UpdateProgress(objectiveId);
                if (objective.status == ObjectiveStatus.Completed)
                {
                    CheckQuestCompletion();
                }
                break;
            }
        }
    }

    private void CheckQuestCompletion()
    {
        bool allObjectivesComplete = true;
        foreach (QuestObjective objective in objectives)
        {
            if (objective.status != ObjectiveStatus.Completed)
            {
                allObjectivesComplete = false;
                break;
            }
        }

        if (allObjectivesComplete)
        {
            status = QuestStatus.Completed;
        }
    }
}
public enum QuestStatus { NotStarted, InProgress, Completed }
using UnityEngine;

[CreateAssetMenu(fileName = "QuestAction", menuName = "QuestSystem/QuestAction", order = 1)]
public class QuestAction : ScriptableObject
{
    public string actionId;
}

using UnityEngine;

public class QuestGiver : MonoBehaviour, IInteractable
{
    [SerializeField] private Quest quest;
 
    [SerializeField] private GameObject interactionIndicator;

    private bool playerInRange = false;
    private QuestSystem playerQuestSystem;
    private UIManager uiManager;
    public void Start(){
        uiManager = FindObjectOfType<UIManager>();
    }

    void Update()
    {
        if (playerInRange && Input.GetKeyDown(KeyCode.E))
        {
            Interact();
        }
    }
    public void Interact()
    {
        if(uiManager.questUIPresenter.gameObject.activeInHierarchy ){
            uiManager.hideQuestUiPresenter();
        }
        else{
            uiManager.showQuestUiPresenter(quest);
        }
        
    }

    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = true;
            interactionIndicator.SetActive(true);
            playerQuestSystem = other.GetComponent<QuestSystem>();
        }
    }

    void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = false;
            interactionIndicator.SetActive(false);
           
        }
    }


}

public abstract class QuestObjective
{
    public string id;
    public string description;
    public ObjectiveStatus status;
    public abstract bool IsCompleted();

    public abstract void UpdateProgress(string infoId);
    public abstract string GetObjectiveProgress();

}
public enum ObjectiveStatus { Completed,Incomplete };

public class KillObjective : QuestObjective
{
    public string enemyId;
    public int targetKills;
    public int currentKills;

    public KillObjective(string id, string description, string enemyId, int targetKills)
    {
        this.id = id;
        this.description = description;
        this.enemyId = enemyId;
        this.targetKills = targetKills;
        this.currentKills = 0;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string killedEnemyId)
    {
        if (killedEnemyId == "kill:"+enemyId && status != ObjectiveStatus.Completed)
        {
            currentKills++;
            if (currentKills >= targetKills)
            {
                status = ObjectiveStatus.Completed;
            }
        }
    }
    public override string GetObjectiveProgress()
    {
        return currentKills + "/" + targetKills;
    }

    public override bool IsCompleted()
    {
        return status == ObjectiveStatus.Completed;
    }
}

public class GatherObjective : QuestObjective
{
    public string itemId;
    public int targetItems;
    public int currentItems;

    public GatherObjective(string id, string description, string itemId, int targetItems)
    {
        this.id = id;
        this.description = description;
        this.itemId = itemId;
        this.targetItems = targetItems;
        this.currentItems = 0;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string gatheredItemId)
    {
        if (gatheredItemId == "gather:"+itemId && status != ObjectiveStatus.Completed)
        {
            currentItems++;
            if (currentItems >= targetItems)
            {
                status = ObjectiveStatus.Completed;
            }
        }
    }

    public override bool IsCompleted()
    {
        return status == ObjectiveStatus.Completed;
    }
    public override string GetObjectiveProgress()
    {
        return currentItems + "/" + targetItems;
    }
}

public class InspectObjective : QuestObjective
{
    public string locationId;
    public bool locationInspected;

    public InspectObjective(string id, string description, string locationId)
    {
        this.id = id;
        this.description = description;
        this.locationId = locationId;
        this.locationInspected = false;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string inspectedLocationId)
    {
        if (inspectedLocationId == "visit:"+locationId && !locationInspected)
        {
            locationInspected = true;
            status = ObjectiveStatus.Completed;
        }
    }

    public override bool IsCompleted()
    {
        return locationInspected;
    }
    public override string GetObjectiveProgress()
    {
        return locationInspected ? "Inspected" : "Not Inspected";
    }
}

public class ActivateObjective : QuestObjective
{
    public string altarId;
    public bool altarActivated;

    public ActivateObjective(string id, string description, string altarId)
    {
        this.id = id;
        this.description = description;
        this.altarId = altarId;
        this.altarActivated = false;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string activatedAltarId)
    {
        if (activatedAltarId == "activate:"+altarId && !altarActivated)
        {
            altarActivated = true;
            status = ObjectiveStatus.Completed;
        }
    }

    public override bool IsCompleted()
    {
        return altarActivated;
    }
    public override string GetObjectiveProgress()
    {
        return altarActivated ? "Activated" : "Not Activated";
    }
}

using UnityEngine;
using System.Collections.Generic;

public class QuestSystem : MonoBehaviour
{
    public List<Quest> quests;

 
public Quest GetQuestByID(int questID)
{
    foreach (Quest quest in quests)
    {
        if (quest.id == questID)
        {
            return quest;
        }
    }
    return null;
}
    private void Start()
    {
        quests = new List<Quest>();
    }

    public void AddQuest(Quest quest)
    {
       
        quests.Add(quest);
    }

    public void RemoveQuest(int questId)
    {
        Quest questToRemove = quests.Find(q => q.id == questId);
        if (questToRemove != null)
        {
          
            quests.Remove(questToRemove);
        }
    }
        public void UpdateQuestObjective(string objectiveId)
    {
        foreach (Quest quest in quests)
        {
            if (quest.status != QuestStatus.Completed)
            {
                quest.CheckAndUpdateObjectives(objectiveId);
            }
        }
    }

   
}

using UnityEngine;

[System.Serializable]
public class Reward
{
    public string rewardId;
    public string rewardName;
    public int quantity;

    public Reward(string rewardId, string rewardName, int quantity)
    {
        this.rewardId = rewardId;
        this.rewardName = rewardName;
        this.quantity = quantity;
    }
}

using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "HuntWolves", menuName = "ScriptableObjects/Quests/HuntWolves", order = 1)]
public class HuntWolvesQuest : Quest
{
    public HuntWolvesQuest() : base(1, "Hunt the Wolves", "The village has been suffering from frequent wolf attacks. They've asked you to hunt down 10 wolves and bring back their pelts as proof.")
    {
        // Add a KillObjective to the list of objectives
        AddObjective(new KillObjective("HuntWolvesObjective", "Hunt 10 Wolves", "Wolf", 10));
    }
}

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

﻿using UnityEngine;
using UnityEngine.UI;

public class CharacterStatsUI : MonoBehaviour
{
    public Text unspentStatPointsText;
    public Text strengthText;
    public Text intelligenceText;
    public Text dexterityText;
    public Text enduranceText;
    public Text wisdomText;

    public Button strengthButton;
    public Button intelligenceButton;
    public Button dexterityButton;
    public Button enduranceButton;
    public Button wisdomButton;

    public CharacterStats characterStats;

    private void Start()
    {
        strengthButton.onClick.AddListener(() => IncreaseStat(Archetype.Strength));
        intelligenceButton.onClick.AddListener(() => IncreaseStat(Archetype.Intelligence));
        dexterityButton.onClick.AddListener(() => IncreaseStat(Archetype.Dexterity));
        enduranceButton.onClick.AddListener(() => IncreaseStat(Archetype.Endurance));
        wisdomButton.onClick.AddListener(() => IncreaseStat(Archetype.Wisdom));

        characterStats.StatsChanged += UpdateUI;
        UpdateUI();
    }

    private void Awake()
    {
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
    }

    private void UpdateUI()
    {
        unspentStatPointsText.text = "Unspent Points: " + characterStats.unspentStatPoints;
        strengthText.text = "Strength: " + characterStats.strength;
        intelligenceText.text = "Intelligence: " + characterStats.intelligence;
        dexterityText.text = "Dexterity: " + characterStats.dexterity;
        enduranceText.text = "Endurance: " + characterStats.endurance;
        wisdomText.text = "Wisdom: " + characterStats.wisdom;
    }

    private void IncreaseStat(Archetype mainStatType)
    {
        characterStats.IncreaseStat(mainStatType, 1);
    }
}

﻿using UnityEngine;
using UnityEngine.UI;

public class CharacterUi : MonoBehaviour
{
    public Text unspentStatPointsText;
    public Text strengthText;
    public Text intelligenceText;
    public Text dexterityText;
    public Text enduranceText;
    public Text wisdomText;



    public Text subStatsPhysical;
    public Text subStatsSpellCasting;
    public Text subStatsDefensive;
    public Text subStatsUniversal;

    public Button openCharacterStatsMenu;
    public Image unspentStatPoints;

    public CharacterStats characterStats;
    public UIManager uiManager;

    private void Start()
    {
        openCharacterStatsMenu.onClick.AddListener(() => uiManager.OpenCharacterStatusUI());
        characterStats.StatsChanged += UpdateUI;
        UpdateUI();
    }

    private void Awake()
    {
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
    }

    private void UpdateUI()
    {
        strengthText.text = "Strength: " + characterStats.strength;
        intelligenceText.text = "Intelligence: " + characterStats.intelligence;
        dexterityText.text = "Dexterity: " + characterStats.dexterity;
        enduranceText.text = "Endurance: " + characterStats.endurance;
        wisdomText.text = "Wisdom: " + characterStats.wisdom;

        subStatsPhysical.text = "Critical Chance: " + characterStats.criticalChance.ToString("F1") + "%" + "\nCritical Damage: " + characterStats.criticalDamage + "%" + "\nAttack Speed: " + characterStats.attackSpeed.ToString("F2");
        subStatsSpellCasting.text = "Spell Crit Chc: " + characterStats.spellCriticalChance.ToString("F1") + "%" + "\nSpell Crit Dmg: " + characterStats.spellCriticalDamage + "%" + "\nCooldown: " + characterStats.cooldown;
        subStatsDefensive.text = "Armor: " + characterStats.armor + "\nMagic Resi: " + characterStats.magicResistance + "\nDodge Chance: " + characterStats.dodgeChance.ToString("F1") + "%";
        subStatsUniversal.text = "Max Life: " + characterStats.maxLife + "\nLife Reg: " + characterStats.lifeRegen + "\nMax Mana: " + characterStats.maxMana + "\nMana Reg: " + characterStats.manaRegen;
    }

}

﻿using TMPro;
using UnityEngine;

public class DamageNumberController : MonoBehaviour
{
    public TextMeshPro textMeshPro;
    public float floatSpeed = 1f;
    public float duration = 1.5f;

    private float elapsedTime = 0f;
    private Camera playerCamera;

    private void Start()
    {
        playerCamera = Camera.main;
    }

    public void SetDamageValue(float damage)
    {
        if (textMeshPro == null)
        {
            Debug.LogError("TextMeshPro component is not assigned in the DamageNumberController component.");
            return;
        }

        textMeshPro.text = damage.ToString();
    }

    private void Update()
    {
        if (textMeshPro == null)
        {
            Destroy(gameObject);
            return;
        }

        // Rotate towards player camera
        if (playerCamera != null)
        {
            FaceCamera();
        }

        // Float upwards
        transform.position += Vector3.up * floatSpeed * Time.deltaTime;

        // Update the elapsed time
        elapsedTime += Time.deltaTime;

        // Fade effect
        textMeshPro.alpha = Mathf.Clamp01(1f - (elapsedTime / duration));

        // Destroy the damage number after the duration
        if (elapsedTime >= duration)
        {
            Destroy(gameObject);
        }
    }

    private void FaceCamera()
    {
        Vector3 targetDirection = playerCamera.transform.position - transform.position;
        targetDirection.y = 0;
        Quaternion targetRotation = Quaternion.LookRotation(-targetDirection);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 1);
    }
}

using UnityEngine;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance;

    public enum GameState { InMenu, Playing, Paused, GameOver }
    public GameState currentState;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }

        // Initialize game state and other systems as needed
        currentState = GameState.InMenu;
    }

    private void Update()
    {
        HandleGameState();
        UpdateCursorVisibility();
    }

    private void UpdateCursorVisibility()
    {
        // If the game is paused or in a menu, show the cursor
        if (currentState == GameState.Paused || currentState == GameState.InMenu)
        {
            Cursor.visible = true;
            Cursor.lockState = CursorLockMode.None;
        }
        // If the game is playing, hide the cursor
        else if (currentState == GameState.Playing)
        {
            Cursor.visible = false;
            Cursor.lockState = CursorLockMode.Locked;
        }
    }

    private void HandleGameState()
    {
        switch (currentState)
        {
            case GameState.InMenu:
                // Handle main menu logic
                break;
            case GameState.Playing:
                // Handle playing state logic
                break;
            case GameState.Paused:
                // Handle paused state logic
                break;
            case GameState.GameOver:
                // Handle game over logic
                break;
        }
    }

    public void ChangeGameState(GameState newState)
    {
        currentState = newState;
    }
    public void SaveGame()
    {
        // Implement save game logic
    }

    public void LoadGame()
    {
        // Implement load game logic
    }
    // Implement other methods as needed, such as SaveGame, LoadGame, etc.
}
﻿using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode, ImageEffectAllowedInSceneView]
public class OutlineHighlight : MonoBehaviour
{
    public Material highlightMaterial;
    public Color highlightColor = Color.red;
    public float outlineThickness = 2f;
    public Transform target;

    private Camera cam;
    private CommandBuffer commandBuffer;

    private void Start()
    {
        cam = GetComponent<Camera>();
        commandBuffer = new CommandBuffer();
    }

    private void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (target == null)
        {
            Graphics.Blit(src, dest);
            return;
        }

        commandBuffer.Clear();

        var renderTexture = RenderTexture.GetTemporary(src.width, src.height, src.depth, src.format);

        commandBuffer.SetRenderTarget(renderTexture);

        commandBuffer.ClearRenderTarget(true, true, Color.clear);

        var meshFilter = target.GetComponent<MeshFilter>();
        if (meshFilter != null)
        {
            commandBuffer.DrawMesh(meshFilter.sharedMesh, target.localToWorldMatrix, highlightMaterial);
        }

        highlightMaterial.SetColor("_OutlineColor", highlightColor);
        highlightMaterial.SetFloat("_OutlineThickness", outlineThickness);

        Graphics.ExecuteCommandBuffer(commandBuffer);

        Graphics.Blit(renderTexture, dest);

        RenderTexture.ReleaseTemporary(renderTexture);
    }
}

using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class PresentQuestUiController : MonoBehaviour
{
    [SerializeField] private TMP_Text questTitle;
    [SerializeField] private TMP_Text questDescription;
    [SerializeField] private Button acceptButton;
    [SerializeField] private Button declineButton;

    private QuestSystem questSystem;
    void Start()
    {
        questSystem = FindObjectOfType<QuestSystem>();
    }
  

    public void showQuestInfo(Quest quest,UIManager UIManager)
    {
        questTitle.text = quest.title;
        questDescription.text = quest.description;
        acceptButton.onClick.AddListener(() => questSystem.AddQuest(quest));
        acceptButton.onClick.AddListener(() => UIManager.hideQuestUiPresenter());
        declineButton.onClick.AddListener(() => UIManager.hideQuestUiPresenter());
        
    }

}

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class QuestBookUIController : MonoBehaviour
{
    public TMP_Text titleText;
    public TMP_Text descriptionText;
    public TMP_Text objectivesText;
    public ScrollRect questListScrollRect;
    public GameObject questListItemPrefab;
    public Transform questListContent;
    
    private QuestSystem questSystem;
    private List<Quest> questList = new List<Quest>();

    private void Awake()
    {
        questSystem = FindObjectOfType<QuestSystem>();
        if (questSystem == null)
        {
            Debug.LogError("No QuestSystem found in the scene!");
        }
    }

    private void Start()
    {
        UpdateQuestList();
    }

    public void UpdateQuestList()
    {
        // Clear the quest list content
        foreach (Transform child in questListContent)
        {
            Destroy(child.gameObject);
        }

        // Re-populate the quest list content
        questList = questSystem.quests;
        foreach (Quest quest in questList)
        {
            GameObject questListItem = Instantiate(questListItemPrefab, questListContent);
            questListItem.GetComponentInChildren<TMP_Text>().text = quest.title;
            questListItem.GetComponent<Button>().onClick.AddListener(() => ShowQuestInformation(quest));
        }

        // Reset the scroll position of the quest list
        questListScrollRect.verticalNormalizedPosition = 1f;
    }

    public void ShowQuestInformation(Quest quest)
    {
        // Set the quest information text fields to the current quest's data
        titleText.text = quest.title;
        descriptionText.text = quest.description;
        string objectivesString = "";
        foreach(QuestObjective objective in quest.objectives)
        {
            objectivesString += $"-({objective.GetObjectiveProgress()})\n";
        }   
        
    }
}

using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class QuestLogUIController : MonoBehaviour
{
    public TMP_Text questLogText;
    public TMP_Text trackingText;

    private QuestSystem questSystem;
    private List<Quest> trackingQuests = new List<Quest>();

    private void Awake()
    {
        questSystem = FindObjectOfType<QuestSystem>();
        if (questSystem == null)
        {
            Debug.LogError("No QuestSystem found in the scene!");
        }
    }

    private void Start()
    {
        UpdateQuestLog();
    }

    public void UpdateQuestLog()
    {
        string questLogString = "";
        foreach (Quest quest in questSystem.quests)
        {
            questLogString += $"[{quest.status}] {quest.title}\n";
            foreach (QuestObjective objective in quest.objectives)
            {
                questLogString += $"- {objective.description} ({objective.GetObjectiveProgress()})\n";
            }
            questLogString += "\n";
        }
        questLogText.text = questLogString;

        string trackingString = "Tracking: ";
        foreach (Quest quest in trackingQuests)
        {
            trackingString += quest.title + ", ";
        }
        trackingText.text = trackingString.TrimEnd(',', ' ');
    }

    public void AddQuestToTrack(int questID)
    {
        Quest quest = questSystem.GetQuestByID(questID);
        if (quest != null && !trackingQuests.Contains(quest))
        {
            trackingQuests.Add(quest);
            UpdateQuestLog();
        }
    }

    public void RemoveQuestToTrack(int questID)
    {
        Quest quest = questSystem.GetQuestByID(questID);
        if (quest != null && trackingQuests.Contains(quest))
        {
            trackingQuests.Remove(quest);
            UpdateQuestLog();
        }
    }
}

﻿using UnityEngine;

public class SkillTreeMenuController : MonoBehaviour
{
    public GameObject[] skillTrees;
    public int currentSkillTree = 0;
    private void Start()
    {
         skillTrees[currentSkillTree].SetActive(true);
    }

    public void SwitchSkillTree(int index)
    {
        if (index < 0 || index >= skillTrees.Length) return;

        skillTrees[currentSkillTree].SetActive(false);
        skillTrees[index].SetActive(true);
        currentSkillTree = index;
    }
}

﻿// UIManager.cs
using UnityEngine;
public class UIManager : MonoBehaviour
{
    public GameObject pauseMenu;
    public GameObject mainMenu;
    public GameObject characterStatusUI;
    public GameObject characterUi;
    public GameObject tooltipSkills;
    public GameObject skillTreeMenu;
    private ToolTipUiController toolTipSkillsController;
    public PresentQuestUiController questUIPresenter;


public void showQuestUiPresenter(Quest quest){
    GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
    questUIPresenter.showQuestInfo(quest,this);
    questUIPresenter.gameObject.SetActive(true);
}
public void hideQuestUiPresenter(){
    GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
    questUIPresenter.gameObject.SetActive(false);
}

    private void Update()
    {
        // Check for user input to pause/unpause the game
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (GameManager.Instance.currentState == GameManager.GameState.Playing)
            {
                PauseGame();
            }
            else if (GameManager.Instance.currentState == GameManager.GameState.Paused)
            {
                UnpauseGame();
            }
        }

        // Check for user input to open/close the CharacterStatusUI
        if (Input.GetKeyDown(KeyCode.C))
        {
            if (GameManager.Instance.currentState == GameManager.GameState.Playing)
            {
                OpenCharacterUi();
            }
            else if (GameManager.Instance.currentState == GameManager.GameState.InMenu)
            {
                CloseCharacterUi();
            }
        }
        if(Input.GetKeyDown(KeyCode.Tab)){
            if (GameManager.Instance.currentState == GameManager.GameState.Playing)
            {
                OpenSkillTreeMenu();
            }
            else if (GameManager.Instance.currentState == GameManager.GameState.InMenu)
            {
                CloseSkillTreeMenu();
            }
        }
    }
    public void Awake()
    {
        toolTipSkillsController = tooltipSkills.GetComponent<ToolTipUiController>();
    }

    public void PauseGame()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Paused);
        Time.timeScale = 0f;
//        pauseMenu.SetActive(true);
    }

    public void UnpauseGame()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        Time.timeScale = 1f;
        pauseMenu.SetActive(false);
    }

    public void ShowMainMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        mainMenu.SetActive(true);
    }

    public void HideMainMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        mainMenu.SetActive(false);
    }
    public void OpenCharacterStatusUI()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        characterStatusUI.SetActive(true);
    }
    public void OpenCharacterUi()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        characterUi.SetActive(true);
    }
    public void CloseCharacterUi()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        characterUi.SetActive(false);
    }
    public void OpenSkillTreeMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        skillTreeMenu.SetActive(true);
    }
    public void CloseSkillTreeMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        CloseToolTipSkill();
        skillTreeMenu.SetActive(false);
    }
    public void CloseCharacterStatusUI()
    {
        characterStatusUI.SetActive(false);
    }
    public void OpenToolTipSkill(SkillNode node, Vector3 Positon)
    {
        tooltipSkills.gameObject.SetActive(true);
        tooltipSkills.gameObject.GetComponent<RectTransform>().position = Positon;
        toolTipSkillsController.UpdateUI(node);
    }
    public void CloseToolTipSkill()
    {
        tooltipSkills.gameObject.SetActive(false);
    }
}

﻿using UnityEngine;

public class WorldSpaceCanvasController : MonoBehaviour
{
    public static WorldSpaceCanvasController Instance;

    public GameObject damageNumberPrefab;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SpawnDamageNumber(float damage, Vector3 position)
    {
        if (damageNumberPrefab == null)
        {
            Debug.LogError("DamageNumberPrefab is not assigned in the WorldSpaceCanvasController component.");
            return;
        }

        GameObject damageNumberInstance = Instantiate(damageNumberPrefab, position, Quaternion.identity, transform);
        damageNumberInstance.gameObject.SetActive(true);
        DamageNumberController damageNumberController = damageNumberInstance.GetComponent<DamageNumberController>();


        if (damageNumberController != null)
        {
            damageNumberController.SetDamageValue(damage);
        }
        else
        {
            Debug.LogError("DamageNumberController component is missing on the DamageNumberPrefab.");
            Destroy(damageNumberInstance);
        }
    }
}

