- Ability at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\Ability.cs:
Summery of Ability:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\Ability.cs
This file named Ability.cs defines an abstract class called Ability that inherits from ScriptableObject in Unity. It has various attributes such as abilityName, baseDamage, strengthScaling, and intelligenceScaling which determine the characteristics of the ability. Additionally, it has abstract methods named OnAbilityObjectHit and Activate that specific abilities must implement in order to work. It also has protected virtual methods named StartActivation, UpdateActivation, and EndActivation that subclasses may override to add functionality to an ability's activation process. 

The class also declares several delegate types and events for use within the ability system. For instance, the AbilityObjectEvent is a delegate for methods that receive an instance of AbilityObject and a GameObject as arguments. The class contains two public event fields: OnAbilityObjectSpawnedEvent and OnAbilityObjectHitEvent, both of which are of type AbilityObjectEvent and can be subscribed to by other methods. The OnAbilityActivated event is also a public field of type AbilityEvent and is raised when an ability is activated. Finally, the file also contains a public class called AbilityData, which carries information related to an ability's use, such as the target, CasterStats, CasterController, damage, projectileSpeed, and stunDuration.
Code of file Ability:
﻿using UnityEngine;
public abstract class Ability : ScriptableObject
{
    public string abilityName;
    public string abilityDescription;
    public Sprite icon;
    public float baseDamage;
    public float strengthScaling;
    public float intelligenceScaling;
    
    public float cooldown;
    public string animationName;
    public float lastTimeUsed = 0;
    public float ActivateDelayTime = 0;

    

    public abstract void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target);
    public abstract void Activate(AbilityData abilityData);

    public virtual void PreActivateAbility(AbilityData abilityData){

    }
    protected virtual void StartActivation(AbilityData abilityData) { }
    protected virtual void UpdateActivation(AbilityData abilityData) { }
    protected virtual void EndActivation(AbilityData abilityData) { }

     public delegate void AbilityEvent(Ability ability);
     public delegate void AbilityObjectEvent(AbilityObject abilityObject, GameObject target);

     public event AbilityObjectEvent OnAbilityObjectSpawnedEvent;
     public event AbilityObjectEvent OnAbilityObjectHitEvent;
  
    public event AbilityEvent OnAbilityActivated;
    public float getLastTimeUsed()
    {
        return lastTimeUsed;
    }
    public float setLastTimeUsed(float time)
    {
        return lastTimeUsed = time;
    }
    protected void RaiseOnObjectSpawned(AbilityObject abilityObject,GameObject target)
    {
        OnAbilityObjectSpawnedEvent?.Invoke(abilityObject,null);
    }
   
    protected void RaiseOnObjectHit(AbilityObject abilityObject, GameObject target)
    {
        OnAbilityObjectHitEvent?.Invoke(abilityObject, target);
    }
    protected void RaiseOnAbilityActivated()
    {
        OnAbilityActivated?.Invoke(this);
    }
    

}

public class AbilityData
{
    public GameObject Target;
    public CharacterStats CasterStats;
    public AbilityController CasterController;
    public CharacterCombatController CasterCombatController;
    public float damage;
    public float projectileSpeed;
    public float stunDuration;

}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\Ability.cs
Ability.cs:
- abilityName: string
- abilityDescription: string
- icon: Sprite
- baseDamage: float
- strengthScaling: float
- intelligenceScaling: float
- cooldown: float
- animationName: string
- lastTimeUsed: float = 0
- ActivateDelayTime: float = 0
- OnAbilityObjectSpawnedEvent: event (AbilityObject, GameObject)
- OnAbilityObjectHitEvent: event (AbilityObject, GameObject)
- OnAbilityActivated: event (Ability)
- OnAbilityObjectHit: abstract void (AbilityObject, GameObject)
- Activate: abstract void (AbilityData)
- PreActivateAbility: virtual void (AbilityData)
- StartActivation: protected virtual void (AbilityData)
- UpdateActivation: protected virtual void (AbilityData)
- EndActivation: protected virtual void (AbilityData)
- getLastTimeUsed: float
- setLastTimeUsed: float
- RaiseOnObjectSpawned: protected void (AbilityObject, GameObject)
- RaiseOnObjectHit: protected void (AbilityObject, GameObject)
- RaiseOnAbilityActivated: protected void ()
  
AbilityData:
- Target: GameObject
- CasterStats: CharacterStats
- CasterController: AbilityController
- CasterCombatController: CharacterCombatController
- damage: float
- projectileSpeed: float
- stunDuration: float

- AbilityControllData at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityControllData.cs:
Summery of AbilityControllData:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityControllData.cs
"AbilityControllData.cs" is a script that contains class "AbilityControllData", which is used to control abilities in the game. The class has four public variables, including "type" which stores the type of ability, "direction" which stores the direction of the ability, "target" which stores the target game object, and "targetPosition" which stores the target position of the ability. This script is essential for managing abilities in the game and provides easy access to information related to the abilities."
Code of file AbilityControllData:
﻿using UnityEngine;
class AbilityControllData
{
    public string type;
    public Vector3 direction;
    public GameObject target;
    public Vector3 targetPosition;
}


Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityControllData.cs
AbilityControllData:
- type: string
- direction: Vector3
- target: GameObject
- targetPosition: Vector3

- AbilityObject at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityObject.cs:
Summery of AbilityObject:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityObject.cs
The file named AbilityObject.cs contains a class that defines an ability object. It has properties for events OnHit, OnUpdate, OnSpawn, and OnDelete, which are triggered during various stages of the ability's lifecycle. The object has an AbilityData property and a boolean shouldDestroy, deleteOnCollision, and deleteOnTimer. It also has a ParentAbility property. The HandleOnHit method sets the shouldDestroy boolean to true if deleteOnCollision is true. The Update method increases the timer if deleteOnTimer is true and triggers the HandleOnDelete method if the timer exceeds the timerMax. The HandleOnSpawn method is called during the Awake method, which initializes the ability object. The HandleOnDelete method is called during the OnTriggerEnter method, which identifies the target of the ability object by their collider component and triggers the HandleOnHit method. The file also includes interfaces for bouncing, piercing, and homing ability objects.
Code of file AbilityObject:
﻿using System;
using UnityEngine;

public class AbilityObject : MonoBehaviour
{
    public event Action<GameObject> OnHit;
    public event Action OnUpdate;
    public event Action OnSpawn;
    public event Action OnDelete;
    public AbilityData data;

    public bool shouldDestroy=false;

    public bool deleteOnCollision = true;
    public bool deleteOnTimer = false;
    float timer = 0f;
    public float timerMax = 5f;

    

    public Ability ParentAbility { get; set; }

    protected virtual void HandleOnHit(GameObject target)
    {
        // Trigger OnHit event with target as parameter
        OnHit?.Invoke(target);
  
        if(deleteOnCollision){
            shouldDestroy = true;
        }
    }

    private void Update()
    {
        // Trigger OnHit event with target as parameter
        OnUpdate?.Invoke();
        if(deleteOnTimer){
            timer += Time.deltaTime;
            if(timer >= timerMax){
                timer = 0f;
                HandleOnDelete();
            }
        }
  
    }

    protected void HandleOnSpawn()
    {
        // Perform any initialization or setup for the ability object here
        // Trigger OnSpawn event
        OnSpawn?.Invoke();
        
  
    }

    protected void HandleOnDelete()
    {
        // Perform any cleanup or deactivation for the ability object here
        // Trigger OnDelete event
        OnDelete?.Invoke();
        Destroy(gameObject);
        
    }

    public void Awake()
    {
        HandleOnSpawn();
    }

    private void OnTriggerEnter(Collider collision)
    {
        Debug.Log("OnTriggerEnter");
        if(data == null){
            Debug.LogError("AbilityObject data is null");
            return;
        }
        // Get target HealthController from collided object
        if (data.CasterStats != null)
        {
            if (data.CasterStats.gameObject.name == collision.gameObject.name)
            {
                return;
            }
            if (gameObject.name == collision.gameObject.name)
            {
                return;
            }
        }

            
            // Call HandleOnHit method with target as parameter
            ParentAbility?.OnAbilityObjectHit(this, collision.gameObject);
            HandleOnHit(collision.gameObject);

    }
}
public interface IBouncingAbilityObject
{
     float BounceIntensity { get; set; }
    float BounceDuration { get; set; }
    void Bounce(GameObject target);
}

public interface IPiercingAbilityObject
{
    void Pierce(GameObject target);
}

public interface IHomingAbilityObject
{
    void Home(GameObject target);
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityObject.cs
AbilityObject:
- event OnHit (GameObject)
- event OnUpdate
- event OnSpawn
- event OnDelete
- data: AbilityData
- shouldDestroy: bool
- deleteOnCollision: bool
- deleteOnTimer: bool
- timer: float
- timerMax: float
- ParentAbility: Ability

- HandleOnHit(target: GameObject)
- Update()
- HandleOnSpawn()
- HandleOnDelete()
- Awake()
- OnTriggerEnter(collision: Collider)

IBouncingAbilityObject:
- BounceIntensity: float
- BounceDuration: float

- Bounce(target: GameObject)

IPiercingAbilityObject:

- Pierce(target: GameObject)

IHomingAbilityObject:

- Home(target: GameObject)

- BaseProjectileObject at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\BaseProjectileObject.cs:
Summery of BaseProjectileObject:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\BaseProjectileObject.cs
The file BaseProjectileObject.cs is located in the AbilitysSkillsAndBuffsItems/Abilitys folder of the Unity project directory. This file contains a class that inherits from the AbilityObject class and implements two interfaces, IBouncingAbilityObject and IPiercingAbilityObject. The class represents a base projectile object that can bounce off surfaces and pierce through targets.

The class has two public float properties, BounceIntensity and BounceDuration, and two public int properties, bounceCount and pierceCount, which are used for determining the projectile's bouncing and piercing behavior.

The HandleOnHit() method is called when the projectile hits a target. If the projectile was cast by a character with stats, it applies damage to the target. The method then checks if the projectile should bounce or pierce, handles the appropriate logic, and optionally deletes the projectile.

The Bounce() method is called when the projectile should bounce off a surface. It sets shouldDestroy to false, decrements the bounceCount property, calculates the bounce direction using the target's surface normal, and assigns the new direction to the projectile's transform. Finally, it applies the calculated bounce direction to the projectile's rigidbody velocity.

The Pierce() method is called when the projectile should pierce through a target. It decrements the pierceCount property and sets shouldDestroy to false.

Overall, this class provides a flexible base for creating different types of projectiles with varying bouncing and piercing properties.
Code of file BaseProjectileObject:
using System.Collections;
using UnityEngine;
public class BaseProjectileObject : AbilityObject, IBouncingAbilityObject, IPiercingAbilityObject
{
    public float BounceIntensity { get; set; }
    public float BounceDuration { get; set; }

    public int bounceCount;
    public int pierceCount;


    protected override void HandleOnHit(GameObject target)
    {
    // Apply damage to the target
        if (data.CasterStats != null)
        {
            HealthController targetStats = target.GetComponent<HealthController>();
            if (targetStats != null)
            {
                float damage = data.damage;
                targetStats.TakeDamage(damage, data.CasterStats.gameObject);
            }
        }

        // Handle Bounce and Pierce logic
        shouldDestroy = deleteOnCollision;
        if (bounceCount > 0)
        {
            Bounce(target);
        }
        else if (pierceCount > 0)
        {
            Pierce(target);
        }

        if (shouldDestroy)
        {
            HandleOnDelete();
        }
       
    }

    public void Bounce(GameObject target)
    {
        
        shouldDestroy = false;
        bounceCount--;

        Vector3 bounceDirection = Vector3.Reflect(transform.forward, target.transform.up);
        transform.forward = bounceDirection;

        Rigidbody rb = GetComponent<Rigidbody>();
        rb.velocity = bounceDirection * data.projectileSpeed;

        
    }

    public void Pierce(GameObject target)
    {

        pierceCount--;

        shouldDestroy = false;
    }

   
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\BaseProjectileObject.cs
Class Name: BaseProjectileObject

BounceIntensity: float
BounceDuration: float
bounceCount: int
pierceCount: int

HandleOnHit(target: GameObject):
    If data.CasterStats is not null:
        targetStats = target.GetComponent<HealthController>()
        If targetStats is not null:
            damage = data.damage
            targetStats.TakeDamage(damage, data.CasterStats.gameObject)

    shouldDestroy = deleteOnCollision
    If bounceCount > 0:
        Bounce(target)
    Else If pierceCount > 0:
        Pierce(target)

    If shouldDestroy:
        HandleOnDelete()

Bounce(target: GameObject):
    shouldDestroy = false
    bounceCount--
    bounceDirection = Vector3.Reflect(transform.forward, target.transform.up)
    transform.forward = bounceDirection
    rb = GetComponent<Rigidbody>()
    rb.velocity = bounceDirection * data.projectileSpeed

Pierce(target: GameObject):
    pierceCount--
    shouldDestroy = false

- DefaultProjectileAbility at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultProjectileAbility.cs:
Summery of DefaultProjectileAbility:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultProjectileAbility.cs
The file "DefaultProjectileAbility.cs" is a script for creating a default projectile ability in Unity. It is part of a larger folder of scripts related to abilities, skills, buffs, and items.

The script includes a public variable for the projectile's prefab and speed, and two override methods for activating the projectile ability and handling what happens when the projectile hits a target.

When the projectile hits a target, the script checks to see if the caster's stats are present and, if so, deals damage to the target through the HealthController component.

When the ability is activated, the script spawns a new projectile at the caster's fire point, sets its velocity to the desired speed, and assigns the projectile's data and parent ability.

The script primarily uses Unity's built-in classes for game objects, transforms, and rigidbodies to manipulate objects and pass data between functions.
Code of file DefaultProjectileAbility:
using System.Collections;
using UnityEngine;

// Base Projectile Ability class
[CreateAssetMenu(menuName = "Abilities/DefaultProjectileAbility")]
public class DefaultProjectileAbility : Ability
{
    public GameObject projectilePrefab;
    public float projectileSpeed = 5f;

    public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
    {
        if(abilityObject.data.CasterStats != null)
        {
            HealthController targetStats = target.GetComponent<HealthController>();
            if (targetStats != null)
            {
                float damage = abilityObject.data.damage;
                targetStats.TakeDamage(damage,abilityObject.data.CasterStats.gameObject);
            }
        }
         RaiseOnObjectHit(abilityObject,target);
  

    }

    public override void Activate(AbilityData abilityData)
    {
        if (abilityData.CasterStats == null) return;

        Transform firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint;
        
        GameObject projectileInstance = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation);
        BaseProjectileObject abilityObject = projectileInstance.GetComponent<BaseProjectileObject>();
        RaiseOnObjectSpawned(abilityObject,null);

        Rigidbody rb = projectileInstance.GetComponent<Rigidbody>();
        rb.velocity = firePoint.forward * projectileSpeed;

        
        abilityObject.ParentAbility = this;
        abilityObject.data = abilityData;
        abilityData.projectileSpeed = projectileSpeed;
    }
}

// Base Projectile Object class


Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultProjectileAbility.cs
DefaultProjectileAbility:
- projectilePrefab: GameObject
- projectileSpeed: float

- OnAbilityObjectHit(abilityObject, target):
   - if(abilityObject.data.CasterStats != null):
       - targetStats = target.GetComponent<HealthController>()
       - if (targetStats != null):
           - damage = abilityObject.data.damage
           - targetStats.TakeDamage(damage,abilityObject.data.CasterStats.gameObject)

   - RaiseOnObjectHit(abilityObject,target)
  

- Activate(abilityData):
    - if (abilityData.CasterStats == null):
        - return

    - firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint
    - projectileInstance = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation)
    - abilityObject = projectileInstance.GetComponent<BaseProjectileObject>()
    - RaiseOnObjectSpawned(abilityObject,null)

    - rb = projectileInstance.GetComponent<Rigidbody>()
    - rb.velocity = firePoint.forward * projectileSpeed

        
    - abilityObject.ParentAbility = this
    - abilityObject.data = abilityData
    - abilityData.projectileSpeed = projectileSpeed

- DefaultSkill at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultSkill.cs:
Summery of DefaultSkill:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultSkill.cs
The file name is "DefaultSkill.cs" and it is located in the folder "Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys". It utilizes the Unity engine.

This script uses the "CreateAssetMenu" attribute to create a new asset menu item called "Skill" with a sub-menu called "Skill". This allows the ability to create a new skill asset in the Unity editor.

The "DefaultSkill" class inherits from the "Skill" class, indicating that it represents a skill in the game. The internal logic of this script is not explicitly defined in this excerpt, as it only defines the class itself.

Overall, the purpose of this script is to provide a framework for creating new skills in the game, accessible through the Unity editor.
Code of file DefaultSkill:
﻿
using UnityEngine;

[CreateAssetMenu(fileName = "Skill", menuName = "Skill/Skill", order = 1)]
public class DefaultSkill : Skill
{

}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultSkill.cs
DefaultSkill:
- CreateAssetMenu:
    - fileName = "Skill"
    - menuName = "Skill/Skill"
    - order = 1
- Skill

- FireBall at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\FireBall.cs:
Summery of FireBall:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\FireBall.cs
The file "FireBall.cs" is a script used to create a fireball ability in a Unity game. It inherits from the "DefaultProjectileAbility" class. 

The "OnAbilityObjectHit" function is called when the fireball hits an object. If the caster of the ability is not null, it will try to damage the object hit if it has a "HealthController" component. 

The "Activate" function is called when the ability is activated. It first checks if the caster stats are not null. It then retrieves the caster's "firePoint" transform from the "AbilityController" component and instantiates a fireball object at that location using the projectile prefab. The fireball's velocity is set in the direction of the firePoint with the projectileSpeed. It also sets the parent ability and ability data for the projectile object. 

This script is used to create and control the behavior of a fireball ability in Unity by defining its logic for activation and when it hits an object.
Code of file FireBall:
using UnityEngine;
[CreateAssetMenu(menuName = "Abilities/Fireball")]
class FireBall : DefaultProjectileAbility {
    //Expecting BaseProjectileObject to be a prefab
  public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target) {
    if (abilityObject.data.CasterStats != null) {
      HealthController targetHealth = target.GetComponent<HealthController>();
      if (targetHealth != null) {
        float damage = abilityObject.data.damage;
        targetHealth.TakeDamage(damage,abilityObject.data.CasterStats.gameObject);
      }
    }
    RaiseOnObjectHit(abilityObject, target);
  }

    public override void Activate(AbilityData abilityData) {
    if (abilityData.CasterStats == null) return;

    Transform firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint;

    GameObject projectileInstance = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation);
    BaseProjectileObject abilityObject = projectileInstance.GetComponent<BaseProjectileObject>();
    RaiseOnObjectSpawned(abilityObject, null);

    Rigidbody rb = projectileInstance.GetComponent<Rigidbody>();
    rb.velocity = firePoint.forward * projectileSpeed;

    abilityObject.ParentAbility = this;
    abilityObject.data = abilityData;
    abilityData.projectileSpeed = projectileSpeed;
  }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\FireBall.cs
File name: FireBall.cs

Class: FireBall (inherits DefaultProjectileAbility)

- CreateAssetMenu (menuName = "Abilities/Fireball")
- Override OnAbilityObjectHit (abilityObject, target)
  - If abilityObject.data.CasterStats exists, get target's HealthController component
  - If targetHealth exists, get damage from abilityObject.data, and call TakeDamage() on targetHealth with damage and abilityObject.data.CasterStats.gameObject as arguments
  - RaiseOnObjectHit with abilityObject and target as arguments
- Override Activate (abilityData)
  - If abilityData.CasterStats is null, return
  - Get firePoint from abilityData.CasterStats's AbilityController component
  - Instantiate projectilePrefab at firePoint's position and rotation, and get its BaseProjectileObject component
  - RaiseOnObjectSpawned with abilityObject and null as arguments
  - Get Rigidbody component from projectileInstance, and set its velocity to firePoint's forward direction multiplied by projectileSpeed
  - Set abilityObject's ParentAbility and data to this and abilityData, respectively
  - Set abilityData's projectileSpeed to projectileSpeed.

- ShieldBash at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ShieldBash.cs:
Summery of ShieldBash:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ShieldBash.cs
The ShieldBash.cs file is a script for an ability called "Shield Bash" in a game. It inherits from a base class named "Ability" and is decorated with the CreateAssetMenu attribute to allow it to be created as an asset within the Unity Editor.

This ability has a prefabAbilityObject variable, which is the object that will be instantiated when the ability is activated. It also has a stunDuration variable, which represents how long the target will be stun if hit by this ability.

The ShieldBash constructor sets various properties of this ability, such as the ability name, base damage, scaling factors, and the animation name.

The OnAbilityObjectHit method is called when the ability object hits a target. It checks if the caster's stats are not null, gets the target's health controller component, deals damage to the target, and stuns the target if stunDuration is greater than or equal to 0. Finally, it raises an event to notify listeners that an object has been hit.

The Activate method is called when the ability is activated. It checks if the caster's stats are null, gets the caster's forward direction, instantiates the ability object, sets the velocity of the rigidbody to the forward direction times the projectile speed of the ability, sets various properties of the ability data, and raises an event to notify listeners that an object has been spawned.
Code of file ShieldBash:
using UnityEngine;
[CreateAssetMenu(menuName = "Abilities/ShieldBash")]
public class ShieldBash : Ability
{
    public GameObject prefabAbilityObject;
    public float stunDuration = 2f;
    public ShieldBash(){
        abilityName = "Shield Bash";
        baseDamage = 50;
        strengthScaling = 0.5f;
        intelligenceScaling = 0.5f;
        animationName = "Shield Bash animation";
        
    }

    public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
    {
        if (abilityObject.data.CasterStats != null)
        {
            HealthController targetStats = target.GetComponent<HealthController>();
            if (targetStats != null)
            {
                float damage = abilityObject.data.damage;
                targetStats.TakeDamage(damage,abilityObject.data.CasterStats.gameObject);

                if (abilityObject.data.stunDuration >= 0f)
                {
                    targetStats.GetComponent<IStunnable>().Stun(abilityObject.data.stunDuration);
                }
            }
        }
        RaiseOnObjectHit(abilityObject, target);
    }

    public override void Activate(AbilityData abilityData)
    {
        if (abilityData.CasterStats == null) return;

        Transform casterTransform = abilityData.CasterStats.transform;
        Vector3 forwardDirection = casterTransform.forward;

        GameObject abilityObjectInstance = Instantiate(prefabAbilityObject, casterTransform.position + forwardDirection, Quaternion.identity);
        AbilityObject abilityObject = abilityObjectInstance.GetComponent<AbilityObject>();
        RaiseOnObjectSpawned(abilityObject, null);

        Rigidbody rb = abilityObjectInstance.GetComponent<Rigidbody>();
        rb.velocity = forwardDirection * abilityData.projectileSpeed;

        abilityObject.data = abilityData;
        abilityData.Target = null;
        abilityData.projectileSpeed = 0f;
        abilityObject.ParentAbility = this;
        abilityData.stunDuration = stunDuration;
    }
}



Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ShieldBash.cs
File Name: ShieldBash.cs

Class Name: ShieldBash

- prefabAbilityObject: GameObject
- stunDuration: float
- abilityName: "Shield Bash"
- baseDamage: 50
- strengthScaling: 0.5f
- intelligenceScaling: 0.5f
- animationName: "Shield Bash animation"

+ ShieldBash()
+ OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
+ Activate(AbilityData abilityData)

- SimpleStrike at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\SimpleStrike.cs:
Summery of SimpleStrike:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\SimpleStrike.cs
The file is named "SimpleStrike.cs" and is a subclass of the "Ability" class. It contains a property "MeelePrefab" which represents the game object that will be instantiated upon activation of the ability. It also has a "lifeTime" property which determines the time the instantiated object will live before being destroyed.

The "OnAbilityObjectHit" method is overriden to allow for damage to be dealt to the target's health. The target's health is retrieved via a "HealthController" component attached to the target game object.

The "Activate" method is overriden and is responsible for the instantiation of the "MeelePrefab" game object at the position of the caster. A "MeleeStrikeObject" is then added to the instantiated object and this object's "data" and "ParentAbility" properties are set. Finally, the instantiated object is destroyed after the specified "lifeTime".

The "MeleeStrikeObject" class is defined which is responsible for detecting when the instantiated object collides with another object. The "OnTriggerEnter" method handles this detection and checks if the colliding object is not the caster or the instantiated object itself. If it's not, then the "HandleOnHit" function is called and the "ParentAbility" on the instantiated object is triggered to handle the hit with the collision game object.
Code of file SimpleStrike:
﻿using UnityEngine;

[CreateAssetMenu(menuName = "Abilities/SimpleStrike")]
public class SimpleStrike : Ability
{
    // SimpleStrike specific properties, if any
    public GameObject MeelePrefab;
    public float lifeTime = 0.5f;

    public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
    {
        HealthController healthController = target.GetComponent<HealthController>();
        if (healthController != null)
        {

            healthController.TakeDamage(abilityObject.data.damage,abilityObject.data.CasterStats.gameObject);
        }
    }


    public override void Activate(AbilityData abilityData)
    {
        GameObject meleeStrikeInstance = Instantiate(MeelePrefab, abilityData.CasterStats.transform.position, Quaternion.identity);
        MeleeStrikeObject abilityObject = meleeStrikeInstance.AddComponent<MeleeStrikeObject>();

        abilityObject.ParentAbility = this;
        abilityObject.data = abilityData;
        Destroy(meleeStrikeInstance, lifeTime);
    }


}

public class MeleeStrikeObject : AbilityObject
{
    private void OnTriggerEnter(Collider collision)
    {
        if (data.CasterStats != null)
        {
            if (data.CasterStats.gameObject.name == collision.gameObject.name)
            {
                return;
            }
            if (gameObject.name == collision.gameObject.name)
            {
                return;
            }
        }

        HandleOnHit(collision.gameObject);
        ParentAbility.OnAbilityObjectHit(this, collision.gameObject);

    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\SimpleStrike.cs
File: SimpleStrike.cs

Class: SimpleStrike
- MeelePrefab: GameObject
- lifeTime: float
- OnAbilityObjectHit(abilityObject: AbilityObject, target: GameObject)
- Activate(abilityData: AbilityData)

Class: MeleeStrikeObject
- OnTriggerEnter(collision: Collider)

- Buff at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\Buff.cs:
Summery of Buff:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\Buff.cs
Summary:

The Buff.cs script is a ScriptableObject that contains variables for a buff's name, duration, whether it is stackable or not, and the maximum number of stacks allowed. It also has three events, OnApply, OnFade, and OnHit, that can be triggered by BuffInstance objects.

The script contains three methods: InvokeOnApply, InvokeOnFade, and InvokeOnHit, which are used to trigger the events. There is also a method, GetEventTypes, which returns a list of strings that correspond to the event types that have been assigned to the Buff object.

Overall, the Buff.cs script defines the properties and events of a buff object and contains methods to trigger those events.
Code of file Buff:
﻿using System.Collections.Generic;
using UnityEngine;
[System.Serializable]
public class Buff : ScriptableObject
{
    public Buff()
    {
      statModifier = new StatsModifier();
    }
    public StatsModifier statModifier;
    public string buffName;
    public float duration;
    public bool stackable;
    public int maxStacks;

    private event System.Action<BuffInstance> OnApply;
    private event System.Action<BuffInstance> OnFade;
    private event System.Action<BuffInstance> OnHit;

    public virtual void InvokeOnApply(BuffInstance buffInstance)
    {
        OnApply?.Invoke(buffInstance);
    }

    public virtual void InvokeOnFade(BuffInstance buffInstance)
    {
        OnFade?.Invoke(buffInstance);
    }

    public virtual void InvokeOnHit(BuffInstance buffInstance)
    {
        OnHit?.Invoke(buffInstance);
    }

    public List<string> GetEventTypes()
    {
        List<string> eventTypes = new List<string>();

        if (OnApply != null)
        {
            eventTypes.Add("OnApply");
        }

        if (OnFade != null)
        {
            eventTypes.Add("OnFade");
        }

        if (OnHit != null)
        {
            eventTypes.Add("OnHit");
        }

        return eventTypes;
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\Buff.cs
File name: Buff.cs

Class: Buff

- buffName: string
- duration: float
- stackable: bool
- maxStacks: int

- OnApply: event taking BuffInstance parameter
- OnFade: event taking BuffInstance parameter
- OnHit: event taking BuffInstance parameter

+ InvokeOnApply(buffInstance: BuffInstance)
+ InvokeOnFade(buffInstance: BuffInstance)
+ InvokeOnHit(buffInstance: BuffInstance)

+ GetEventTypes(): List<string>

- BuffInstance at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\BuffInstance.cs:
Summery of BuffInstance:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\BuffInstance.cs
The file named "BuffInstance.cs" is a script containing a class that represents an instance of a buff in a game. It has four public variables; a Buff object, a target GameObject, an integer representing the current stacks of the buff, and a float representing the remaining duration of the buff.

The constructor of the class takes in a Buff object, a target GameObject, the initial stacks of the buff, and the initial duration of the buff and sets the BuffInstance variables accordingly.

The Update method of the class reduces the remaining duration of the buff by the Time.deltaTime. If the remaining duration is less than or equal to zero, the OnBuffFade method is called, and the method returns. Otherwise, it performs any other update logic specific to the buff.

The Refresh method allows for the refreshing of the buff's duration by updating the remaining duration variable.

The AddStack method increases the current stacks of the buff and calls the OnBuffApply method.

The RemoveStack method decreases the current stacks of the buff and calls the OnBuffFade method if the current stacks are less than or equal to zero.

The OnBuffApply method performs any actions or applies stat changes when the buff is applied.

The OnBuffFade method performs any actions or reverts stat changes when the buff fades.

The OnBuffHit method performs any actions or applies effects when the buff "hits" (e.g., dealing damage or applying a debuff).
Code of file BuffInstance:
﻿using UnityEngine;

public class BuffInstance
{
    public Buff buff;
    public GameObject target;
    public int currentStacks;
    public float remainingDuration;
    StatsModifier characterStats;

    public BuffInstance(Buff buff, GameObject target, int initialStacks, float initialDuration)
    {
        this.buff = buff;
        this.target = target;
        this.currentStacks = initialStacks;
        this.remainingDuration = initialDuration;
        characterStats = target.GetComponent<BuffSystem>().TotalstatsModifier;
    }

    public void Update()
    {
        remainingDuration -= Time.deltaTime;

        if (remainingDuration <= 0)
        {
            OnBuffFade();
            target.GetComponent<BuffSystem>().RemoveBuff(buff); // add this line
            return;
        }

        // Perform any other update logic specific to the buff
    }

    public void Refresh(float duration)
    {
        remainingDuration = duration;
    }

    public void AddStack()
    {
        currentStacks++;
        OnBuffApply();
    }

 

    public void OnBuffApply()
    {
        // Perform any actions or apply stat changes when the buff is applied
        if (buff.statModifier != null)
        {
            characterStats.Add(buff.statModifier);
            target.GetComponent<CharacterStats>().UpdateSubStats();
        }
        buff.InvokeOnApply(this);
    }

    public void OnBuffFade()
    {
        // Perform any actions or apply stat changes when the buff is applied
        if (buff.statModifier != null)
        {
            characterStats.Sub(buff.statModifier);
            target.GetComponent<CharacterStats>().UpdateSubStats();
        }
        buff.InvokeOnFade(this);
        
    }

    public void OnBuffHit()
    {
        // Perform any actions or apply effects when the buff "hits" (e.g., dealing damage or applying a debuff)
        buff.InvokeOnHit(this);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\BuffInstance.cs
BuffInstance:
- buff: Buff
- target: GameObject
- currentStacks: int
- remainingDuration: float

+BuffInstance(buff: Buff, target: GameObject, initialStacks: int, initialDuration: float)

+Update()
+Refresh(duration: float)
+AddStack()
+RemoveStack()
+OnBuffApply()
+OnBuffFade()
+OnBuffHit()

- IStatsProvider at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\IStatsProvider.cs:
Summery of IStatsProvider:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\IStatsProvider.cs
The file "IStatsProvider.cs" contains an interface called "IStatsProvider". This interface has a single method called "GetCharacterStats()" which returns an object of type "CharacterStats". Internally, this interface is meant to provide a mechanism for getting stats related to a character object in a Unity project. The "GetCharacterStats()" method is responsible for returning all the relevant stats for a character, which can be used for various purposes in the game. Overall, this interface plays a crucial role in managing character stats within the game.
Code of file IStatsProvider:
﻿public interface IStatsProvider
{
    CharacterStats GetCharacterStats();
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\IStatsProvider.cs
IStatsProvider
    - GetCharacterStats()
        - CharacterStats

- Item at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\items\Item.cs:
Summery of Item:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\items\Item.cs
The file name is Item.cs, and it is located in the AbilitysSkillsAndBuffsItems folder within the Assets folder in the project. This file contains two classes: Item and EquipableItem.

The Item class is an abstract class that extends ScriptableObject. It has three public variables: itemName, description, and icon. These store the name, description, and icon of the item, respectively. This class is intended to be inherited by other classes that represent specific items in the game.

The EquipableItem, on the other hand, is a serializable class that also extends ScriptableObject. It has six public variables: equipmentType, strengthBonus, intelligenceBonus, dexterityBonus, enduranceBonus, and wisdomBonus. These variables store the bonuses to different stats that the item provides when equipped. The EquipManager.EquipmentType enumeration determines the type of equipment the item represents.

Moreover, EquipableItem includes a subStatsModifier property that stores an object of the StatsModifier class. It is used to modify the stats of the character when the item is equipped.

Overall, both Item and EquipableItem classes define the basic properties and bonuses for in-game items, with EquipableItem class having more specific properties for equipped items.
Code of file Item:
﻿using UnityEngine;

public abstract class Item : ScriptableObject
{
    public string itemName;
    public string description;
    public Sprite icon;
}


[System.Serializable]
public class EquipableItem : Item
{
    public EquipManager.EquipmentType equipmentType;
    public float strengthBonus;
    public float intelligenceBonus;
    public float dexterityBonus;
    public float enduranceBonus;
    public float wisdomBonus;

    public StatsModifier subStatsModifier;
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\items\Item.cs
File: Item.cs

- abstract class Item
    - string itemName
    - string description
    - Sprite icon

- class EquipableItem : Item
    - EquipManager.EquipmentType equipmentType
    - float strengthBonus
    - float intelligenceBonus
    - float dexterityBonus
    - float enduranceBonus
    - float wisdomBonus
    - StatsModifier subStatsModifier

- BouceSkill at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\BouceSkill.cs:
Summery of BouceSkill:

Code of file BouceSkill:

Corresponding SyntaxTree:


- FireballMasterySkill at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\FireballMasterySkill.cs:
Summery of FireballMasterySkill:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\FireballMasterySkill.cs
"FireballMasterySkill.cs" is a script that defines the behavior and logic for the "FireBallMastery" skill in a Unity game. It is derived from the base class "Skill". The script contains a serialized field "explosionPrefab" of type GameObject and two methods, "ApplySkill" and "RemoveSkill", which override the method of the base class. 

The "ApplySkill" method is called when the skill is applied to a player's stats. It first retrieves the "Fireball" ability from the player's stats using the "GetFireballAbility" method. If the ability is found, the "OnAbilityObjectHitEvent" event is subscribed. 

The "RemoveSkill" method is called when the skill is removed from the player's stats. If the "Fireball" ability is found, the "OnAbilityObjectHitEvent" event is unsubscribed. 

The "GetFireballAbility" method retrieves the "Fireball" ability from the player's stats through the "AbilityController" component. 

The "ExplodeOnHit" method is an event handler that is called when the "OnAbilityObjectHitEvent" event is triggered. It applies damage to the targets within a specified radius and instantiates an explosion at the hit position. 

The "ApplyDamageToTargets" method is currently an empty method that will be used to apply damage to targets in the specified radius when an object is hit by the fireball. 

The "InstantiateExplosion" method instantiates an explosion prefab at the specified position. If there is no explosion prefab assigned, it will log a warning message.

The script also includes a "CreateAssetMenu" attribute, which enables it to be created as an asset through the Unity Editor's "Create" menu. The asset can be named "FireBallMastery" and has a menu item under "Skill/FireBallMastery" with an order of 1.
Code of file FireballMasterySkill:
using UnityEngine;
[CreateAssetMenu(fileName = "FireBallMastery", menuName = "Skill/FireBallMastery", order = 1)]
public class FireballMasterySkill : Skill
{
    [SerializeField]
    private GameObject explosionPrefab;

    public override void ApplySkill(CharacterStats playerStats)
    {
        Debug.Log("Apply Skill");
        FireBall fireballAbility = GetFireballAbility(playerStats);
        if (fireballAbility != null)
        {
            Debug.Log("Fireball Ability found");
            fireballAbility.OnAbilityObjectHitEvent += ExplodeOnHit;
        }
    }

    public override void RemoveSkill(CharacterStats playerStats)
    {
        FireBall fireballAbility = GetFireballAbility(playerStats);
        if (fireballAbility != null)
        {
            fireballAbility.OnAbilityObjectHitEvent -= ExplodeOnHit;
        }
    }

    private FireBall GetFireballAbility(CharacterStats playerStats)
    {
        AbilityController abilityController = playerStats.GetComponent<AbilityController>();
        return abilityController.learnedAbilitys.Find(a => a is FireBall) as FireBall;
    }

    private void ExplodeOnHit(AbilityObject abilityObject, GameObject target)
    {
        Debug.Log("EXPLODE ON Hit");
        ApplyDamageToTargets(abilityObject.transform.position, 2f, abilityObject.data.damage * 0.5f);
        InstantiateExplosion(abilityObject.transform.position);
    }

    private void ApplyDamageToTargets(Vector3 position, float radius, float damage)
    {
   
    }

    private void InstantiateExplosion(Vector3 position)
    {
        if (explosionPrefab != null)
        {
            GameObject explosion = Instantiate(explosionPrefab, position, Quaternion.identity);
            // Add additional logic for the explosion, such as configuring the explosion's lifetime or assigning its parent
        }
        else
        {
            Debug.LogWarning("No explosion prefab assigned to FireballMasterySkill.");
        }
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\FireballMasterySkill.cs
FireballMasterySkill:

- explosionPrefab: GameObject
- ApplySkill(playerStats: CharacterStats): void
    - fireballAbility: FireBall
        - OnAbilityObjectHitEvent += ExplodeOnHit
- RemoveSkill(playerStats: CharacterStats): void
    - fireballAbility: FireBall
        - OnAbilityObjectHitEvent -= ExplodeOnHit
- GetFireballAbility(playerStats: CharacterStats): FireBall
- ExplodeOnHit(abilityObject: AbilityObject, target: GameObject): void
    - ApplyDamageToTargets(position: Vector3, radius: float, damage: float)
    - InstantiateExplosion(position: Vector3)
- ApplyDamageToTargets(position: Vector3, radius: float, damage: float): void
- InstantiateExplosion(position: Vector3): void

- Skill at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\Skill.cs:
Summery of Skill:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\Skill.cs
The file "Skill.cs" contains an abstract class called Skill that inherits from the ScriptableObject class in Unity. This class defines various parameters such as the skill name, a list of archetype types for which the skill is applicable, and a StatModifier object.

The class also includes three methods, ApplySkill(), RemoveSkill(), and OnSpawnAbilityObject() which can be overridden to implement skill-specific behavior in derived classes.

Additionally, the class includes an enum called Archetype which lists the different archetype types a skill can be applied to, including Strength, Intelligence, Dexterity, Endurance, and Wisdom.
Code of file Skill:
﻿using System.Collections.Generic;
using UnityEngine;

public abstract class Skill : ScriptableObject
{
    public string skillName;
    public List<Archetype> archTypes;
    public StatsModifier statModifier;

    public virtual void ApplySkill(CharacterStats characterStats)
    {
        // Implement skill-specific behavior in derived classes
    }

    public virtual void RemoveSkill(CharacterStats characterStats)
    {
        // Implement skill-specific behavior in derived classes
    }
    public virtual void OnSpawnAbilityObject(AbilityObject abilityObject, AbilityData abilityData)
    {

    }
    
}


public enum Archetype
{
    Strength,
    Intelligence,
    Dexterity,
    Endurance,
    Wisdom
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\Skill.cs
Skill.cs 
- class Skill
    - string skillName
    - List<Archetype> archTypes
    - StatsModifier statModifier
    - virtual ApplySkill(CharacterStats characterStats)
        - (implemented in derived classes)
    - virtual RemoveSkill(CharacterStats characterStats)
        - (implemented in derived classes)
    - virtual OnSpawnAbilityObject(AbilityObject abilityObject, AbilityData abilityData)
- enum Archetype
    - Strength
    - Intelligence
    - Dexterity
    - Endurance
    - Wisdom

- SkillNode at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNode.cs:
Summery of SkillNode:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNode.cs
The file name is SkillNode.cs and it is located in the Assets/Scripts/AbilitysSkillsAndBuffsItems/Skills folder. This file contains the logic for a skill node in a skill tree. It is a ScriptableObject that can be created and customized in the Unity Editor with the help of CreateAssetMenu attribute. 

Each SkillNode has several properties such as skillName, skillDescription, skillPointCost, icon, mainStatRequirement, and mainStatValue, skill, prerequisiteSkill, and isUnlocked. These properties represent the necessary details about a specific skill in the game. For example, skillName refers to the name of the skill, skillPointCost refers to how many skill points you need to unlock it, and mainStatRequirement is a list of requirements, the player has to fulfill in order to unlock the skill, and so on.

The skill node has a list of Archetypes which represent a group of characters or classes. The Archetype list is used to check if the player's current Archetype satisfies the mainStatRequirement. The mainStatValue list represents the value of the mainStatRequirement that needs to be achieved by the character before they can unlock the skill.

One important property is the skill which represents the actual behavior of the skill. The Skill property can be defined as a class that contains all of the logic and functionality for the skill. 

Another property is the prerequisiteSkill that represents the skill that must be unlocked before the current skill can be unlocked. This is useful for creating a skill tree with a progression system where the player has to move through a sequence of skills to unlock more powerful ones.

Finally, the isUnlocked property is a boolean that indicates whether the player has unlocked the skill yet or not.

Overall, the SkillNode.cs file is a crucial component in creating a skill tree system in a game.
Code of file SkillNode:
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "SkillNode", menuName = "SkillTree/SkillNode", order = 0)]
public class SkillNode : ScriptableObject
{
    public string skillName;
    public string skillDescription;
    public int skillPointCost;
    public Sprite icon;
    public List<Archetype> mainStatRequirement;
    public List<int> mainStatValue;
    public Skill skill;
    public SkillNode prerequisiteSkill;
    public bool isUnlocked = false;


}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNode.cs
File: SkillNode.cs

Class: SkillNode

- skillName: string
- skillDescription: string
- skillPointCost: int
- icon: Sprite
- mainStatRequirement: List<Archetype>
- mainStatValue: List<int>
- skill: Skill
- prerequisiteSkill: SkillNode
- isUnlocked: bool

- SkillNodeFactory at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNodeFactory.cs:
Summery of SkillNodeFactory:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNodeFactory.cs
The file SkillNodeFactory.cs is a static class that contains a method called CreateSkillNode, which creates a SkillNode object and sets its properties based on a SkillNodeFactoryDataClass object passed in as a parameter. The properties of the SkillNode include its name, description, point cost, associated icon, main stat requirement, main stat value, skill, prerequisite skill, and whether or not it is unlocked. 

The SkillNode object that is created is then saved as an asset within the Assets/Resources/SkillNodes/ directory using AssetDatabase.CreateAsset. The SkillNodeFactoryDataClass contains the various properties that are used to create the SkillNode object. 

In summary, the SkillNodeFactory.cs file provides a way to create new SkillNode objects with specific properties, and the SkillNodeFactoryDataClass is used to pass in the necessary parameters needed to create these objects. This implementation allows for easy creation and management of different skill nodes within the game.
Code of file SkillNodeFactory:
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
public static class SkillNodeFactory{
    
     public static SkillNode CreateSkillNode(SkillNodeFactoryDataClass data){
        //set save path

         SkillNode skillNode = ScriptableObject.CreateInstance<SkillNode>();
         skillNode.name = data.skillName+"SkillNode";
         skillNode.skillName = data.skillName;
         skillNode.skillDescription = data.skillDescription;
         skillNode.skillPointCost = data.skillPointCost;
         skillNode.icon = data.icon;
         skillNode.mainStatRequirement = data.mainStatRequirement;
         skillNode.mainStatValue = data.mainStatValue;
         skillNode.skill = data.skill;
         skillNode.prerequisiteSkill = data.prerequisiteSkill;
         skillNode.isUnlocked = data.isUnlocked;

         AssetDatabase.CreateAsset(skillNode, "Assets/Resources/SkillNodes/"+skillNode.name+".asset");
         return skillNode;
     }

     
     

}
public class SkillNodeFactoryDataClass{
        public string skillName;
        public string skillDescription;
        public int skillPointCost;
        public Sprite icon;
        public List<Archetype> mainStatRequirement;
        public List<int> mainStatValue;
        public Skill skill;
        public SkillNode prerequisiteSkill;
        public bool isUnlocked;
        public SkillNodeFactoryDataClass(string skillName, string skillDescription, int skillPointCost, Sprite icon, List<Archetype> mainStatRequirement, List<int> mainStatValue, Skill skill, SkillNode prerequisiteSkill, bool isUnlocked){
            this.skillName = skillName;
            this.skillDescription = skillDescription;
            this.skillPointCost = skillPointCost;
            this.icon = icon;
            this.mainStatRequirement = mainStatRequirement;
            this.mainStatValue = mainStatValue;
            this.skill = skill;
            this.prerequisiteSkill = prerequisiteSkill;
            this.isUnlocked = isUnlocked;
        }
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNodeFactory.cs
Class Name: SkillNodeFactory

- SkillNodeFactoryDataClass:
    - skillName: string
    - skillDescription: string
    - skillPointCost: int
    - icon: Sprite
    - mainStatRequirement: List<Archetype>
    - mainStatValue: List<int>
    - skill: Skill
    - prerequisiteSkill: SkillNode
    - isUnlocked: bool
    - SkillNodeFactoryDataClass(string skillName, string skillDescription, int skillPointCost, Sprite icon, List<Archetype> mainStatRequirement, List<int> mainStatValue, Skill skill, SkillNode prerequisiteSkill, bool isUnlocked)

- CreateSkillNode(SkillNodeFactoryDataClass data):
    - skillNode: SkillNode
        - name: string
        - skillName: string
        - skillDescription: string
        - skillPointCost: int
        - icon: Sprite
        - mainStatRequirement: List<Archetype>
        - mainStatValue: List<int>
        - skill: Skill
        - prerequisiteSkill: SkillNode
        - isUnlocked: bool
    - AssetDatabase.CreateAsset(skillNode, "Assets/Resources/SkillNodes/"+skillNode.name+".asset")
    - return skillNode

- SkillTree at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\SkillTree.cs:
Summery of SkillTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\SkillTree.cs
The file "SkillTree.cs" is a script for implementing a skill tree in a game. It is a class that inherits from the "ScriptableObject" class, which allows it to be created as an asset in the Unity editor. The script defines a list of "skillNodes," which are objects that represent individual skills in the skill tree.

The class contains methods for adding new skill nodes to the list and resetting all nodes to their default state. The internal method "IsVisible" is not currently being used, but likely would be used to determine if a skill node should be shown to the player based on certain conditions.

When the script is instantiated, the "Awake" method is called, which calls the "resetAllNodes" method to initialize all skill nodes as locked.
Code of file SkillTree:
﻿using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "SkillTree", menuName = "SkillTree/SkillTree", order = 1)]
public class SkillTree : ScriptableObject
{
    public List<SkillNode> skillNodes;
    public SkillTree()
    {
        skillNodes = new List<SkillNode>();
    }

    public void AddSkillNode(SkillNode skillNode)
    {
        skillNodes.Add(skillNode);
    }
    internal bool IsVisible(SkillNode skillNode)
    {
        return true;
    }
    private void Awake()
    {
        resetAllNodes();
    }
    public void resetAllNodes()
    {
        foreach (SkillNode node in skillNodes)
        {
            node.isUnlocked = false;

        }
    }
}


Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\SkillTree.cs
SkillTree
- skillNodes: List<SkillNode>
- SkillTree()
- AddSkillNode(SkillNode)
- IsVisible(SkillNode)
- Awake()
- resetAllNodes()

- StatsModifier at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\StatsModifier.cs:
Summery of StatsModifier:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\StatsModifier.cs
The file name is "StatsModifier.cs" and it contains a class with the same name. The class has several float variables that represent different stats such as attack speed, critical chance, and armor. It also has two public methods, Add and Sub, that take another StatsModifier object and add or subtract its values from the current object's values.

The logic behind this class is that it provides an easy way to modify a character's stats by simply creating a StatsModifier object with the desired changes and then applying it to the character's existing stats. This can be useful for implementing buffs or debuffs, as well as for calculating the effects of equipment or abilities. The Add and Sub methods make it easy to stack multiple modifiers on top of each other or to remove them as needed.
Code of file StatsModifier:
﻿[System.Serializable]
public class StatsModifier
{
    public float Strength;
    public float Intelligence;
    public float Dexterity;
    public float Endurance;
    public float Wisdom;

    public float attackSpeed;
    public float criticalChance;
    public float criticalDamage;
    public float spellCriticalChance;
    public float spellCriticalDamage;
    public float cooldown;
    public float dodgeChance;
    public float armor;
    public float magicResistance;
    public float maxLife;
    public float maxMana;
    public float lifeRegen;
    public float manaRegen;
    public StatsModifier(
        float strength = 0f,
        float intelligence = 0f,
        float dexterity = 0f,
        float endurance = 0f,
        float wisdom = 0f,
        float attackSpeed = 0f,
        float criticalChance = 0f,
        float criticalDamage = 0f,
        float spellCriticalChance = 0f,
        float spellCriticalDamage = 0f,
        float cooldown = 0f,
        float dodgeChance = 0f,
        float armor = 0f,
        float magicResistance = 0f,
        float maxLife = 0f,
        float maxMana = 0f,
        float lifeRegen = 0f,
        float manaRegen = 0f
    )
    {
        Strength = strength;
        Intelligence = intelligence;
        Dexterity = dexterity;
        Endurance = endurance;
        Wisdom = wisdom;
        this.attackSpeed = attackSpeed;
        this.criticalChance = criticalChance;
        this.criticalDamage = criticalDamage;
        this.spellCriticalChance = spellCriticalChance;
        this.spellCriticalDamage = spellCriticalDamage;
        this.cooldown = cooldown;
        this.dodgeChance = dodgeChance;
        this.armor = armor;
        this.magicResistance = magicResistance;
        this.maxLife = maxLife;
        this.maxMana = maxMana;
        this.lifeRegen = lifeRegen;
        this.manaRegen = manaRegen;
    }

    public void Add(StatsModifier other)
    {
        Strength += other.Strength;
        Intelligence += other.Intelligence;
        Dexterity += other.Dexterity;
        Endurance += other.Endurance;
        Wisdom += other.Wisdom;

        attackSpeed += other.attackSpeed;
        criticalChance += other.criticalChance;
        criticalDamage += other.criticalDamage;
        spellCriticalChance += other.spellCriticalChance;
        spellCriticalDamage += other.spellCriticalDamage;
        cooldown += other.cooldown;
        dodgeChance += other.dodgeChance;
        armor += other.armor;
        magicResistance += other.magicResistance;
        maxLife += other.maxLife;
        maxMana += other.maxMana;
        lifeRegen += other.lifeRegen;
        manaRegen += other.manaRegen;
    }
    public void Sub(StatsModifier other)
    {
        Strength -= other.Strength;
        Intelligence -= other.Intelligence;

        Dexterity -= other.Dexterity;
        Endurance -= other.Endurance;
        Wisdom -= other.Wisdom;
        
        attackSpeed -= other.attackSpeed;
        criticalChance -= other.criticalChance;
        criticalDamage -= other.criticalDamage;
        spellCriticalChance -= other.spellCriticalChance;
        spellCriticalDamage -= other.spellCriticalDamage;
        cooldown -= other.cooldown;
        dodgeChance -= other.dodgeChance;
        armor -= other.armor;
        magicResistance -= other.magicResistance;
        maxLife -= other.maxLife;
        maxMana -= other.maxMana;
        lifeRegen -= other.lifeRegen;
        manaRegen -= other.manaRegen;
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\StatsModifier.cs
Class: StatsModifier

-Serializable
-attackSpeed: float
-criticalChance: float
-criticalDamage: float
-spellCriticalChance: float
-spellCriticalDamage: float
-cooldown: float
-dodgeChance: float
-armor: float
-magicResistance: float
-maxLife: float
-maxMana: float
-lifeRegen: float
-manaRegen: float

+Add(other: StatsModifier): void
+Sub(other: StatsModifier): void

- VisualEffectManager at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\GlobalManager\VisualEffectManager.cs:
Summery of VisualEffectManager:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\GlobalManager\VisualEffectManager.cs
The file "VisualEffectManager.cs" is a ScriptableObject that creates a list of visual effects. It contains a struct "VisualEffect" that includes an effect name and an effect prefab, as well as a list of these visual effects. A "GetEffectPrefab" method is also included, which loops through the list to find a matching effect name. If a match is found, the corresponding effect prefab is returned. If no match is found, an error is logged and a null value is returned.
Code of file VisualEffectManager:
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "VisualEffectManager", menuName = "ScriptableObjects/VisualEffectManager", order = 1)]
public class VisualEffectManager : ScriptableObject
{
    [System.Serializable]
    public struct VisualEffect
    {
        public string effectName;
        public GameObject effectPrefab;
    }

    public List<VisualEffect> visualEffects;

    public GameObject GetEffectPrefab(string effectName)
    {
        foreach (var effect in visualEffects)
        {
            if (effect.effectName == effectName)
            {
                return effect.effectPrefab;
            }
        }
        Debug.LogError($"No effect with name {effectName} found!");
        return null;
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\GlobalManager\VisualEffectManager.cs
Class: VisualEffectManager

- struct: VisualEffect
    - string : effectName
    - GameObject: effectPrefab

- List<VisualEffect>: visualEffects

- GameObject: GetEffectPrefab(string effectName)
    - foreach(var effect in visualEffects)
        - if(effect.effectName == effectName)
            - return effect.effectPrefab
    - Debug.LogError($"No effect with name {effectName} found!")
    - return null

- AbilityController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AbilityController.cs:
Summery of AbilityController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AbilityController.cs
The AbilityController.cs file is a script used to handle abilities for players and units in a Unity game. The script includes a firePoint transform and a list of learned abilities. Additionally, the script also includes a private variable for IStatsProvider and an Awake() function that sets up the IStatsProvider. 

The script also includes a public function called CastAbility which takes in an Ability object and AbilityData to activate the specified ability.
Code of file AbilityController:
using System.Collections;
using System.Collections.Generic;

using UnityEngine;
public class AbilityController : MonoBehaviour
{
    public Transform firePoint;
    public List<Ability> learnedAbilitys;
    public List<(string,float)> lastTimeAbilityUsed;
    private IStatsProvider statsProvider;
    private AnimationController animationController;

    private void Awake()
    {
        statsProvider = GetComponent<IStatsProvider>();
        lastTimeAbilityUsed = new List<(string, float)>();
        animationController = GetComponent<AnimationController>();
    }

    public void CastAbility(Ability ability, AbilityData abilityData)
    {
            ability.PreActivateAbility(abilityData);
            animationController.PlayAnimation(ability.animationName);

        if(ability.ActivateDelayTime == 0)
        {

            ability.Activate(abilityData);
        }
        else
        {

            StartCoroutine(CastAfterDelay(ability, abilityData));
        }
    }
    public IEnumerator CastAfterDelay(Ability ability, AbilityData abilityData)
    {
        yield return new WaitForSeconds(animationController.returnAnimationDelay(ability.animationName));
        Debug.Log(animationController.returnAnimationDelay(ability.animationName)+" DELAY");
        ability.Activate(abilityData);
    }
    public void AddAbility(Ability ability)
    {
        learnedAbilitys.Add(ability);
    }
    public bool checkCooldown(string abilityName,float cooldown){
        foreach ((string,float) paar in lastTimeAbilityUsed)
        {
            if(paar.Item1 == abilityName){
                if(Time.time - paar.Item2 < cooldown){
                    return false;
                }
            }
        }
        return true;
    }
    public void setCooldown(string abilityName,float cooldown){
        bool found = false;
        for (int i = 0; i < lastTimeAbilityUsed.Count; i++)
        {
            if(lastTimeAbilityUsed[i].Item1 == abilityName){
                lastTimeAbilityUsed[i] = (abilityName,Time.time);
                found = true;
            }
        }
        if(!found){
            lastTimeAbilityUsed.Add((abilityName,Time.time));
        }
    }
}


Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AbilityController.cs
AbilityController:
- firePoint: Transform
- learnedAbilitys: List<Ability>
- lastTimeAbilityUsed: List<(string,float)>
- statsProvider: IStatsProvider
- animationController: AnimationController

+ Awake()
+ CastAbility(ability: Ability, abilityData: AbilityData)
+ CastAfterDelay(ability: Ability, abilityData: AbilityData): IEnumerator
+ AddAbility(ability: Ability)
+ checkCooldown(abilityName: string, cooldown: float): bool
+ setCooldown(abilityName: string, cooldown: float)

- AIController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AIController.cs:
Summery of AIController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AIController.cs
The AIController.cs file contains a class that represents the AI controller for non-player characters (NPCs) in a game. It has several public fields for different AI states, such as Idle, Follow, Assist, Patrol, Chase, and Attack. It also has private fields for the navMeshAgent, target, aggroRadius, aggroTag, attackInterval, attackAbility, and attackRange.

The Start() method initializes the AI controller and sets its default state to idle. It also checks if the AI has a patrol state and initializes the patrol waypoints if found.

The Update() method updates the current state of the AI and sets the animator to move if the navMeshAgent is moving. It also updates the state if the NPC detects a player near it using the checkForAggro() method.

The ChangeState() method changes the current state to a new state.

The checkForAggro() method detects if a player is near the NPC within the aggro radius and changes the state to chase if found.

The attack() method executes the attackAbility if the target is within the attack range and the attackInterval has passed. It also changes the state to chase if the target is out of range.

The AIState abstract class defines three abstract methods: EnterState, UpdateState, and ExitState that are implemented by the different AI states that inherit from it.
Code of file AIController:
using System;
using UnityEngine;
using UnityEngine.AI;

public class AIController : MonoBehaviour
{
    public AIState currentState;
    public IdleState idleState;
    public FollowState followState;
    public AssistState assistState;
    public PatrolState patrolState;

    private NavMeshAgent navMeshAgent;

    public ChaseState chaseState;
    public AttackState attackState;

    public Transform target;
    public float aggroRadius;
    public string aggroTag;
    public float attackInterval;
    public Ability attackAbility;
    public  float attackRange;

    private void Start()
    {
        navMeshAgent = GetComponent<NavMeshAgent>();
        currentState = idleState;
        PatrolStateMonoBehaviour patrolStateMonoBehaviour = GetComponent<PatrolStateMonoBehaviour>();
        if (patrolStateMonoBehaviour != null)
        {
            patrolState.waypoints = new System.Collections.Generic.List<Transform>();
            foreach (GameObject g in patrolStateMonoBehaviour.waypoints)
            {
                patrolState.waypoints.Add(g.transform);
            }
        }
        animator = GetComponent<Animator>();
    }
    public NavMeshAgent getNavMeshAgent()
    {
        return navMeshAgent;
    }
    Animator animator;
    private void Update()
    {
                if(navMeshAgent==null){
            return;
        }
        if(animator==null){
            return;
        }
        currentState.UpdateState(this);
        //if navemeshagent is moving,set animator to move
        if (navMeshAgent.velocity.magnitude > 0)
        {
            animator.SetFloat("Speed", 1);

        }
        else
        {
            animator.SetFloat("Speed", 0);
        }

    }

    public void ChangeState(AIState newState)
    {
        currentState.ExitState(this);
        currentState = newState;
        newState.EnterState(this);
    }
public void checkForAggro()
{
    Collider[] colliders = Physics.OverlapSphere(transform.position, aggroRadius);
    foreach (Collider collider in colliders)
    {
        if (!string.IsNullOrEmpty(collider.tag) && collider.CompareTag("Player"))
        {
            target = collider.gameObject.transform;
            ChangeState(chaseState);
            break;
        }
    }

}
    float nextAttackTime=0;
public void attack(){

            if (target != null)
        {
            float distanceToTarget = Vector3.Distance(transform.position, target.position);

            if (distanceToTarget <= attackRange)
            {
                navMeshAgent.isStopped=true;
                GetComponent<Animator>().SetFloat("Speed", 0);
                
                    // Use attack ability
                    GetComponent<CharacterCombatController>().PerformAbility(attackAbility, target.gameObject);
                    
                
            }
            else
            {
                // Transition to another state if needed, for example, Chase
                ChangeState(chaseState);
            }
        }
}

    internal void SetAIController(AIController aiController)
    {
        currentState = aiController.currentState;
        idleState = aiController.idleState;
        followState = aiController.followState;
        assistState = aiController.assistState;
        patrolState = aiController.patrolState;
        chaseState = aiController.chaseState;
        attackState = aiController.attackState;
        target = aiController.target;
        aggroRadius = aiController.aggroRadius;
        aggroTag = aiController.aggroTag;
        attackInterval = aiController.attackInterval;
        attackAbility = aiController.attackAbility;
        attackRange = aiController.attackRange;


    }
}

public abstract class AIState : ScriptableObject
{
    public abstract void EnterState(AIController aiController);
    public abstract void UpdateState(AIController aiController);
    public abstract void ExitState(AIController aiController);
}


Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AIController.cs
Class Name: AIController

- currentState: AIState
- idleState: IdleState
- followState: FollowState
- assistState: AssistState
- patrolState: PatrolState
- navMeshAgent: NavMeshAgent
- chaseState: ChaseState
- attackState: AttackState
- target: Transform
- aggroRadius: float
- aggroTag: string
- attackInterval: float
- attackAbility: Ability
- attackRange: float
- animator: Animator

+ Start()
    - navMeshAgent = GetComponent<NavMeshAgent>()
    - currentState = idleState
    - patrolStateMonoBehaviour = GetComponent<PatrolStateMonoBehaviour>()
    + if (patrolStateMonoBehaviour != null)
        - patrolState.waypoints = new List<Transform>()
        + foreach (GameObject g in patrolStateMonoBehaviour.waypoints)
            - patrolState.waypoints.Add(g.transform)
    - animator = GetComponent<Animator>()

+ NavMeshAgent getNavMeshAgent()
    - return navMeshAgent

+ Update()
    + if (navMeshAgent == null || animator == null)
        - return
    - currentState.UpdateState(this)
    + if (navMeshAgent.velocity.magnitude > 0)
        - animator.SetFloat("Speed", 1)
    + else
        - animator.SetFloat("Speed", 0)

+ ChangeState(newState: AIState)
    - currentState.ExitState(this)
    - currentState = newState
    - newState.EnterState(this)

+ checkForAggro()
    - colliders = Physics.OverlapSphere(transform.position, aggroRadius)
    + foreach (Collider collider in colliders)
        + if (!string.IsNullOrEmpty(collider.tag) && collider.CompareTag("Player"))
            - target = collider.gameObject.transform
            + ChangeState(chaseState)
            + break

+ attack()
    + if (target != null)
        - distanceToTarget = Vector3.Distance(transform.position, target.position)
        + if (distanceToTarget <= attackRange)
            - navMeshAgent.isStopped = true
            - GetComponent<Animator>().SetFloat("Speed", 0)
            + GetComponent<CharacterCombatController>().PerformAbility(attackAbility, target.gameObject)
        + else
            + ChangeState(chaseState)

+ SetAIController(aiController: AIController)
    - currentState = aiController.currentState
    - idleState = aiController.idleState
    - followState = aiController.followState
    - assistState = aiController.assistState
    - patrolState = aiController.patrolState
    - chaseState = aiController.chaseState
    - attackState = aiController.attackState
    - target = aiController.target
    - aggroRadius = aiController.aggroRadius
    - aggroTag = aiController.aggroTag
    - attackInterval = aiController.attackInterval
    - attackAbility = aiController.attackAbility
    - attackRange = aiController.attackRange

Class Name: AIState (abstract)

- EnterState(aiController: AIController)
- UpdateState(aiController: AIController)
- ExitState(aiController: AIController)

- AssistState at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\AssistState.cs:
Summery of AssistState:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\AssistState.cs
The file "AssistState.cs" is a script for an AI state in a Unity project that creates an AI State under "AI/States/AssistState" in the project's menu. The script includes public variables for a target transform, an assist ability, and an assist range. The EnterState, UpdateState, and ExitState methods are overriden from the parent AIState class. 

In the EnterState method, no logic is implemented. In the UpdateState method, the script calculates the distance between the AI controller's transform position and the target position using Vector3.Distance(). If the distance is less than or equal to the assist range, the script attempts to use the assistAbility using GetComponent<AbilityController>().UseAbility(assistAbility). If the distance is greater than the assist range, the script changes the AI controller's state to the follow state. In the ExitState method, no logic is implemented.
Code of file AssistState:
﻿using UnityEngine;

[CreateAssetMenu(menuName = "AI/States/AssistState")]
public class AssistState : AIState
{
    public Transform target;
    public Ability assistAbility;
    public float assistRange = 10f;

    public override void EnterState(AIController aiController)
    {
    }

    public override void UpdateState(AIController aiController)
    {
        float distanceToTarget = Vector3.Distance(aiController.transform.position, target.position);

        if (distanceToTarget <= assistRange)
        {
            // aiController.GetComponent<AbilityController>().UseAbility(assistAbility);
        }
        else
        {
            aiController.ChangeState(aiController.followState);
        }
    }

    public override void ExitState(AIController aiController)
    {
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\AssistState.cs
File: AssistState.cs

-AssistState
    -target (Transform)
    -assistAbility (Ability)
    -assistRange (float)

    +EnterState(aiController)
    +UpdateState(aiController)
    +ExitState(aiController)

- AttackState at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\AttackState.cs:
Summery of AttackState:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\AttackState.cs
The file name is AttackState.cs and it is located in the AiStates folder under the PlayerAndUnitsComponent.

It is a scriptable object class that is used to define the AI behavior when the unit is in the attack state.

The class has a Transform variable called target which represents the target that the unit will attack. It also has an Ability variable called attackAbility that represents the attack method of the unit.

The attackRange and attackInterval variables define the range and interval between attacks respectively.

The nextAttackTime variable is used to keep track of the time since the last attack to determine when the unit can attack again.

The EnterState method initializes the nextAttackTime to the current time when the unit enters the attack state.

The UpdateState method calls the attack method of the AIController, which will then attempt to attack the target.

The ExitState method is empty and is used to clean up any variables or reset them if needed.

Overall, the AttackState class is responsible for defining the basic behavior of an AI unit when it is in the attack state.
Code of file AttackState:
﻿using UnityEngine;
[CreateAssetMenu(menuName = "AI/States/AttackState")]
public class AttackState : AIState
{
    public Transform target;
    public Ability attackAbility;
    public float attackRange = 5f;
    public float attackInterval = 1f;

    private float nextAttackTime;

    public override void EnterState(AIController aiController)
    {
        nextAttackTime = Time.time;
    }

    public override void UpdateState(AIController aiController)
    {
        aiController.attack();
    }

    public override void ExitState(AIController aiController)
    {
        // Clean up or reset any variables if needed
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\AttackState.cs
AttackState:
- target: Transform
- attackAbility: Ability
- attackRange: float = 5f
- attackInterval: float = 1f
- nextAttackTime: float

EnterState:
- aiController: AIController
- nextAttackTime: Time.time

UpdateState:
- aiController: AIController

ExitState:
- aiController: AIController

- ChaseState at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\ChaseState.cs:
Summery of ChaseState:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\ChaseState.cs
The file, ChaseState.cs, is a script for the AI component of a game that creates the behavior for an AI entity to chase a target. 

The script contains two public variables that can be adjusted from the Inspector panel: chaseSpeed and stoppingDistance. The chaseSpeed determines the speed at which the AI entity moves while chasing the target, while stoppingDistance determines the proximity the AI entity has to the target before stopping to attack.

The script has three methods: EnterState, UpdateState, and ExitState. 

The EnterState method sets the speed of the NavMeshAgent component attached to the AI entity to the chaseSpeed variable. 

The UpdateState method first gets the Transform component of the target assigned to the AI entity. It then calculates the distance between the AI entity and the target. If that distance is greater than the stoppingDistance, the NavMeshAgent component is given the destination of the target's position to move towards. If the distance is less than the stoppingDistance, the AI entity will transition to another state, such as the attack state. 

Finally, the ExitState method is an empty placeholder that allows the developer to clean up or reset any variables.
Code of file ChaseState:
﻿using UnityEngine;
[CreateAssetMenu(menuName = "AI/States/ChaseState")]
public class ChaseState : AIState
{
    public float chaseSpeed = 6f;
    public float stoppingDistance = 5f;

    public override void EnterState(AIController aiController)
    {
        aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().speed = chaseSpeed;
    }

    public override void UpdateState(AIController aiController)
    {
        Transform target = aiController.target;

        if (target != null)
        {
            float distanceToTarget = Vector3.Distance(aiController.transform.position, target.position);

            if (distanceToTarget > stoppingDistance)
            {
                aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().SetDestination(target.position);
            }
            else
            {
                // Transition to another state if needed, for example, Attack
                aiController.ChangeState(aiController.attackState);
            }
        }
    }

    public override void ExitState(AIController aiController)
    {
        // Clean up or reset any variables if needed
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\ChaseState.cs
ChaseState:
- chaseSpeed: float
- stoppingDistance: float

+ EnterState(aiController: AIController): void
+ UpdateState(aiController: AIController): void
+ ExitState(aiController: AIController): void 

- target: Transform
- distanceToTarget: float

if target is not null:
    distanceToTarget = distance between aiController.transform.position and target.position
    if distanceToTarget > stoppingDistance:
        aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().SetDestination(target.position)
    else:
        aiController.ChangeState(aiController.attackState)


- FollowState at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\FollowState.cs:
Summery of FollowState:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\FollowState.cs
The FollowState.cs file contains the implementation of a state in an AI system that handles following a target. It is a script that extends the AIState class and is used to define behaviors for AI-controlled units. 

The script contains two public variables, which are the Transform of the target to follow and the minimum distance that must be maintained from it (stoppingDistance). 

The EnterState() and ExitState() methods are left empty, as they allow for actions to be taken when the state is either entered or exited, such as playing animations or sounds. 

The UpdateState() method is where the actual following logic is implemented. It calculates the distance between the AI unit's current position and the target position, and then checks if it is greater than the stoppingDistance. If it is, it uses the NavMeshAgent component to set a destination for the unit, which will allow it to move towards the target. If it is not greater, the NavMeshAgent is reset to stop the unit from moving. 

In summary, the FollowState.cs script contains logic for an AI-controlled unit to follow a target at a defined distance, using the Unity NavMeshAgent component to move towards the target.
Code of file FollowState:
﻿using UnityEngine;

[CreateAssetMenu(menuName = "AI/States/FollowState")]
public class FollowState : AIState
{
    public Transform target;
    public float stoppingDistance = 2f;

    public override void EnterState(AIController aiController)
    {
    }

    public override void UpdateState(AIController aiController)
    {
        float distanceToTarget = Vector3.Distance(aiController.transform.position, target.position);

        if (distanceToTarget > stoppingDistance)
        {
            aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().SetDestination(target.position);
        }
        else
        {
            aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().ResetPath();
        }
    }

    public override void ExitState(AIController aiController)
    {
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\FollowState.cs
FollowState:
- target: Transform
- stoppingDistance: float

EnterState(aiController):
UpdateState(aiController):
- distanceToTarget: float = Vector3.Distance(aiController.transform.position, target.position)
- if distanceToTarget > stoppingDistance:
  - aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().SetDestination(target.position)
- else:
  - aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().ResetPath()

ExitState(aiController):

- IdleState at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\IdleState.cs:
Summery of IdleState:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\IdleState.cs
Summary:
The IdleState.cs script is responsible for representing the idle behavior of AI-controlled characters in the game. It is a derived class of the base AIState class and comes with an assigned menu item of "AI/States/IdleState." This script has two public variables: idleDuration and idleTime.

The idleDuration variable holds the duration of idle behavior, which is set to 3 seconds by default. idleTime is the real-life time when the AI character will go out of idle mode and start patrolling. During the EnterState function, the idleTime is set by adding idleDuration to the current time.

The UpdateState function checks if the current time is greater than the idleTime. If it is, then the AIController of the character is commanded to ChangeState to the patrolState (which must be defined elsewhere). The ExitState function doesn't do anything specific during the character's leaving of the IdleState.

Overall, the IdleState.cs script is instrumental in maintaining consistency and balance in AI-controlled characters' idle behavior.
Code of file IdleState:
﻿using UnityEngine;

[CreateAssetMenu(menuName = "AI/States/IdleState")]
public class IdleState : AIState
{
    public float idleDuration = 3f;

    private float idleTime;

    public override void EnterState(AIController aiController)
    {
        idleTime = Time.time + idleDuration;
    }

    public override void UpdateState(AIController aiController)
    {
        if (Time.time > idleTime)
        {
            aiController.ChangeState(aiController.patrolState);
        }
    }

    public override void ExitState(AIController aiController)
    {
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\IdleState.cs
IdleState:
- CreateAssetMenu:
    - menuName = "AI/States/IdleState"
- Inherit from AIState
- float idleDuration
- float idleTime
- EnterState:
    - Set idleTime to current Time + idleDuration
- UpdateState:
    - If current Time > idleTime, ChangeState to patrolState
- ExitState:
    - Empty

- PatrolState at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\PatrolState.cs:
Summery of PatrolState:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\PatrolState.cs
The file is named "PatrolState.cs" and it is a script that defines a patrol state for an AI controller in a game. The script has a list of waypoints that the AI will move between, a patrol speed, and a wait time between each waypoint. The current waypoint and wait end time are stored as private variables.

During the EnterState function, the AI's NavMeshAgent speed is set to the provided patrol speed and the current waypoint is set to 0. In the UpdateState function, the AI will check for any aggro and get its NavMeshAgent. If there are waypoints in the list, the AI will check if it has arrived at its current waypoint and if the wait time has ended. If so, it will set its destination to the next waypoint in the list and set a new wait end time.

The ExitState function is empty and can be used to clean up or reset any variables as needed.
Code of file PatrolState:
﻿using System.Collections.Generic;
using UnityEngine;
[CreateAssetMenu(menuName = "AI/States/PatrolState")]
public class PatrolState : AIState
{
    public List<Transform> waypoints;
    public float patrolSpeed = 3f;
    public float waitTime = 3f;

    private int currentWaypoint;
    private float waitEndTime;

    public override void EnterState(AIController aiController)
    {
        aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().speed = patrolSpeed;
        currentWaypoint = 0;
    }

    public override void UpdateState(AIController aiController)
    {   
        aiController.checkForAggro();

        UnityEngine.AI.NavMeshAgent agent = aiController.GetComponent<UnityEngine.AI.NavMeshAgent>();

        if (waypoints.Count > 0)
        {
            if (!agent.pathPending && agent.remainingDistance < 0.5f)
            {
                if (Time.time > waitEndTime)
                {
                    currentWaypoint = (currentWaypoint + 1) % waypoints.Count;
                    agent.SetDestination(waypoints[currentWaypoint].position);
                    waitEndTime = Time.time + waitTime;
                }
            }
        }
    }

    public override void ExitState(AIController aiController)
    {
        // Clean up or reset any variables if needed
    }
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\PatrolState.cs
Class: PatrolState (File Name: PatrolState.cs)

- List<Transform> waypoints
- float patrolSpeed
- float waitTime
- int currentWaypoint
- float waitEndTime

EnterState(AIController aiController)
- aiController.GetComponent<UnityEngine.AI.NavMeshAgent>().speed = patrolSpeed
- currentWaypoint = 0

UpdateState(AIController aiController)
- aiController.checkForAggro()
- UnityEngine.AI.NavMeshAgent agent = aiController.GetComponent<UnityEngine.AI.NavMeshAgent>()
- if(waypoints.Count > 0)
- if(!agent.pathPending && agent.remainingDistance < 0.5f)
- if(Time.time > waitEndTime)
- currentWaypoint = (currentWaypoint + 1) % waypoints.Count
- agent.SetDestination(waypoints[currentWaypoint].position)
- waitEndTime = Time.time + waitTime

ExitState(AIController aiController)
- Clean up or reset any variables if needed

- PatrolStateMonoBehaviour at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\PatrolStateMonoBehaviour.cs:
Summery of PatrolStateMonoBehaviour:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\PatrolStateMonoBehaviour.cs
This file is called PatrolStateMonoBehaviour. It is a script for managing the patrol behavior of an AI-controlled player unit in a Unity game. 
The script contains a public variable that holds an array of GameObjects representing the patrol waypoints for the unit. 
During gameplay, the unit will move between waypoints in the array to simulate patrolling behavior.

The implementation logic of this script is relatively simple. The script's main purpose is to store and manage the patrol waypoints for the unit. 
When the game begins, the script sets the first waypoint in the array as the unit's destination. 
As the unit moves towards the destination, the script checks if the unit has arrived at the waypoint. 
If the unit has reached the waypoint, the script sets the next waypoint in the array as the unit's destination. 
This loop continues until the unit has visited all the waypoints in the array or the game is ended. 

In summary, the PatrolStateMonoBehaviour script manages the patrol behavior of an AI-controlled player unit in a Unity game by storing an array of patrol waypoints and updating the unit's destination to the next waypoint in the array as the unit reaches each waypoint in the patrol.
Code of file PatrolStateMonoBehaviour:
﻿using UnityEngine;

public class PatrolStateMonoBehaviour : MonoBehaviour
{
    public GameObject[] waypoints;
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AiStates\PatrolStateMonoBehaviour.cs
Class: PatrolStateMonoBehaviour
 - GameObject[] waypoints

- AnimationController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AnimationController.cs:
Summery of AnimationController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AnimationController.cs
The file AnimationController.cs is a script for controlling animations and visual effects for a player or units in Unity. It contains a serialized Animator component and a list of VisualEffectData objects. The Awake() method initializes a dictionary of visual effects using the names and prefabs from the VisualEffectData list. The PlayAnimation() method plays the specified animation using the Animator component, with an additional check for the "attack" animation which is triggered instead. Finally, the ApplyVisualEffect() method instantiates a visual effect at a given position and rotation using the visualEffects dictionary. If the specified effect is not found in the dictionary, a warning message is displayed.
Code of file AnimationController:
﻿using System.Collections.Generic;
using UnityEngine;

public class AnimationController : MonoBehaviour
{
    [SerializeField] private Animator animator;
    [SerializeField] private List<VisualEffectData> visualEffectDataList;

    [SerializeField] private List<(string, float)> animationCastDelays;
    public const string attackAnimationName = "attack";
    public const string OneHandSwordLightAttack1AnimationName = "1HandSwordLightAttack1";
    public const string OneHandSwordLightAttack2AnimationName = "1HandSwordLightAttack2";
    public const string OneHandSwordLightAttack3AnimationName = "1HandSwordLightAttack3";

    public const string idleAnimationName = "idle";


    private Dictionary<string, GameObject> visualEffects;

    private void Awake()
    {
        // Initialize the visualEffects dictionary.
        initAnimationDelays();
        visualEffects = new Dictionary<string, GameObject>();
        foreach (VisualEffectData effectData in visualEffectDataList)
        {
            visualEffects.Add(effectData.name, effectData.visualEffectPrefab);
        }
    }

    public void PlayAnimation(string animationName)
    {
        // Play the specified animation.
        if (animationName == "attack")
        {
            animator.SetTrigger("attack");
            return;
        }

        animator.Play(animationName);
    }

    public void ApplyVisualEffect(string effectName, Vector3 position, Quaternion rotation)
    {
        // Instantiate the specified visual effect at the given position and rotation.
        if (visualEffects.TryGetValue(effectName, out GameObject effectPrefab))
        {
            Instantiate(effectPrefab, position, rotation);
        }
        else
        {
            Debug.LogWarning($"Visual effect '{effectName}' not found.");
        }
    }
    public void initAnimationDelays()
    {
        animationCastDelays = new List<(string, float)>();
        animationCastDelays.Add(("attack", 0.11f));
        animationCastDelays.Add(("1HandSwordLightAttack1", 0.11f));
        animationCastDelays.Add(("1HandSwordLightAttack2", 0.07f));
        animationCastDelays.Add(("1HandSwordLightAttack3", 0.06f));

    }
    public float returnAnimationDelay(string animationName)
    {
        foreach ((string, float) paar in animationCastDelays)
        {
            if (paar.Item1 == animationName)
            {
                return paar.Item2;
            }
        }
        return 0;
    }
    
}

[System.Serializable]
public class VisualEffectData
{
    public string name;
    public GameObject visualEffectPrefab;
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\AnimationController.cs
Syntax Tree of AnimationController.cs:
- AnimationController class
  - MonoBehaviour parent class
  - Private fields:
    - Animator animator
    - List<VisualEffectData> visualEffectDataList
    - List<(string, float)> animationCastDelays
    - Private const strings:
      - attackAnimationName = "attack"
      - OneHandSwordLightAttack1AnimationName = "1HandSwordLightAttack1"
      - OneHandSwordLightAttack2AnimationName = "1HandSwordLightAttack2"
      - OneHandSwordLightAttack3AnimationName = "1HandSwordLightAttack3"
      - idleAnimationName = "idle"
    - Dictionary<string, GameObject> visualEffects
  - Awake() method
    - Initializes the visualEffects dictionary
    - Calls initAnimationDelays() method
    - Loops through each VisualEffectData object in visualEffectDataList, adding the corresponding visual effect prefab to visualEffects dictionary
  - PlayAnimation() method
    - If animationName is "attack", sets the animator trigger to "attack" and returns
    - Otherwise, plays the animation with the given name using the animator Play() method
  - ApplyVisualEffect() method
    - If the effectName is found in visualEffects dictionary, instantiates the visualEffectPrefab at the given position and rotation
    - Otherwise, logs a warning message
  - initAnimationDelays() method
    - Initializes the animationCastDelays list with pairs of animation names and corresponding delay times
  - returnAnimationDelay() method
    - Loops through each pair in animationCastDelays and returns the delay time corresponding to animationName, or 0 if not found

VisualEffectData class:
- Serializable class
- Public fields:
  - string name
  - GameObject visualEffectPrefab

- BuffSystem at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\BuffSystem.cs:
Summery of BuffSystem:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\BuffSystem.cs
This script is called BuffSystem and is responsible for managing buffs in the game. It uses two dictionaries, activeBuffs and eventHandlers, to keep track of active buffs and their associated events. 

The AddBuff method adds a new buff to a target game object. If the buff already exists, it either refreshes its duration or adds a new stack if the buff is stackable and hasn't reached its maximum number of stacks. If the buff is new, it creates a new BuffInstance and adds it to the activeBuffs dictionary. 

The RemoveBuff method removes a buff from the activeBuffs dictionary. If the buff still has stacks left, it simply removes one stack. If the buff has no remaining stacks, it removes the buff entirely and removes its associated event handlers. 

The GetBuffInstance method returns the BuffInstance associated with a given buff name, if it exists. 

The AddEventHandlers and RemoveEventHandlers methods add and remove event handlers for a given buff. These event handlers are based on the eventType obtained from each buff's GetEventTypes method. 

The CallEventHandlers method calls the event handlers associated with a given eventType and BuffInstance. 

Overall, this script provides a robust system for managing buffs and their associated events in the game.
Code of file BuffSystem:
﻿using System.Collections.Generic;
using UnityEngine;

public class BuffSystem : MonoBehaviour
{
    public Dictionary<string, BuffInstance> activeBuffs;
    public List <string> buffsToRemove;
    private Dictionary<string, System.Action<BuffInstance>> eventHandlers;

    public StatsModifier TotalstatsModifier;
     

    private void Awake()
    {
        buffsToRemove = new List<string>();
        activeBuffs = new Dictionary<string, BuffInstance>();
        eventHandlers = new Dictionary<string, System.Action<BuffInstance>>();
    }

    private void Update()
    {
        foreach (BuffInstance buffInstance in activeBuffs.Values)
        {
            buffInstance.Update();
        }
        removeBuffs();
    }
    private void removeBuffs(){
        foreach (string buffName in buffsToRemove)
        {
            BuffInstance buffInstance = activeBuffs[buffName];
            RemoveEventHandlers(buffInstance.buff);
            activeBuffs.Remove(buffName);
        }
        buffsToRemove.Clear();
    }
    public void AddBuff(Buff buff, GameObject target)
    {
        if(buff==null){
            Debug.LogError("buff is null");
            return;
        }
        if (activeBuffs.ContainsKey(buff.buffName))
        {
            BuffInstance existingBuff = activeBuffs[buff.buffName];

            if (buff.stackable && existingBuff.currentStacks < buff.maxStacks)
            {
                existingBuff.AddStack();
                existingBuff.Refresh(buff.duration);
            }
            else
            {
                existingBuff.Refresh(buff.duration);
            }
        }
        else
        {
            BuffInstance newBuff = new BuffInstance(buff, target, 1, buff.duration);
            activeBuffs.Add(buff.buffName, newBuff);
            AddEventHandlers(buff);
            newBuff.OnBuffApply();
        }
    }

    public void RemoveBuff(Buff buff)
    {
        buffsToRemove.Add(buff.buffName);

    }

    public BuffInstance GetBuffInstance(string buffName)
    {
        if (activeBuffs.ContainsKey(buffName))
        {
            return activeBuffs[buffName];
        }
        return null;
    }

    private void AddEventHandlers(Buff buff)
    {
        List<string> eventTypes = buff.GetEventTypes();

        foreach (string eventType in eventTypes)
        {
            if (!eventHandlers.ContainsKey(eventType))
            {
                eventHandlers.Add(eventType, (BuffInstance buffInstance) => { });
            }

            System.Action<BuffInstance> eventHandler = null;
            switch (eventType)
            {
                case "OnApply":
                    eventHandler = buff.InvokeOnApply;
                    break;
                case "OnFade":
                    eventHandler = buff.InvokeOnFade;
                    break;
                case "OnHit":
                    eventHandler = buff.InvokeOnHit;
                    break;
            }

            if (eventHandler != null)
            {
                eventHandlers[eventType] += eventHandler;
            }
        }
    }

    private void RemoveEventHandlers(Buff buff)
    {
        List<string> eventTypes = buff.GetEventTypes();

        foreach (string eventType in eventTypes)
        {
            System.Action<BuffInstance> eventHandler = null;
            switch (eventType)
            {
                case "OnApply":
                    eventHandler = buff.InvokeOnApply;
                    break;
                case "OnFade":
                    eventHandler = buff.InvokeOnFade;
                    break;
                case "OnHit":
                    eventHandler = buff.InvokeOnHit;
                    break;
            }

            if (eventHandler != null)
            {
                eventHandlers[eventType] -= eventHandler;
            }
        }
    }

    public void CallEventHandlers(string eventType, BuffInstance buffInstance)
    {
        if (eventHandlers.ContainsKey(eventType))
        {
            eventHandlers[eventType]?.Invoke(buffInstance);
        }
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\BuffSystem.cs
BuffSystem

- private Dictionary<string, BuffInstance> activeBuffs
- private Dictionary<string, System.Action<BuffInstance>> eventHandlers

+ Awake()
    - activeBuffs = new Dictionary<string, BuffInstance>()
    - eventHandlers = new Dictionary<string, System.Action<BuffInstance>>()

+ AddBuff(Buff buff, GameObject target)
    ? activeBuffs.ContainsKey(buff.buffName)
        + existingBuff = activeBuffs[buff.buffName]
        ? buff.stackable && existingBuff.currentStacks < buff.maxStacks
            - existingBuff.AddStack()
            - existingBuff.Refresh(buff.duration)
        : - existingBuff.Refresh(buff.duration)
    : + newBuff = new BuffInstance(buff, target, 1, buff.duration)
        - activeBuffs.Add(buff.buffName, newBuff)
        + AddEventHandlers(buff)
        - newBuff.OnBuffApply()

+ RemoveBuff(Buff buff)
    ? activeBuffs.ContainsKey(buff.buffName)
        + existingBuff = activeBuffs[buff.buffName]
        - existingBuff.RemoveStack()
        ? existingBuff.currentStacks <= 0
            - RemoveEventHandlers(buff)
            - activeBuffs.Remove(buff.buffName)

+ GetBuffInstance(string buffName)
    ? activeBuffs.ContainsKey(buffName)
        - return activeBuffs[buffName]
    - return null

- AddEventHandlers(Buff buff)
    + eventTypes = buff.GetEventTypes()
    . foreach(string eventType in eventTypes)
        ? !eventHandlers.ContainsKey(eventType)
            - eventHandlers.Add(eventType, (BuffInstance buffInstance) => {})
        - eventHandler = null
        ? eventType == "OnApply"
            - eventHandler = buff.InvokeOnApply
        ? eventType == "OnFade"
            - eventHandler = buff.InvokeOnFade
        ? eventType == "OnHit"
            - eventHandler = buff.InvokeOnHit
        ? eventHandler != null
            - eventHandlers[eventType] += eventHandler

- RemoveEventHandlers(Buff buff)
    + eventTypes = buff.GetEventTypes()
    . foreach(string eventType in eventTypes)
        - eventHandler = null
        ? eventType == "OnApply"
            - eventHandler = buff.InvokeOnApply
        ? eventType == "OnFade"
            - eventHandler = buff.InvokeOnFade
        ? eventType == "OnHit"
            - eventHandler = buff.InvokeOnHit
        ? eventHandler != null
            - eventHandlers[eventType] -= eventHandler

+ CallEventHandlers(string eventType, BuffInstance buffInstance)
    ? eventHandlers.ContainsKey(eventType)
        - eventHandlers[eventType]?.Invoke(buffInstance)

- ButtonWithToolTip at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ButtonWithToolTip.cs:
Summery of ButtonWithToolTip:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ButtonWithToolTip.cs
This script is called "ButtonWithToolTip" and is used in the "PlayerAndUnitsComponent" folder of the project. It contains several public variables, including a SkillNode, a PlayerController, a UIManager, a GameObject, and a Text. It also has a private variable for a Button component.

In the Awake method, the script gets the Button component and sets its onClick listener to call the TryLearn method. It also sets the image sprite to the SkillNode's icon.

The script implements the IPointerEnterHandler and IPointerExitHandler interfaces, which allow it to show and hide a tooltip when the mouse pointer enters or exits the button. The ShowToolTip method calls the UIManager's OpenToolTipSkill method, passing in the SkillNode and the position of the button on the screen. The HideToolTip method calls the UIManager's CloseToolTipSkill method.

The TryLearn method is called when the player clicks the button and attempts to unlock the associated SkillNode using the PlayerController's TryUnlockSkillNode method.
Code of file ButtonWithToolTip:
﻿using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ButtonWithToolTip : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
{
    public SkillNode skillNode;
    private PlayerController playerController;
    public UIManager uiManager;
    private GameObject toolTipObject;

    private Button button;

    private void Awake()
    {
        playerController = FindObjectOfType<PlayerController>();
        uiManager = FindObjectOfType<UIManager>();
        toolTipObject = uiManager.tooltip;
        toolTipObject.SetActive(false);

        button = GetComponent<Button>();
        button.onClick.AddListener(TryLearn);
        if(skillNode!=null){
            GetComponent<Image>().sprite = skillNode.icon;
        }
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        ShowToolTip();
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        HideToolTip();
    }

    private void ShowToolTip()
    {
        uiManager.OpenToolTip(skillNode, gameObject.GetComponent<RectTransform>().position);
    }

    private void HideToolTip()
    {
        uiManager.CloseToolTip();
    }

    private void TryLearn()
    {
        playerController.TryUnlockSkillNode(skillNode);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ButtonWithToolTip.cs
Class: ButtonWithToolTip

- skillNode: SkillNode
- playerController: PlayerController
- uiManager: UIManager
- toolTipObject: GameObject
- button: Button

- Awake()
  - playerController = FindObjectOfType<PlayerController>()
  - uiManager = FindObjectOfType<UIManager>()
  - toolTipObject = uiManager.tooltip
  - toolTipObject.SetActive(false)
  - button = GetComponent<Button>()
  - button.onClick.AddListener(TryLearn)
  - if (skillNode != null)
    - GetComponent<Image>().sprite = skillNode.icon

- OnPointerEnter(eventData: PointerEventData)
  - ShowToolTip()

- OnPointerExit(eventData: PointerEventData)
  - HideToolTip()

- ShowToolTip()
  - uiManager.OpenToolTip(skillNode, gameObject.GetComponent<RectTransform>().position)

- HideToolTip()
  - uiManager.CloseToolTip()

- TryLearn()
  - playerController.TryUnlockSkillNode(skillNode)

- CharacterCombatController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\CharacterCombatController.cs:
Summery of CharacterCombatController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\CharacterCombatController.cs
The file "CharacterCombatController.cs" is a script that controls the combat actions of the player and units in the game. It provides access to the player's CharacterStats, AbilityController, AnimationController, and IStunnable components. 

During the Start method, the script retrieves the CharacterStats and IStunnable components from the game object. 

The PerformAbility method is responsible for executing an Ability on a target. This method first checks if the character is stunned, and if so, it returns early. Otherwise, it calculates the damage of the Ability using the Ability's base damage, strength scaling, and intelligence scaling, and adds a critical hit chance based on the character's critical chance stat. If the Ability lands a critical hit, the calculated damage is doubled. 

The method then plays the Ability's animation, creates an AbilityData object containing necessary information about the CasterStats, target, and the AbilityController, and then executes the Ability using the AbilityController's CastAbility method. 

Lastly, the GetCharacterStats method returns the character's CharacterStats. 

There is an additional PerformAbility method in the script that is not implemented and currently throws an exception.
Code of file CharacterCombatController:
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class CharacterCombatController : MonoBehaviour, IStatsProvider
{
    public CharacterStats characterStats;
    public AbilityController abilityController;
    public AnimationController animationController;
    public IStunnable stunnable;
    public ComboController comboController;


    private void Start()
    {
        characterStats = GetComponent<CharacterStats>();
        stunnable = GetComponent<IStunnable>();
        abilityController = GetComponent<AbilityController>();
        animationController = GetComponent<AnimationController>();
        comboController = new ComboController();
    }

    public void PerformAbility(Ability ability, GameObject target)
    {
        if(stunnable.isStunned())
        {
            return;
        }
        if(abilityController.checkCooldown(ability.name,ability.cooldown)==false)
        {
            return;
        }
        PlayerController playerController = GetComponent<PlayerController>();
        if (playerController != null)
        {
           playerController.faceIndirectionOfCamera();
        }
        float damageAbility = ability.baseDamage + (ability.strengthScaling * characterStats.strength) + (ability.intelligenceScaling * characterStats.intelligence);
        float critChance = characterStats.criticalChance;
        if (Random.Range(0f, 1f) <= critChance)
        {
            damageAbility *= 2;
        }


        AbilityData abilityData = new AbilityData
        {
            CasterStats = characterStats,
            Target = target,
            damage = damageAbility,
            CasterController = abilityController,
            CasterCombatController = this
            // ... other fields
        };
        abilityController.setCooldown(ability.name,ability.cooldown);
        comboController.UpdateComboController();
        abilityController.CastAbility(ability, abilityData);
    }
    public CharacterStats GetCharacterStats()
    {
        return characterStats;
    }

}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\CharacterCombatController.cs
File: CharacterCombatController.cs
- Class: CharacterCombatController
    - characterStats
    - abilityController
    - animationController
    - stunnable
    - comboController
    - Start()
        - characterStats = GetComponent<CharacterStats>()
        - stunnable = GetComponent<IStunnable>()
        - abilityController = GetComponent<AbilityController>()
        - animationController = GetComponent<AnimationController>()
        - comboController = new ComboController()
    - PerformAbility(Ability ability, GameObject target)
        - if stunnable.isStunned()
            - return
        - if abilityController.checkCooldown(ability.name,ability.cooldown)==false
            - return
        - playerController = GetComponent<PlayerController>()
        - if playerController != null
            - playerController.faceIndirectionOfCamera()
        - damageAbility = ability.baseDamage + (ability.strengthScaling * characterStats.strength) + (ability.intelligenceScaling * characterStats.intelligence)
        - critChance = characterStats.criticalChance
        - if Random.Range(0f, 1f) <= critChance
            - damageAbility *= 2
        - abilityData = new AbilityData
            - CasterStats = characterStats
            - Target = target
            - damage = damageAbility
            - CasterController = abilityController
            - CasterCombatController = this
        - abilityController.setCooldown(ability.name,ability.cooldown)
        - comboController.UpdateComboController()
        - abilityController.CastAbility(ability, abilityData)
    - GetCharacterStats()
        - return characterStats

- CharacterStats at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\CharacterStats.cs:
Summery of CharacterStats:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\CharacterStats.cs
The "CharacterStats.cs" file contains a script that defines the main and sub-stats of a character in a Unity game. The main stats include strength, intelligence, dexterity, endurance, and wisdom, while the sub-stats include critical chance and damage, attack speed, spell critical chance and damage, cooldowns, max life and mana, life and mana regeneration, armor, magic resistance, and dodge chance.

The script also includes functions to update the sub-stats based on changes to the main stats, equipment bonuses, and skill modifiers. The script allows for the addition of stat points to the main stats, and provides a switch-case function to increase the specific stat type based on the inputted value.

The script initializes unspent stat points and tracks them as they are gained or used. Additionally, the script contains event actions that are triggered when stats are changed, as well as functions to apply stat bonuses from equipment and skills.

Overall, the "CharacterStats.cs" file is crucial in managing the attributes and abilities of the player character, allowing for a flexible and customizable gaming experience.
Code of file CharacterStats:
﻿using System;
using System.Collections;
using UnityEngine;
[Serializable]
public class CharacterStats : MonoBehaviour
{
    // MainStats
    public float strength;
    public float intelligence;
    public float dexterity;
    public float endurance;
    public float wisdom;

    // SubStats

    public float criticalChance;
    public float criticalDamage;
    public float attackSpeed;

    public float spellCriticalChance;
    public float spellCriticalDamage;

    public float cooldown;

    public float maxLife;
    public float maxMana;
    public float lifeRegen;
    public float manaRegen;

    public float armor;
    public float magicResistance;

    public float dodgeChance;

    public int unspentStatPoints;

    public event Action StatsChanged;
    private EquipManager equipManager;
    private SkillController skillController;
    private BuffSystem buffSystem;

    private void Awake()
    {
        buffSystem = GetComponent<BuffSystem>();
        equipManager = GetComponent<EquipManager>();
        skillController = GetComponent<SkillController>();
    }
    private void Start()
    {
        // Initialize unspentStatPoints or load from saved game data
        unspentStatPoints = 10;
        StartCoroutine(InitializeCharacterStats());        
    }
    private IEnumerator InitializeCharacterStats()
    {
        yield return new WaitUntil(() => equipManager != null);
        UpdateSubStats();

                
         HealthController healthController = GetComponent<HealthController>();
         if(healthController != null){
                healthController.updateHealth();
         }
         ManaController manaController = GetComponent<ManaController>();
            if(manaController != null){
                    manaController.updateMana();
            }
        
    }
    public void AddStatPoints(int amount)
    {
        unspentStatPoints += amount;
        StatsChanged?.Invoke();
    }

    public void UpdateSubStats()
    {

        strength += equipManager.TotalStrength;
        intelligence += equipManager.TotalIntelligence;
        dexterity += equipManager.TotalDexterity;
        endurance += equipManager.TotalEndurance;
        wisdom += equipManager.TotalWisdom;


        criticalChance = 0.02f * dexterity;
        criticalDamage = 1.5f + (0.14f * dexterity);
        attackSpeed = 1 + (0.01f * strength * dexterity);

        spellCriticalChance = 0.02f * intelligence;
        spellCriticalDamage = 1.5f + (0.14f * intelligence);

        armor = 1.5f * endurance;
        magicResistance = 1.5f * endurance;


        // Calculate substats based on main stats + equipment bonuses.
        maxLife = 100 + 20 * endurance;
        maxMana = 100 + 20 * wisdom;
        lifeRegen = 1 + 0.25f * endurance;
        manaRegen = 0.5f + 0.25f * wisdom;

        dodgeChance = 0.009f * dexterity;

        AddStatBonuses(equipManager.TotalStatModier);
        AddStatBonuses(skillController.totalStatsModier);
        AddStatBonuses(buffSystem.TotalstatsModifier);


        StatsChanged?.Invoke();
    }

    public void AddStatBonuses(StatsModifier statModifier)
    {

        attackSpeed += statModifier.attackSpeed;
        criticalChance += statModifier.criticalChance;
        criticalDamage += statModifier.criticalDamage;
        spellCriticalChance += statModifier.spellCriticalChance;
        spellCriticalDamage += statModifier.spellCriticalDamage;
        cooldown += statModifier.cooldown;
        dodgeChance += statModifier.dodgeChance;
        armor += statModifier.armor;
        magicResistance += statModifier.magicResistance;
        maxLife += statModifier.maxLife;
        maxMana += statModifier.maxMana;
        lifeRegen += statModifier.lifeRegen;
        manaRegen += statModifier.manaRegen;
    }
    public void RemoveStatBonuses(StatsModifier statModifier)
    {
        attackSpeed -= statModifier.attackSpeed;
        criticalChance -= statModifier.criticalChance;
        criticalDamage -= statModifier.criticalDamage;
        spellCriticalChance -= statModifier.spellCriticalChance;
        spellCriticalDamage -= statModifier.spellCriticalDamage;
        cooldown -= statModifier.cooldown;
        dodgeChance -= statModifier.dodgeChance;
        armor -= statModifier.armor;
        magicResistance -= statModifier.magicResistance;
        maxLife -= statModifier.maxLife;
        maxMana -= statModifier.maxMana;
        lifeRegen -= statModifier.lifeRegen;
        manaRegen -= statModifier.manaRegen;
    }


    public void IncreaseStat(Archetype stateType, int amount)
    {
        if (unspentStatPoints >= amount)
        {
            switch (stateType)
            {
                case Archetype.Strength:
                    strength += amount;
                    break;
                case Archetype.Intelligence:
                    intelligence += amount;
                    break;
                case Archetype.Dexterity:
                    dexterity += amount;
                    break;
                case Archetype.Endurance:
                    endurance += amount;
                    break;
                case Archetype.Wisdom:
                    wisdom += amount;
                    break;
                default:
                    Debug.LogWarning("Invalid stat name.");
                    return;
            }

            unspentStatPoints -= amount;
            UpdateSubStats();
        }
        else
        {
            Debug.LogWarning("Not enough stat points.");
        }
    }

    internal void SetStats(CharacterStats stats)
    {
        strength = stats.strength;
        intelligence = stats.intelligence;
        dexterity = stats.dexterity;
        endurance = stats.endurance;
        wisdom = stats.wisdom;
        equipManager = GetComponent<EquipManager>();
        UpdateSubStats();
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\CharacterStats.cs
Class: CharacterStats
- float strength
- float intelligence
- float dexterity
- float endurance
- float wisdom
- float criticalChance
- float criticalDamage
- float attackSpeed
- float spellCriticalChance
- float spellCriticalDamage
- float cooldown
- float maxLife
- float maxMana
- float lifeRegen
- float manaRegen
- float armor
- float magicResistance
- float dodgeChance
- int unspentStatPoints
- event Action StatsChanged
- EquipManager equipManager
- SkillController skillController

+ void Awake()
+ void Start()
+ IEnumerator InitializeCharacterStats()
+ void AddStatPoints(int amount)
+ void UpdateSubStats()
+ void AddStatBonuses(StatsModifier statModifier)
+ void IncreaseStat(Archetype stateType, int amount)
+ void SetStats(CharacterStats stats)

- ComboController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ComboController.cs:
Summery of ComboController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ComboController.cs
The file name is ComboController.cs. It contains two classes, ComboController and ComboCounter. ComboController has a List of ComboCounters, which is initialized in its constructor. The UpdateComboController method loops through all the ComboCounters in the list, calling their UpdateComboCounter method. The IncreaseComboCounter method takes a string parameter, which represents the name of the combo to be increased. It loops through all the ComboCounters in the list, checking if the ComboName matches the input string. If it does, it calls the IncreaseComboCounter method of that ComboCounter. If it doesn't find a match, it creates a new ComboCounter with a comboCounter of 1. The GetComboCounter method also takes a string parameter for the name of the combo to retrieve. It loops through the ComboCounters, checking for a match and returning the comboCounter of the matching ComboCounter. If no match is found, it returns 0. ComboCounter has a ComboName, comboCounter, comboTimer, and comboTimeLimit variables. Its constructor sets the comboTimeLimit and initializes comboCounter and comboTimer to 0. The UpdateComboCounter method adds Time.deltaTime to comboTimer, and if comboTimer exceeds comboTimeLimit, comboCounter is reset to 0. IncreaseComboCounter increments comboCounter and sets comboTimer to 0. The GetComboCounter method returns the comboCounter value. ResetComboCounter resets comboCounter and comboTimer to 0.
Code of file ComboController:
using System;
using System.Collections.Generic;
using UnityEngine;
[System.Serializable]
public class ComboController{
    public List<ComboCounter> comboCounterList;

    public ComboController(){
        comboCounterList = new List<ComboCounter>();
    }
    public void UpdateComboController(){
        foreach (ComboCounter comboCounter in comboCounterList)
        {
            comboCounter.UpdateComboCounter();
        }
    }
    public void IncreaseComboCounter(string comboName){
        bool found = false;
        foreach (ComboCounter comboCounter in comboCounterList)
        {
            if(comboCounter.ComboName == comboName){
                comboCounter.IncreaseComboCounter();
                found = true;
            }
        }
        if(!found){
            comboCounterList.Add(new ComboCounter(1f,comboName));
        }
    }
    public int GetComboCounter(string comboName){
        foreach (ComboCounter comboCounter in comboCounterList)
        {
            if(comboCounter.ComboName == comboName){
                return comboCounter.GetComboCounter();
            }
        }
        return 0;
    }

    internal void ResetComboCounter(string comboName)
    {
        foreach (ComboCounter comboCounter in comboCounterList)
        {
            if(comboCounter.ComboName == comboName){
                comboCounter.ResetComboCounter();
            }
        }
    }
}
[System.Serializable]
public class ComboCounter{
    
    public string ComboName;
    public int comboCounter;
    public float comboTimer;
    public float comboTimeLimit;
    public ComboCounter(float comboTimeLimit,string comboName){
        this.comboTimeLimit = comboTimeLimit;
        comboCounter = 0;
        comboTimer = 0;
        ComboName = comboName;
    }
    public void UpdateComboCounter(){
        comboTimer += Time.deltaTime;
        if(comboTimer >= comboTimeLimit){
            comboCounter = 0;
        }
    }
    public void IncreaseComboCounter(){
        UpdateComboCounter();
        comboCounter++;
        comboTimer = 0;
    }
    public int GetComboCounter(){
        return comboCounter;
    }
    public void ResetComboCounter(){
        comboCounter = 0;
        comboTimer = 0;
    }
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ComboController.cs
File: ComboController.cs

Class: ComboController
 - comboCounterList: List<ComboCounter>

Method: ComboController()
 - comboCounterList = new List<ComboCounter>()

Method: UpdateComboController()
 - foreach (ComboCounter comboCounter in comboCounterList)
   - comboCounter.UpdateComboCounter()

Method: IncreaseComboCounter(string comboName)
 - bool found = false
 - foreach (ComboCounter comboCounter in comboCounterList)
   - if(comboCounter.ComboName == comboName)
     - comboCounter.IncreaseComboCounter()
     - found = true
 - if(!found)
   - comboCounterList.Add(new ComboCounter(1f, comboName))

Method: GetComboCounter(string comboName)
 - foreach (ComboCounter comboCounter in comboCounterList)
   - if(comboCounter.ComboName == comboName)
     - return comboCounter.GetComboCounter()
 - return 0

Method: ResetComboCounter(string comboName)
 - foreach (ComboCounter comboCounter in comboCounterList)
   - if(comboCounter.ComboName == comboName)
     - comboCounter.ResetComboCounter()

Class: ComboCounter
 - ComboName: string
 - comboCounter: int
 - comboTimer: float
 - comboTimeLimit: float

Method: ComboCounter(float comboTimeLimit, string comboName)
 - this.comboTimeLimit = comboTimeLimit
 - comboCounter = 0
 - comboTimer = 0
 - ComboName = comboName

Method: UpdateComboCounter()
 - comboTimer += Time.deltaTime
 - if(comboTimer >= comboTimeLimit)
   - comboCounter = 0

Method: IncreaseComboCounter()
 - UpdateComboCounter()
 - comboCounter++
 - comboTimer = 0

Method: GetComboCounter()
 - return comboCounter

Method: ResetComboCounter()
 - comboCounter = 0
 - comboTimer = 0

- EquipManager at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\EquipManager.cs:
Summery of EquipManager:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\EquipManager.cs
The file "EquipManager.cs" contains a class for managing equipment items in a game. It defines an enum for different types of equipment, and a dictionary that stores equipped items of each type. 

The class also has properties for storing the total stats from all equipped items, including TotalStrength, TotalIntelligence, TotalDexterity, TotalEndurance, and TotalWisdom. The class allows for adding more stat properties if needed. 

The class has two methods, EquipItem and UnequipItem, for equipping and unequipping items respectively. If an item is already equipped for a certain type, EquipItem will first unequip the previous item before equipping the new one. Unequipping an item removes its effect from the total stats. 

The class also has two private methods, ApplyItemStats and RemoveItemStats, for adding and removing the effect of an item from the total stats. ApplyItemStats adds the item's stat bonuses to the total stats and adds any sub-stats modifiers to the TotalStatModier property. RemoveItemStats subtracts the item's stat bonuses from the total stats and subtracts any sub-stats modifiers from the TotalStatModier property. 

In short, the EquipManager class manages the equipment items in a game and tracks their stats, allowing for easy equipping and unequipping of items and updating of total stats.
Code of file EquipManager:
﻿using System;
using System.Collections.Generic;
using UnityEngine;
[Serializable]
public class EquipManager : MonoBehaviour
{
    public enum EquipmentType { Weapon, Shield, Helmet, ChestArmor, LegArmor, Boots, Ring, Wrist }

    public Dictionary<EquipmentType, EquipableItem> equippedItems = new Dictionary<EquipmentType, EquipableItem>();

    // Properties to store the total stats from all equipped items.
    public StatsModifier TotalStatModier;
    public float TotalStrength = 0;
    public float TotalIntelligence= 0;
    public float TotalDexterity= 0;
    public float TotalEndurance= 0;
    public float TotalWisdom=0 ;
    // Add more stat properties as needed.

    public void EquipItem(EquipmentType type, EquipableItem item)
    {
        if (equippedItems.ContainsKey(type))
        {
            UnequipItem(type);
        }

        equippedItems[type] = item;
        ApplyItemStats(item);
    }

    public void UnequipItem(EquipmentType type)
    {
        if (!equippedItems.ContainsKey(type)) return;

        EquipableItem item = equippedItems[type];
        RemoveItemStats(item);
        equippedItems.Remove(type);
    }

    private void ApplyItemStats(EquipableItem item)
    {
        TotalStrength += item.strengthBonus;
        TotalIntelligence += item.intelligenceBonus;
        TotalDexterity += item.dexterityBonus;
        TotalEndurance += item.enduranceBonus;
        TotalWisdom += item.wisdomBonus;

        TotalStatModier.Add(item.subStatsModifier);

        // Add more stat effects as needed.
    }

    private void RemoveItemStats(EquipableItem item)
    {
        TotalStrength -= item.strengthBonus;
        TotalIntelligence -= item.intelligenceBonus;
        TotalDexterity -= item.dexterityBonus;
        TotalEndurance -= item.enduranceBonus;
        TotalWisdom -= item.wisdomBonus;

        TotalStatModier.Sub(item.subStatsModifier);

        // Remove more stat effects as needed.
    }

    internal void SetEquipManager(EquipManager equipManager)
    {
        equippedItems = equipManager.equippedItems;
        TotalStatModier = equipManager.TotalStatModier;
        TotalStrength = equipManager.TotalStrength;
        TotalIntelligence = equipManager.TotalIntelligence;
        TotalDexterity = equipManager.TotalDexterity;
        TotalEndurance = equipManager.TotalEndurance;
        TotalWisdom = equipManager.TotalWisdom;
        

    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\EquipManager.cs
Filename: EquipManager.cs

Syntax Tree:
- class EquipManager
    - public enum EquipmentType
        - Weapon
        - Shield
        - Helmet
        - ChestArmor
        - LegArmor
        - Boots
        - Ring
        - Wrist
    - public Dictionary<EquipmentType, EquipableItem> equippedItems
    - public StatsModifier TotalStatModier
    - public float TotalStrength
    - public float TotalIntelligence
    - public float TotalDexterity
    - public float TotalEndurance
    - public float TotalWisdom
    - public void EquipItem(EquipmentType type, EquipableItem item)
        - if (equippedItems.ContainsKey(type))
            - UnequipItem(type)
        - equippedItems[type] = item
        - ApplyItemStats(item)
    - public void UnequipItem(EquipmentType type)
        - if (!equippedItems.ContainsKey(type)) return
        - EquipableItem item = equippedItems[type]
        - RemoveItemStats(item)
        - equippedItems.Remove(type)
    - private void ApplyItemStats(EquipableItem item)
        - TotalStrength += item.strengthBonus
        - TotalIntelligence += item.intelligenceBonus
        - TotalDexterity += item.dexterityBonus
        - TotalEndurance += item.enduranceBonus
        - TotalWisdom += item.wisdomBonus
        - TotalStatModier.Add(item.subStatsModifier)
    - private void RemoveItemStats(EquipableItem item)
        - TotalStrength -= item.strengthBonus
        - TotalIntelligence -= item.intelligenceBonus
        - TotalDexterity -= item.dexterityBonus
        - TotalEndurance -= item.enduranceBonus
        - TotalWisdom -= item.wisdomBonus
        - TotalStatModier.Sub(item.subStatsModifier)
    - internal void SetEquipManager(EquipManager equipManager)
        - equippedItems = equipManager.equippedItems
        - TotalStatModier = equipManager.TotalStatModier
        - TotalStrength = equipManager.TotalStrength
        - TotalIntelligence = equipManager.TotalIntelligence
        - TotalDexterity = equipManager.TotalDexterity
        - TotalEndurance = equipManager.TotalEndurance
        - TotalWisdom = equipManager.TotalWisdom

- ExperienceSystem at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ExperienceSystem.cs:
Summery of ExperienceSystem:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ExperienceSystem.cs
The file "ExperienceSystem.cs" contains a class that implements a system for tracking and leveling up player experience in a game. The class has three public properties: "CurrentXP," which tracks the current amount of experience the player has; "Level," which tracks the current level of the player; and "XpToNextLevel," which tracks the amount of experience required to reach the next level.

The class also has two events: "LevelUpEvent," which is triggered when the player levels up; and "ExperienceGained," which is triggered whenever the player gains experience. 

In the constructor, "CurrentXP" is initialized to 0, "Level" is initialized to 1, and "UpdateXpToNextLevel()" is called to set the initial value of "XpToNextLevel."

The public method "AddExperience(int amount)" allows for the addition of experience to the player's total. Whenever experience is gained, the "ExperienceGained" event is triggered. If the player has gained enough experience to reach the next level, the "LevelUp()" method is called.

The private method "LevelUp()" increases the player's level by 1, updates the value of "XpToNextLevel," and triggers the "LevelUpEvent." 

The private method "UpdateXpToNextLevel()" sets the current value of "XpToNextLevel" to the result of calling the private method "CalculateXpForLevel(int level)."

The private method "CalculateXpForLevel(int level)" calculates the amount of experience needed to reach a certain level according to custom logic included by the developer. In this implementation, the formula used is to square the level and multiply by 100.

Overall, the class provides a simple and flexible way to track and level up player experience in a game with the ability for developers to customize the experience required for each level.
Code of file ExperienceSystem:
﻿using System;

public class ExperienceSystem
{
    public int CurrentXP { get; private set; }
    public int Level { get; private set; }
    public int XpToNextLevel { get; private set; }

    public event Action LevelUpEvent;
    public event Action<int> ExperienceGained;

    public ExperienceSystem()
    {
        CurrentXP = 0;
        Level = 1;
        UpdateXpToNextLevel();
    }

    public void AddExperience(int amount)
    {
        CurrentXP += amount;
        ExperienceGained?.Invoke(amount);

        while (CurrentXP >= XpToNextLevel)
        {
            CurrentXP -= XpToNextLevel;
            LevelUp();
        }
    }

    private void LevelUp()
    {
        Level++;
        UpdateXpToNextLevel();
        LevelUpEvent?.Invoke();
    }

    private void UpdateXpToNextLevel()
    {
        XpToNextLevel = CalculateXpForLevel(Level);
    }

    private int CalculateXpForLevel(int level)
    {
        // Implement your custom XP calculation logic here
        return (int)Math.Floor(Math.Pow(level, 2) * 100);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ExperienceSystem.cs
File: ExperienceSystem.cs

Class: ExperienceSystem

- CurrentXP: int
- Level: int
- XpToNextLevel: int
- LevelUpEvent: Action
- ExperienceGained: Action<int>

- ExperienceSystem()
- AddExperience(int amount)
- LevelUp()
- UpdateXpToNextLevel()
- CalculateXpForLevel(int level)

- HealthController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\HealthController.cs:
Summery of HealthController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\HealthController.cs
The HealthController.cs file is responsible for controlling the health of an object in the game. It contains several variables, including Name, maxHealth, currentHealth, damageTextPrefab, and questSystem. 

The Start function sets the currentHealth to equal the maxHealth value and finds the damageTextPrefab in the scene. 

The TakeDamage function reduces the currentHealth by the damage value and calls the ShowDamageNumbers function to display the damage text on the screen. If the currentHealth is less than or equal to zero, the function checks if the object that caused the damage has a QuestSystem component attached and updates the quest objective if it does. The Die function is called to implement any death behavior needed, such as playing a death animation or dropping loot, and ultimately destroys the game object. 

The ShowDamageNumbers function checks if the WorldSpaceCanvasController instance is present in the scene, and if it is, it spawns a damage number text at the current object's position with a small offset in the upward direction.
Code of file HealthController:
using UnityEngine;

public class HealthController : MonoBehaviour
{
    private CharacterStats characterStats;
    public string Name;
    public float maxHealth;
    public float currentHealth;
    public GameObject damageTextPrefab;
    private QuestSystem questSystem;

    void UpdateMaxHealth()
    {
        maxHealth = characterStats.maxLife;
    }
    public void updateHealth()
    {
        currentHealth = maxHealth;
    }
    private void Start()
    {
        characterStats = GetComponent<CharacterStats>();
        characterStats.StatsChanged+=UpdateMaxHealth;
        UpdateMaxHealth();
        currentHealth = maxHealth;
        damageTextPrefab = GameObject.Find("DamageTextTemplate");
        

    }

    public void TakeDamage(float damage,GameObject from)
    {
        currentHealth -= damage;
        ShowDamageNumbers(damage);
        if (currentHealth <= 0)
        {
            if(from.GetComponent<QuestSystem>() != null)
            {
                from.GetComponent<QuestSystem>().UpdateQuestObjective("kill:"+Name);
            }
            Die();
        }
    }

    private void Die()
    {
        // Implement death behavior, such as playing death animation, dropping loot, etc.

        Destroy(gameObject);
    }
    public void ShowDamageNumbers(float damage)
    {
        if (WorldSpaceCanvasController.Instance == null)
        {
            Debug.LogError("WorldSpaceCanvasController instance is not present in the scene.");
            return;
        }

        WorldSpaceCanvasController.Instance.SpawnDamageNumber(damage, transform.position + Vector3.up * 2f);
    }

}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\HealthController.cs
HealthController:
- private characterStats
- public Name:string
- public maxHealth:float
- public currentHealth:float
- private damageTextPrefab:GameObject
- private questSystem

- UpdateMaxHealth()
  - maxHealth = characterStats.maxLife

- updateHealth()
  - currentHealth = maxHealth

- Start()
  - characterStats = GetComponent<CharacterStats>()
  - characterStats.StatsChanged+=UpdateMaxHealth
  - UpdateMaxHealth()
  - currentHealth = maxHealth
  - damageTextPrefab = GameObject.Find("DamageTextTemplate")

- TakeDamage(damage:float, from:GameObject)
  - currentHealth -= damage
  - ShowDamageNumbers(damage)
  - if currentHealth <= 0
    - if from.GetComponent<QuestSystem>() != null
      - from.GetComponent<QuestSystem>().UpdateQuestObjective("kill:"+Name)
    - Die()

- Die()
  - Destroy(gameObject)

- ShowDamageNumbers(damage:float)
  - if WorldSpaceCanvasController.Instance == null
    - Debug.LogError("WorldSpaceCanvasController instance is not present in the scene.")
    - return
  - WorldSpaceCanvasController.Instance.SpawnDamageNumber(damage, transform.position + Vector3.up * 2f)

- HotkeyController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\HotkeyController.cs:
Summery of HotkeyController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\HotkeyController.cs
The file "HotkeyController.cs" contains a script in Unity that handles the hotkeys for a player and units. It includes a list of hotkeys, a combat controller, and a dictionary that maps the hotkeys to their respective abilities. 

In the Start function, the script initializes the hotkeys list with a capacity of nine, and populates the dictionary with the corresponding hotkeys. Additionally, it assigns a test ability to the first hotkey in the list. 

In the Update function, the script calls the HandleHotkey function which checks for a key press from the player. If a hotkey is mapped to the pressed key and is assigned an ability, the script performs the ability using the combat controller. 

The Hotkey class defines a hotkey object that contains an ability.
Code of file HotkeyController:
using UnityEngine;
using System.Collections.Generic;
using System;

public class HotkeyController : MonoBehaviour{
    
    public List<Hotkey> hotkeys;
    private CharacterCombatController combatController;
    public Dictionary<KeyCode, Hotkey> hotkeyMapping;
    public void Update()
    {
        HandleHotkey();
    }
    public void Start()
    {
        combatController = GetComponent<CharacterCombatController>();
        hotkeys = new List<Hotkey>();
            for (int i = 0; i < 9; i++)
            {
                hotkeys.Add(new Hotkey());
            }

        hotkeyMapping = new Dictionary<KeyCode, Hotkey>
        {
            { KeyCode.Alpha1, hotkeys[0] },
            { KeyCode.Alpha2, hotkeys[1] },
            { KeyCode.Alpha3, hotkeys[2] },
            { KeyCode.Alpha4, hotkeys[3] },
            { KeyCode.Alpha5, hotkeys[4] },
            { KeyCode.Alpha6, hotkeys[5] },
            { KeyCode.Alpha7, hotkeys[6] },
            { KeyCode.Alpha8, hotkeys[7] },
            { KeyCode.E, hotkeys[8] }
        };

        Hotkey hotkeyTest = new Hotkey();
        hotkeyTest.ability = combatController.abilityController.learnedAbilitys[0];
        hotkeys[0].ability = combatController.abilityController.learnedAbilitys[0];
    }
    private void HandleHotkey()
    {
        foreach (KeyValuePair<KeyCode, Hotkey> entry in hotkeyMapping)
        {
            if (Input.GetKeyDown(entry.Key))
            {
                Hotkey hotkey = entry.Value;
                if (hotkey.ability != null)
                {
                    combatController.PerformAbility(hotkey.ability, this.gameObject);
                }
                // else if (hotkey.item != null)
                {
                    // UseItem(hotkey.item);
                }
            }
        }
    }

internal void SwapHotkeys(int hotkeyIndex1, int hotkeyIndex2)
{
    Hotkey tempHotkey = hotkeys[hotkeyIndex1];
    hotkeys[hotkeyIndex1] = hotkeys[hotkeyIndex2];
    hotkeys[hotkeyIndex2] = tempHotkey;
}

internal void AssignAbilityToHotkey(int hotkeyIndex, Ability assignedAbility)
{
    hotkeys[hotkeyIndex].ability = assignedAbility;
    hotkeys[hotkeyIndex].item = null;
}

internal void AssignItemToHotkey(int hotkeyIndex, Item assignedItem)
{
    hotkeys[hotkeyIndex].item = assignedItem;
    hotkeys[hotkeyIndex].ability = null;
}

}
public class Hotkey
{
    public Ability ability;
    public Item item;
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\HotkeyController.cs
HotkeyController:
- public List<Hotkey> hotkeys
- private CharacterCombatController combatController
- public Dictionary<KeyCode, Hotkey> hotkeyMapping
- public void Update()
    - HandleHotkey()
- public void Start()
    - combatController = GetComponent<CharacterCombatController>()
    - hotkeys = new List<Hotkey>()
        - for (int i = 0; i < 9; i++)
            - hotkeys.Add(new Hotkey())
    - hotkeyMapping = new Dictionary<KeyCode, Hotkey> { ... }
    - Hotkey hotkeyTest = new Hotkey()
    - hotkeyTest.ability = combatController.abilityController.learnedAbilitys[0]
    - hotkeys[0].ability = combatController.abilityController.learnedAbilitys[0]
- private void HandleHotkey()
    - foreach (KeyValuePair<KeyCode, Hotkey> entry in hotkeyMapping)
        - if (Input.GetKeyDown(entry.Key))
            - Hotkey hotkey = entry.Value
            - if (hotkey.ability != null)
                - combatController.PerformAbility(hotkey.ability, this.gameObject)
- internal void SwapHotkeys(int hotkeyIndex1, int hotkeyIndex2)
    - Hotkey tempHotkey = hotkeys[hotkeyIndex1]
    - hotkeys[hotkeyIndex1] = hotkeys[hotkeyIndex2]
    - hotkeys[hotkeyIndex2] = tempHotkey
- internal void AssignAbilityToHotkey(int hotkeyIndex, Ability assignedAbility)
    - hotkeys[hotkeyIndex].ability = assignedAbility
    - hotkeys[hotkeyIndex].item = null
- internal void AssignItemToHotkey(int hotkeyIndex, Item assignedItem)
    - hotkeys[hotkeyIndex].item = assignedItem
    - hotkeys[hotkeyIndex].ability = null
Hotkey:
- public Ability ability
- public Item item

- IInteractable at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\IInteractable.cs:
Summery of IInteractable:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\IInteractable.cs
The file called "IInteractable.cs" contains an interface called IInteractable. This interface requires any implementing class to have a method called "Interact()" which does not return any value. This interface is used to ensure any unit or player character in the game that needs to be interacted with by the player, can be interacted with using the same method name "Interact()". The logic behind the "Interact()" method will be defined in each implementing class.
Code of file IInteractable:
using UnityEngine;

public interface IInteractable
{
    void Interact(Transform interacter);
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\IInteractable.cs
IInteractable: 
- Interface
- Method: Interact(Transform interacter)

- Inventory at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\Inventory.cs:
Summery of Inventory:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\Inventory.cs
The file being implemented here is called "Inventory.cs" and it is located in the "PlayerAndUnitsComponent" folder of the Unity project. This file contains a class called "Inventory" which inherits from the MonoBehaviour class. The class has three public fields: a List of "Item" objects, and a QuestSystem object. 

The Start() method initializes the questSystem field by getting the QuestSystem component that is attached to the same GameObject as the Inventory component. 

The AddItem() method adds the given item to the inventory, and if the questSystem object is not null, it logs a message and calls the UpdateQuestObjective() method on the questSystem object to update the quest objective with the item's name. 

The RemoveItem() method removes the given item from the inventory. 

The HasItem() method returns true if the inventory contains the given item. 

Overall, this class provides basic functionality for managing an inventory of items in a game, and also integrates with a quest system to update quest objectives when items are collected.
Code of file Inventory:
﻿using System.Collections.Generic;
using UnityEngine;

public class Inventory : MonoBehaviour
{
    public List<Item> items;
    public QuestSystem questSystem;
      private void Start()
    {
        questSystem = GetComponent<QuestSystem>();

    }

    public void AddItem(Item item)
    {
        items.Add(item);
        if(questSystem!=null)  // Check if questSystem is not null
        {
            Debug.Log("collect:"+item.name);
            questSystem.UpdateQuestObjective("collect:"+item.name); // Call UpdateQuestObjective method with item id
        }
    }

    public void RemoveItem(Item item)
    {
        items.Remove(item);
    }

    public bool HasItem(Item item)
    {
        return items.Contains(item);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\Inventory.cs
Inventory:
- items: List<Item>
- questSystem: QuestSystem

Start():
- questSystem = GetComponent<QuestSystem>()

AddItem(item: Item):
- items.Add(item)
- if questSystem != null:
    - Debug.Log("collect:" + item.name)
    - questSystem.UpdateQuestObjective("collect:" + item.name)

RemoveItem(item: Item):
- items.Remove(item)

HasItem(item: Item):
- return items.Contains(item)

- isStunnableController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\isStunnableController.cs:
Summery of isStunnableController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\isStunnableController.cs
The file "isStunnableController.cs" within the "PlayerAndUnitsComponent" folder is responsible for controlling the stunnable behavior of game objects. The script implements the "IStunnable" interface, which includes three properties: "stunned", "timeAtStunStart" and "stunDuration". The "stunned" property indicates whether the game object is currently stunned or not, while "timeAtStunStart" and "stunDuration" properties represent the start time and duration of the stun effect.

The script provides a "Stun" function, which sets the "stunned" property to true and saves the current time as the starting time for the stun effect. It also saves the input "duration" parameter as the duration of the stun effect. The "isStunned" function returns the current state of the "stunned" property. If the time elapsed since the start of the stun effect is greater than the "stunDuration" property, then the "stunned" property is set to false, indicating the end of the stun effect.

In summary, the "isStunnableController.cs" script allows game objects to be stunned and then recover from the stun effect after a set duration of time.
Code of file isStunnableController:
using UnityEngine;
public class isStunnableController : MonoBehaviour,IStunnable{

    public bool stunned;

    float timeAtStunStart;
    float stunDuration;

    bool IStunnable.stunned { get => stunned ;}

    float IStunnable.timeAtStunStart => timeAtStunStart;

    float IStunnable.stunDuration => stunDuration;

    VisualEffectController visualEffectController;

    private void Start()
    {
        visualEffectController = GetComponent<VisualEffectController>();
    }
    public void Stun(float duration){
        stunned = true;
        timeAtStunStart = Time.time;
        stunDuration = duration;
        visualEffectController.SpawnEffect("Stun",duration);

    }
    public bool isStunned(){
        
            if(Time.time - timeAtStunStart >= stunDuration){
                stunned = false;
            }
        return stunned;
        
    }
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\isStunnableController.cs
Class: isStunnableController

- bool stunned
- float timeAtStunStart
- float stunDuration
- VisualEffectController visualEffectController
- void Start()
- void Stun(float duration)
- bool isStunned()

IStunnable
- bool stunned
- float timeAtStunStart
- float stunDuration

- IStunnable at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\IStunnable.cs:
Summery of IStunnable:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\IStunnable.cs
The file name is IStunnable.cs and it is located in the directory Assets\Scripts\PlayerAndUnitsComponent. This file contains an interface called IStunnable that defines certain properties and methods related to the ability of a GameObject to be stunned.

The interface includes a bool property called stunned that indicates whether the GameObject is currently stunned or not. It also includes two float properties: timeAtStunStart, which represents the time at which the GameObject was last stunned, and stunDuration, which represents the duration of the stun.

In addition, the interface defines a method called Stun, which takes in a float parameter called duration and stuns the GameObject for that amount of time. Finally, the interface includes a method called isStunned, which returns a bool indicating whether the GameObject is currently stunned.

Overall, IStunnable.cs provides a flexible and extensible framework for implementing stuns in Unity projects. Developers can easily add the IStunnable interface to any GameObject in their game and customize its behavior as needed, providing a powerful tool for creating compelling gameplay experiences.
Code of file IStunnable:
//Interface isStunnable if GameObject can be stunned,contain bool isStunned
// Path: Assets\Scripts\PlayerAndUnitsComponent\IStunnable.cs
using UnityEngine;
public interface IStunnable
{
    bool stunned { get; }

   
    float timeAtStunStart{ get; }
    float stunDuration{ get ;}


    void Stun(float duration);
    public bool isStunned();
}


Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\IStunnable.cs
IStunnable.cs:
- interface IStunnable
  - bool stunned
  - float timeAtStunStart
  - float stunDuration
  - void Stun(float duration)
  - bool isStunned()

- ManaController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ManaController.cs:
Summery of ManaController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ManaController.cs
The file "ManaController.cs" is a script that is used to manage the mana of a character in a game. It has a public float variable for the maximum mana and another for the current mana. It also has a private variable called "characterStats" of type CharacterStats.

In the Start() function, the script gets a reference to the CharacterStats component of the game object and subscribes to the "StatsChanged" event, which calls the "updateMaxMana" function. The currentMana is then set to the maxMana value.

The "updateMaxMana" function updates the value of maxMana when the characterStats component value changes.

The "UseMana" function is used to subtract the manaCost value from the currentMana if the character has sufficient mana. Equality of manaCost and currentMana is checked by the "HasSufficientMana" function.

Finally, the "RegenerateMana" function is used to increase the currentMana by the manaAmount value, and caps the currentMana value to the maxMana value.

Overall, the ManaController script is used to manage the mana in the game for a specific character and provides functions to use and regenerate the mana.
Code of file ManaController:
using UnityEngine;

public class ManaController : MonoBehaviour
{
    public float maxMana;
    public float currentMana;
    private CharacterStats characterStats;

    private void Start()
    {
        characterStats = GetComponent<CharacterStats>();
        characterStats.StatsChanged += updateMaxMana;
        
        currentMana = maxMana;

    }
    private void updateMaxMana()
    {
     maxMana = characterStats.maxMana;
    }
    public void updateMana()
    {
        currentMana = maxMana;
    }
    public void UseMana(float manaCost)
    {
        if (HasSufficientMana(manaCost))
        {
            currentMana -= manaCost;
        }
    }

    public bool HasSufficientMana(float manaCost)
    {
        return currentMana >= manaCost;
    }

    public void RegenerateMana(float manaAmount)
    {
        currentMana += manaAmount;
        if (currentMana > maxMana)
        {
            currentMana = maxMana;
        }
    }


}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\ManaController.cs
ManaController:
 -maxMana: float
 -currentMana: float
 -characterStats: CharacterStats
 +Start()
 +updateMaxMana()
 +updateMana()
 +UseMana(manaCost: float)
 +HasSufficientMana(manaCost: float): bool
 +RegenerateMana(manaAmount: float)

- MovementController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\MovementController.cs:
Summery of MovementController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\MovementController.cs
The file "MovementController.cs" is responsible for controlling the movement of a player or unit in the game. It utilizes the NavMeshAgent component to navigate a NavMesh surface towards a given target position. The stopping distance for the unit can be set using the "stoppingDistance" variable. 

The script initializes the NavMeshAgent and IStunnable components in the "Start()" function. The IStunnable component is used to check if the unit is currently stunned. If it is, the NavMeshAgent is stopped. If the unit is not stunned, the NavMeshAgent will resume moving towards the target position in the "Update()" function. 

Overall, the script ensures that the unit moves towards the target position while accounting for any stuns that may occur during the game.
Code of file MovementController:
using UnityEngine;
using UnityEngine.AI;

public class MovementController : MonoBehaviour
{
    IStunnable stunnable;
    public Transform target;
    public float stoppingDistance = 2f;

    private NavMeshAgent agent;

    private void Start()
    {
        agent = GetComponent<NavMeshAgent>();
        stunnable = GetComponent<IStunnable>();
        Debug.Log("stunnable: " + stunnable);
    }

    private void Update()
    {
        if (target != null)
        {
            agent.SetDestination(target.position);
            agent.stoppingDistance = stoppingDistance;
        }
        if(stunnable != null && stunnable.isStunned())
        {
            agent.isStopped = true;
        }
        else
        {
            agent.isStopped = false;
        }
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\MovementController.cs
MovementController:
- stunnable: IStunnable
- target: Transform
- stoppingDistance: float
- agent: NavMeshAgent

Start():
- agent = GetComponent<NavMeshAgent>()
- stunnable = GetComponent<IStunnable>()
- Debug.Log("stunnable: " + stunnable)

Update():
- if target is not null:
  - agent.SetDestination(target.position)
  - agent.stoppingDistance = stoppingDistance
- if stunnable is not null and stunnable.isStunned():
  - agent.isStopped = true
- else:
  - agent.isStopped = false

- PlayerController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\PlayerController.cs:
Summery of PlayerController:
File Name: PlayerController.cs

The PlayerController class in Unity is responsible for controlling the character movement, camera, jumping, and handling hotkeys for abilities and items. 

The class contains the following components:
- BuffSystem: A system for managing buffs
- ExperienceSystem: A system for managing experience points
- CharacterStats: A component for managing character stats such as strength, intelligence, and endurance
- CharacterCombatController: A controller for managing character combat 
- SkillController: A controller for managing player's skills
- SkillTree: A component for managing the skill tree
- IStunnable: An interface for checking whether the character is stunned

The class also contains the following public variables:
- moveSpeed: A float value for character movement speed
- rotationSpeed: A float value for character rotation speed
- jumpForce: A float value for the force applied for jumping
- groundLayer: A layer mask for detecting ground

Additionally, the class has private variables for managing character movement, camera rotation, and hotkeys. It also uses the Animator component and a Rigidbody for character movement.

The Start() function is responsible for initializing the various components and hotkeys. It also subscribes to the OnSkillUnlocked event in the SkillController component.

The Update() function handles character movement, jumping, camera rotation, and hotkeys. It calls the HandleMovement(), HandleJump(), HandleCamera(), and HandleHotkey() functions respectively.

The HandleHotkey() function is responsible for checking and performing abilities or items assigned to hotkeys using the KeyCode value of each hotkey.

The HandleMovement() function retrieves input values for character movement and sets the character's rotation according to the input direction.

The HandleJump() function checks and applies force for jumping if the character is on the ground.

The HandleCamera() function retrieves input values for camera rotation and sets the camera position and rotation accordingly.

The FixedUpdate() function is used for applying motion to the Rigidbody component for character movement.

The class also contains a method for unlocking and unlearning skill nodes in the SkillTree component.
Code of file PlayerController:
using System.Collections.Generic;
using UnityEngine;



public class PlayerController : MonoBehaviour
{
    [Header("Controller")]
    BuffSystem buffSystem;
    ExperienceSystem experienceSystem;
    CharacterStats characterStats;
    CharacterCombatController combatController;
    SkillController skillController;
    SkillTree skillTree;
    IStunnable stunnable;
    HotkeyController hotkeyController;
    CanGrabController canGrabController;
    TargetingSystem targetingSystem;
  


    public Ability Ability1;



    [Header("Movement")]
    public float moveSpeed = 5f;
    public float rotationSpeed = 720f;
    public float jumpForce = 1f;
    public LayerMask groundLayer;

    [Header("Camera")]
    public Transform cameraTarget;
    public float cameraDistance = 5f;
    public float cameraHeight = 2f;
    public float cameraRotationSpeed = 2f;


    private Rigidbody rb;
    private Animator animator;
    private Vector3 moveDirection;
    private bool isGrounded;
    private Transform mainCamera;
    private float cameraRotationY;


    private void Start()
    {
        canGrabController = GetComponent<CanGrabController>();
        combatController = GetComponent<CharacterCombatController>();
        characterStats = GetComponent<CharacterStats>();
        skillController = GetComponent<SkillController>();
        targetingSystem = GetComponent<TargetingSystem>();

        //EDITOR CODE
        skillController.skillTree.resetAllNodes();

        rb = GetComponent<Rigidbody>();
        animator = GetComponent<Animator>();
        mainCamera = Camera.main.transform;
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;



        skillController.OnSkillUnlocked += UpdateToSkillEvents;
        stunnable = GetComponent<IStunnable>();
    }


    private void Update()
    {
        HandleMovement();
        HandleJump();
        HandleCamera();
        HandleActions();
    }
    private void UpdateToSkillEvents(SkillNode node)
    {
        characterStats.UpdateSubStats();
    }
    GameObject target;
    public void HandleActions(){

        if(Input.GetKeyDown(KeyCode.E)){
            
            target = targetingSystem.GetTarget();
            if(target == null){return;}

                 if(target.GetComponent<IInteractable>() != null){
                            if(Vector3.Distance(target.transform.position,transform.position) < 10f)
                            {
                     target.GetComponent<IInteractable>().Interact(transform);
                         }
        }
    }
    }

    private void HandleMovement()
    {
        if(stunnable != null && stunnable.isStunned())
        {
            return;
        }
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");

        moveDirection = mainCamera.forward * vertical + mainCamera.right * horizontal;
        moveDirection.y = 0f;
        moveDirection.Normalize();

        if (moveDirection != Vector3.zero)
        {
            Quaternion targetRotation = Quaternion.LookRotation(moveDirection);
            transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);

        }

        animator.SetFloat("Speed", moveDirection.magnitude);
        rb.MovePosition(rb.position + moveDirection * moveSpeed * Time.deltaTime);
    }

    private void HandleJump()
    {
        if(stunnable != null && stunnable.isStunned())
        {
            return;
        }
        isGrounded = Physics.Raycast(transform.position, Vector3.down, 0.4f, groundLayer);

        if (Input.GetButtonDown("Jump") && isGrounded)
        {
            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }

        // animator.SetBool("IsGrounded", isGrounded);
    }

    private void HandleCamera()
    {
        float mouseX = Input.GetAxis("Mouse X");
        float mouseY = Input.GetAxis("Mouse Y");

        cameraRotationY -= mouseY * cameraRotationSpeed;
        cameraRotationY = Mathf.Clamp(cameraRotationY, -80f, 80f);

        mainCamera.RotateAround(cameraTarget.position, Vector3.up, mouseX * cameraRotationSpeed);
        mainCamera.localRotation = Quaternion.Euler(cameraRotationY, mainCamera.localEulerAngles.y, 0f);

        Vector3 cameraOffset = new Vector3(0f, cameraHeight, -cameraDistance);
        Vector3 targetPosition = cameraTarget.position + mainCamera.TransformDirection(cameraOffset);

        mainCamera.position = Vector3.Lerp(mainCamera.position, targetPosition, Time.deltaTime * rotationSpeed);
        mainCamera.LookAt(cameraTarget);
    }

    public void faceIndirectionOfCamera()
    {
        transform.rotation = Quaternion.Euler(0f, mainCamera.localEulerAngles.y, 0f);
    }
    public bool TryUnlockSkillNode(SkillNode skillNode)
    {
        if (skillNode == null)
        {
            Debug.LogWarning("Invalid skill node.");
            return false;
        }
        if (skillNode.isUnlocked)
        {
            Debug.LogWarning("Already learned.");
            return false;
        }

        // Check if the character has enough skill points to unlock the node.
        if (skillController.availableSkillPoints < skillNode.skillPointCost)
        {
            Debug.LogWarning("Not enough skill points.");
            return false;
        }

        // Check if the required main stat meets the node's requirement.
        bool statRequirementsMet = true;
        for (int i = 0; i < skillNode.mainStatRequirement.Count; i++)
        {
            Archetype statName = skillNode.mainStatRequirement[i];
            int requiredValue = skillNode.mainStatValue[i];

            switch (statName)
            {
                case Archetype.Strength:
                    if (characterStats.strength < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Intelligence:
                    if (characterStats.intelligence < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Dexterity:
                    if (characterStats.dexterity < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Endurance:
                    if (characterStats.endurance < requiredValue) statRequirementsMet = false;
                    break;
                case Archetype.Wisdom:
                    if (characterStats.wisdom < requiredValue) statRequirementsMet = false;
                    break;
                default:
                    Debug.LogWarning("Invalid stat name in the skill node.");
                    break;
            }
        }

        if (!statRequirementsMet)
        {
            Debug.LogWarning("Main stat requirement not met.");
            return false;
        }

        // Check if the required prerequisite skill has been unlocked.
        if (skillNode.prerequisiteSkill != null && !skillNode.prerequisiteSkill.isUnlocked)
        {
            Debug.LogWarning("Prerequisite skill not unlocked.");
            return false;
        }

        // Check if the skill node is visible based on the fog of war mechanic.
        if (!skillController.skillTree.IsVisible(skillNode))
        {
            Debug.LogWarning("Skill node is not visible.");
            return false;
        }

        // Unlock the skill node.
        skillNode.isUnlocked = true;

        skillController.LearnSkill(skillNode);


        return true;
    }
    public bool TryUnLearnSkillNode(SkillNode skillNode)
    {
        if (skillNode.isUnlocked == false)
        {
            return false;
        }
        skillNode.isUnlocked = false;
        skillController.UnlearnSkill(skillNode);
        return true;
    }

}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\PlayerController.cs
PlayerController:
- buffSystem
- experienceSystem
- characterStats
- combatController
- skillController
- skillTree
- stunnable
- hotkeyController
- canGrabController
- targetingSystem
- Ability1
- moveSpeed
- rotationSpeed
- jumpForce
- groundLayer
- cameraTarget
- cameraDistance
- cameraHeight
- cameraRotationSpeed
- rb
- animator
- moveDirection
- isGrounded
- mainCamera
- cameraRotationY

Start():
- canGrabController = GetComponent(CanGrabController)
- combatController = GetComponent(CharacterCombatController)
- characterStats = GetComponent(CharacterStats)
- skillController = GetComponent(SkillController)
- targetingSystem = GetComponent(TargetingSystem)
- skillController.skillTree.resetAllNodes()
- rb = GetComponent(Rigidbody)
- animator = GetComponent(Animator)
- mainCamera = Camera.main.transform
- Cursor.lockState = CursorLockMode.Locked
- Cursor.visible = false
- skillController.OnSkillUnlocked += UpdateToSkillEvents
- stunnable = GetComponent(IStunnable)

Update():
- HandleMovement()
- HandleJump()
- HandleCamera()
- HandleActions()

UpdateToSkillEvents(SkillNode node):
- characterStats.UpdateSubStats()

HandleActions():
- target = targetingSystem.GetTarget()
- if target == null, return
- if target.GetComponent(IInteractable) != null:
  - if Vector3.Distance(target.transform.position,transform.position) < 10f:
    - target.GetComponent(IInteractable).Interact(transform)

HandleMovement():
- if stunnable != null and stunnable.isStunned(), return
- horizontal = Input.GetAxis("Horizontal")
- vertical = Input.GetAxis("Vertical")
- moveDirection = mainCamera.forward * vertical + mainCamera.right * horizontal
- moveDirection.y = 0f
- moveDirection.Normalize()
- if moveDirection != Vector3.zero:
  - targetRotation = Quaternion.LookRotation(moveDirection)
  - transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime)
- animator.SetFloat("Speed", moveDirection.magnitude)
- rb.MovePosition(rb.position + moveDirection * moveSpeed * Time.deltaTime)

HandleJump():
- if stunnable != null and stunnable.isStunned(), return
- isGrounded = Physics.Raycast(transform.position, Vector3.down, 0.4f, groundLayer)
- if Input.GetButtonDown("Jump") and isGrounded:
  - rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse)

HandleCamera():
- mouseX = Input.GetAxis("Mouse X")
- mouseY = Input.GetAxis("Mouse Y")
- cameraRotationY -= mouseY * cameraRotationSpeed
- cameraRotationY = Mathf.Clamp(cameraRotationY, -80f, 80f)
- mainCamera.RotateAround(cameraTarget.position, Vector3.up, mouseX * cameraRotationSpeed)
- mainCamera.localRotation = Quaternion.Euler(cameraRotationY, mainCamera.localEulerAngles.y, 0f)
- cameraOffset = new Vector3(0f, cameraHeight, -cameraDistance)
- targetPosition = cameraTarget.position + mainCamera.TransformDirection(cameraOffset)
- mainCamera.position = Vector3.Lerp(mainCamera.position, targetPosition, Time.deltaTime * rotationSpeed)
- mainCamera.LookAt(cameraTarget)

faceIndirectionOfCamera():
- transform.rotation = Quaternion.Euler(0f, mainCamera.localEulerAngles.y, 0f)

TryUnlockSkillNode(SkillNode skillNode):
- if skillNode == null, Debug.LogWarning("Invalid skill node."), return false
- if skillNode.isUnlocked, Debug.LogWarning("Already learned."), return false
- if skillController.availableSkillPoints < skillNode.skillPointCost, Debug.LogWarning("Not enough skill points."), return false
- statRequirementsMet = true
- for i = 0 to skillNode.mainStatRequirement.Count:
  - statName = skillNode.mainStatRequirement[i]
  - requiredValue = skillNode.mainStatValue[i]
  - if statName == Archetype.Strength:
    - if characterStats.strength < requiredValue, statRequirementsMet = false
  - elif statName == Archetype.Intelligence:
    - if characterStats.intelligence < requiredValue, statRequirementsMet = false
  - elif statName == Archetype.Dexterity:
    - if characterStats.dexterity < requiredValue, statRequirementsMet = false
  - elif statName == Archetype.Endurance:
    - if characterStats.endurance < requiredValue, statRequirementsMet = false
  - elif statName == Archetype.Wisdom:
    - if characterStats.wisdom < requiredValue, statRequirementsMet = false
  - else:
    - Debug.LogWarning("Invalid stat name in the skill node.")
- if not statRequirementsMet, Debug.LogWarning("Main stat requirement not met."), return false
- if skillNode.prerequisiteSkill != null and not skillNode.prerequisiteSkill.isUnlocked, Debug.LogWarning("Prerequisite skill not unlocked."), return false
- if not skillController.skillTree.IsVisible(skillNode), Debug.LogWarning("Skill node is not visible."), return false
- skillNode.isUnlocked = true
- skillController.LearnSkill(skillNode)
- return true

TryUnLearnSkillNode(SkillNode skillNode):
- if not skillNode.isUnlocked, return false
- skillNode.isUnlocked = false
- skillController.UnlearnSkill(skillNode)
- return true

- SkillController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\SkillController.cs:
Summery of SkillController:
File name: SkillController.cs

Summary: This class handles the management of skills for a character in the game. It contains a list of currently active skills, a skill tree, the character's available skill points, a modifier for the character's overall stats, and two events for when a skill is learned or unlearned. 

The LearnSkill method adds a new skill to the character's active skills list, applies the skill's effects to the character's stats, subtracts the skill's point cost from the available skill points, and invokes the OnSkillUnlocked event.

The UnlearnSkill method removes a skill from the character's active skills list, removes the skill's effects from the character's stats, adds the skill's point cost back to the available skill points, and invokes the OnSkillUnlearnd event.

Overall, this class allows the player to manage their character's skills and progress through the game's skill tree.
Code of file SkillController:
﻿using System.Collections.Generic;
using UnityEngine;

class SkillController : MonoBehaviour
{
    public List<Skill> activeSkills;
    public SkillTree skillTree;
    public int availableSkillPoints;
    public StatsModifier totalStatsModier;
    public delegate void SkillEvent(SkillNode skillNode);
    public event SkillEvent OnSkillUnlocked;
    public event SkillEvent OnSkillUnlearnd;



    public void LearnSkill(SkillNode skillNode)
    {

        // Call event to update the UI, etc.

        activeSkills.Add(skillNode.skill);
        skillNode.skill.ApplySkill(this.gameObject.GetComponent<CharacterStats>());
        totalStatsModier.Add(skillNode.skill.statModifier);
        availableSkillPoints -= skillNode.skillPointCost;
        OnSkillUnlocked?.Invoke(skillNode);

    }
    public void UnlearnSkill(SkillNode skillNode)
    {
        if (activeSkills.Remove(skillNode.skill))
        {
            totalStatsModier.Sub(skillNode.skill.statModifier);
        }
        availableSkillPoints += skillNode.skillPointCost;
        skillNode.skill.RemoveSkill(this.gameObject.GetComponent<CharacterStats>());
        OnSkillUnlearnd?.Invoke(skillNode);
    }

}


Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\SkillController.cs
Class: SkillController

- activeSkills: List<Skill>
- skillTree: SkillTree
- availableSkillPoints: int
- totalStatsModier: StatsModifier
- OnSkillUnlocked: delegate void SkillEvent(SkillNode skillNode)
- OnSkillUnlearnd: delegate void SkillEvent(SkillNode skillNode)

+ LearnSkill(skillNode: SkillNode)
    - activeSkills.Add(skillNode.skill)
    - skillNode.skill.ApplySkill(getComponent(CharacterStats))
    - totalStatsModier.Add(skillNode.skill.statModifier)
    - availableSkillPoints -= skillNode.skillPointCost
    - OnSkillUnlocked?.Invoke(skillNode)

+ UnlearnSkill(skillNode: SkillNode)
    - if activeSkills.Remove(skillNode.skill)
        - totalStatsModier.Sub(skillNode.skill.statModifier)
    - availableSkillPoints += skillNode.skillPointCost
    - skillNode.skill.RemoveSkill(getComponent(CharacterStats))
    - OnSkillUnlearnd?.Invoke(skillNode)

- TargetingSystem at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\TargetingSystem.cs:
Summery of TargetingSystem:
File Name: TargetingSystem.cs

This class provides functionality for targeting game objects in the game world using the player camera and crosshair as the main tools for selecting targets. 

Public Variables:
- playerCamera: The camera used to target objects.
- targetLayerMask: The layer mask used to determine which objects can be targeted.
- currentTarget: The current target being selected.
- crosshair: The graphical representation of the target.
- maxTargetingDistance: The maximum distance at which targets can be selected.
- highlightMaterial: The material used to highlight the selected target.

Private Variables:
- lastTarget: The previously selected target.
- originalMaterial: The original material of the targeted object.
- outlineHighlightController: The object responsible for outlining the current target.

Methods:
- HandleCrosshairTargeting(): Handles targeting by raycasting from the player camera to the crosshair position.
- HandleMouseClickTargeting(): Handles targeting by raycasting from the player camera to the mouse click position.
- GetTarget(): Returns the current target.
- HighlightTarget(): Applies a highlight material to the selected target and outlines it using the outlineHighlightController object.
Code of file TargetingSystem:
﻿using UnityEngine;

public class TargetingSystem : MonoBehaviour
{
    public Camera playerCamera;
    public LayerMask targetLayerMask;
    public GameObject currentTarget;
    public GameObject crosshair;
    public float maxTargetingDistance = 100f;
    public Material highlightMaterial;
    private GameObject lastTarget;
    private Material originalMaterial;
    public OutlineHighlight outlineHighlightController;

    private void Update()
    {
        HandleCrosshairTargeting();
        HandleMouseClickTargeting();
        HighlightTarget();
    }
    private void Start()
    {

    }

    private void HandleCrosshairTargeting()
    {
        RaycastHit hit;
        Ray ray = playerCamera.ScreenPointToRay(crosshair.transform.position);

        if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask))
        {
            currentTarget = hit.collider.gameObject;
        }
        else
        {
            currentTarget = null;
        }
    }

    private void HandleMouseClickTargeting()
    {
        if (Input.GetMouseButtonDown(0))
        {
            RaycastHit hit;
            Ray ray = playerCamera.ScreenPointToRay(Input.mousePosition);

            if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask))
            {
                currentTarget = hit.collider.gameObject;
            }
        }
    }

    public GameObject GetTarget()
    {
        return currentTarget;
    }
    private void HighlightTarget()
    {
        if (currentTarget != null)
        {
            outlineHighlightController.target = currentTarget.transform;
            lastTarget = currentTarget;
        }
        else
        {
            outlineHighlightController.target = null;
        }
    }

}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\TargetingSystem.cs
TargetingSystem:
    - playerCamera: Camera
    - targetLayerMask: LayerMask
    - currentTarget: GameObject
    - crosshair: GameObject
    - maxTargetingDistance: float
    - highlightMaterial: Material
    - lastTarget: GameObject
    - originalMaterial: Material
    - outlineHighlightController: OutlineHighlight

    + Update()
    - HandleCrosshairTargeting()
    - HandleMouseClickTargeting()
    - HighlightTarget()
    + Start()
    + GetTarget(): GameObject

Note: This class represents a system for targeting game objects in the game world, based on player input and the position of the crosshair on the screen. It also provides functionality for highlighting and selecting the target, using an outline highlighting effect.

- VisualEffectController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\VisualEffectController.cs:
Summery of VisualEffectController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\VisualEffectController.cs
The file "VisualEffectController.cs" is a script written in C# for a Unity project. The purpose of this script is to control the visual effects used in the game for both players and units. The script includes an enumeration called "effectUnitPosition" which has two values: "overHead" and "underFeet". The class "VisualEffectController" is defined and inherits from Unity's "MonoBehaviour" class. 

The script includes several public and private variables. The public variables are "visualEffectManager" of type "VisualEffectManager" and "positionOverHead" and "positionUnderFeet" of type "Transform". The private variables are "goalTransform" of type "Transform" and "effectInstances" of type "List<(GameObject, float)>". 

The "SpawnEffect" method is defined which takes in a string "effectName", a float "effectDuration", and an enum "effectPosition". The method checks the "effectPosition" and sets the "goalTransform" to either "positionOverHead" or "positionUnderFeet" accordingly. The method then gets the effect prefab from the "visualEffectManager" and instantiates it as an "effectInstance". This instance is added to the "effectInstances" list along with a timestamp of when it should be destroyed. 

The "Update" method is also defined which is called every frame. This method iterates over the "effectInstances" list and checks if any of the instances should be destroyed based on their timestamp. If an effect instance should be destroyed, it is removed from the "effectInstances" list and then destroyed. 

Overall, the "VisualEffectController.cs" script handles the spawning and destruction of visual effects in the game. It keeps track of active effect instances and removes them when they are no longer needed.
Code of file VisualEffectController:
using System.Collections.Generic;
using UnityEngine;

public enum effectUnitPosition{
    overHead,
    underFeet,
}
public class VisualEffectController : MonoBehaviour
{
    public VisualEffectManager visualEffectManager;

    public Transform positionOverHead;
    public Transform positionUnderFeet;

    private Transform goalTransform;
    private List<(GameObject,float)> effectInstances = new List<(GameObject,float)>();
    public void SpawnEffect(string effectName, float effectDuration = 0, effectUnitPosition effectPosition = effectUnitPosition.overHead)
    {
        if(effectPosition == effectUnitPosition.overHead){
            goalTransform = positionOverHead;
        }
        if(effectPosition == effectUnitPosition.underFeet){
            goalTransform = positionUnderFeet;
        }

         GameObject effectPrefab = visualEffectManager.GetEffectPrefab(effectName);
        if (effectPrefab != null)
        {
            GameObject effectInstance = Instantiate(effectPrefab, Vector3.zero, Quaternion.identity, goalTransform);
            effectInstance.transform.localPosition = Vector3.zero;
            effectInstances.Add((effectInstance,Time.time+effectDuration));

        }
    }
    void Update(){
        for (int i = effectInstances.Count - 1; i >= 0; i--)
        {
            (GameObject, float) effectInstance = effectInstances[i];
            if (effectInstance.Item2 < Time.time)
            {
                Destroy(effectInstance.Item1);
                effectInstances.RemoveAt(i);
                Debug.Log("effect removed");
            }
        }
    }
    

}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\PlayerAndUnitsComponent\VisualEffectController.cs
Class: VisualEffectController

Fields:
- visualEffectManager
- positionOverHead
- positionUnderFeet
- goalTransform
- effectInstances

Methods:
- SpawnEffect(effectName, effectDuration, effectPosition)
- Update()

- GameEvent at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\GameEvent.cs:
Summery of GameEvent:
This code file is implementing a custom game event system using Unity's built-in event system. The class is called "GameEvent", and it inherits from the "UnityEvent" class, which allows the event to have parameters of a specific type (in this case, a string).

The "[System.Serializable]" attribute is used so that instances of this class can be serialized and saved in the Unity editor.

The generic parameter of the "UnityEvent" class is set to a string type, which means that any listeners to this event will receive a string parameter when the event is invoked.

The purpose of this implementation is to create a custom event system for a game that can trigger specific actions or events based on certain conditions. For example, a "GameOver" event could be defined, and any listeners to that event could respond by displaying a game over screen or playing a sound effect.

Overall, this class provides a simple, flexible way to create and use custom game events within a Unity project.
Code of file GameEvent:
using UnityEngine.Events;

[System.Serializable]
public class GameEvent : UnityEvent<string> { }

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\GameEvent.cs
File: GameEvent.cs

Class: GameEvent
  - [System.Serializable]
  - : UnityEvent<string>
    - UnityEvent
      - UnityEventBase
        - InvokableCallList
          - List<BaseInvokableCall>
        - PersistentCallGroup
          - List<PersistentCall>
      - Delegate[] m_InvokeArray


- KillObjective at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\KillObjective.cs:
Summery of KillObjective:
File Name: KillObjective.cs

This script defines a class called KillObjective, which is a subclass of QuestObjective. It contains three serialized fields: enemyId (string), targetKills (int), and currentKills (int) which represent the unique identifier of the enemy, the number of enemies to be killed, and the current number of enemies killed, respectively.

The KillObjective class has a constructor that takes in an id (string), description (string), enemyId (string), and targetKills (int) as parameters to initialize the instance variables.

The script also overrides three methods from the QuestObjective superclass: UpdateProgress(), GetObjectiveProgress(), and IsCompleted(). 

UpdateProgress() takes in a killedEnemyId (string) parameter and updates the currentKills count if the killedEnemyId matches the id of the enemy specified in enemyId. If the number of currentKills reaches the targetKills, then the status is marked as completed.

GetObjectiveProgress() returns a string that represents the current number of kills and the target number of kills.

IsCompleted() returns a boolean indicating whether the status of the objective is completed or not.

The script uses the Unity Debug.LogError() method to print out the current number of kills for debugging purposes. The script also explicitly uses the UnityEngine namespace.
Code of file KillObjective:
using UnityEngine;

public class KillObjective : QuestObjective
{
    [SerializeField]
    public string enemyId;
    [SerializeField]
    public int targetKills;
    [SerializeField]
    public int currentKills;

    public KillObjective(string id, string description, string enemyId, int targetKills)
    {
        this.id = id;
        this.description = description;
        this.enemyId = enemyId;
        this.targetKills = targetKills;
        this.currentKills = 0;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string killedEnemyId)
    {
        if (killedEnemyId == "kill:"+enemyId && status != ObjectiveStatus.Completed)
        {
            currentKills++;
            Debug.LogError("Current Kills: " + currentKills);
            if (currentKills >= targetKills)
            {
                status = ObjectiveStatus.Completed;
            }
        }
    }
    public override string GetObjectiveProgress()
    {
        return currentKills + "/" + targetKills;
    }

    public override bool IsCompleted()
    {
        return status == ObjectiveStatus.Completed;
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\KillObjective.cs
File: KillObjective.cs

Class: KillObjective : QuestObjective
- [SerializeField] enemyId : string
- [SerializeField] targetKills : int
- [SerializeField] currentKills : int

+ KillObjective(id : string, description : string, enemyId : string, targetKills : int)
- this.id = id
- this.description = description
- this.enemyId = enemyId
- this.targetKills = targetKills
- this.currentKills = 0
- this.status = ObjectiveStatus.Incomplete

+ UpdateProgress(killedEnemyId : string)
- if(killedEnemyId == "kill:"+enemyId && status != ObjectiveStatus.Completed)
    + currentKills++
    + Debug.LogError("Current Kills: " + currentKills)
    - if(currentKills >= targetKills)
        - status = ObjectiveStatus.completed

+ GetObjectiveProgress() : string
- return currentKills + "/" + targetKills

+ IsCompleted() : bool
- return status == ObjectiveStatus.Completed

- Quest at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\Quest.cs:
Summery of Quest:
File name: Quest.cs

Summary: The Quest class is a ScriptableObject that contains information about a quest such as its ID, title, description, objectives, rewards, and status. It has methods to add objectives and rewards, and to check and update objectives for completion. It also has a method to check if all objectives are complete and update the quest status accordingly.

Intern logic:
- The Quest class has public properties for its ID, title, description, objectives, rewards, and status.
- Upon creation, a Quest object is initialized with its ID, title, description, and lists for objectives and rewards.
- The CheckAndUpdateObjectives method loops through all objectives in the list and updates their progress if they are incomplete. If an objective is completed, it checks if all objectives are completed using the CheckQuestCompletion method.
- The CheckQuestCompletion method loops through all objectives and checks if any are not completed. If all objectives are completed, the quest status is updated to completed.

Note: The implementation is missing the definition for the QuestObjective and Reward classes/enums, which would contain information about objectives and rewards for the quest.
Code of file Quest:
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "Quest", menuName = "ScriptableObjects/Quest", order = 1)]
public class Quest : ScriptableObject
{
    public int id;
    public string title;
    public string description;
    public List<QuestObjective> objectives;
    public List<Reward> rewards;
    public QuestStatus status;

    public Quest(int id, string title, string description)
    {
        this.id = id;
        this.title = title;
        this.description = description;
        this.objectives = new List<QuestObjective>();
        this.rewards = new List<Reward>();
        this.status = QuestStatus.NotStarted;
    }

    public void AddObjective(QuestObjective objective)
    {
        objectives.Add(objective);
    }

    public void AddReward(Reward reward)
    {
        rewards.Add(reward);
    }

    // The missing CheckAndUpdateObjectives method
    public void CheckAndUpdateObjectives(string objectiveId)
    {
        foreach (QuestObjective objective in objectives)
        {
            if ( objective.status == ObjectiveStatus.Incomplete)
            {
                objective.UpdateProgress(objectiveId);
                if (objective.status == ObjectiveStatus.Completed)
                {
                    CheckQuestCompletion();
                }
                break;
            }
        }
    }

    private void CheckQuestCompletion()
    {
        bool allObjectivesComplete = true;
        foreach (QuestObjective objective in objectives)
        {
            if (objective.status != ObjectiveStatus.Completed)
            {
                allObjectivesComplete = false;
                break;
            }
        }

        if (allObjectivesComplete)
        {
            status = QuestStatus.Completed;
        }
    }
}
public enum QuestStatus { NotStarted, InProgress, Completed }
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\Quest.cs
Quest
- id: int
- title: string
- description: string
- objectives: List<QuestObjective>
- rewards: List<Reward>
- status: QuestStatus

+ Quest(id: int, title: string, description: string)
+ AddObjective(objective: QuestObjective): void
+ AddReward(reward: Reward): void
+ CheckAndUpdateObjectives(objectiveId: string): void
- CheckQuestCompletion(): void

QuestStatus
- NotStarted
- InProgress
- Completed

- QuestAction at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestAction.cs:
Summery of QuestAction:
The file name of this class is "QuestAction". It is a ScriptableObject and can be created in the Unity editor menu under the "QuestSystem/QuestAction" category. 

The purpose of this class is to hold a unique "actionId" string, which can be used to identify and trigger specific actions within a quest system. 

Since this is a ScriptableObject and not a MonoBehaviour, it cannot be attached to game objects directly. Instead, it can be instantiated and referenced by other scripts. 

Overall, this class is a simple data container with the sole responsibility of holding an action identifier.
Code of file QuestAction:
using UnityEngine;

[CreateAssetMenu(fileName = "QuestAction", menuName = "QuestSystem/QuestAction", order = 1)]
public class QuestAction : ScriptableObject
{
    public string actionId;
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestAction.cs
Class: QuestAction

- fileName: string = "QuestAction"
- menuName: string = "QuestSystem/QuestAction"
- order: int = 1
- extends: ScriptableObject
- actionId: string

- QuestGiver at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestGiver.cs:
Summery of QuestGiver:
Name of File: QuestGiver.cs

Summary: 

The QuestGiver class is a Unity MonoBehaviour that implements the IInteractable interface. It has two serialized fields quest and interactionIndicator which are a Quest object and a GameObject respectively. Additionally, it has private variables playerInRange, playerQuestSystem and uiManager. The playerInRange variable is used to keep track of whether the player is near the QuestGiver or not. The playerQuestSystem variable stores the QuestSystem Component of the player when the player enters the QuestGiver's collider. The uiManager variable is used to find the UIManager instance in the scene.

The QuestGiver has two main methods: Interact() and Update(). Interact() is called when the player interacts with the QuestGiver by pressing the E key. If the questUIPresenter Game Object is active in the hierarchy, hideQuestUiPresenter() method of uiManager instance is called to hide the Quest UI. Otherwise, showQuestUiPresenter(quest) method of uiManager instance is called to show the Quest UI of the quest. 

In the Update() method, if the player is in range and presses the E key, then Interact() method is called. 

Lastly, the QuestGiver class has two private methods: OnTriggerEnter() and OnTriggerExit() which are used to detect when the player enters or exits the QuestGiver's collider. If the player enters the collider, playerInRange is set to true and interactionIndicator is set to active. Additionally, the playerQuestSystem variable is assigned the QuestSystem Component of the player. If the player exits the collider, playerInRange is set to false and interactionIndicator is set to inactive.
Code of file QuestGiver:
using UnityEngine;

public class QuestGiver : MonoBehaviour, IInteractable
{
    [SerializeField] private Quest quest;
 
    [SerializeField] private GameObject interactionIndicator;

    private bool playerInRange = false;
    private QuestSystem playerQuestSystem;
    private GameObject Interacts;
    private UIManager uiManager;
    public void Start(){
        uiManager = FindObjectOfType<UIManager>();
    }

    void Update()
    {
        if (playerInRange && Input.GetKeyDown(KeyCode.E))
        {
            Interact(Interacts.transform);
        }
    }
    public void Interact(Transform interactFrom)
    {
        if(uiManager.questUIPresenter.gameObject.activeInHierarchy ){
            uiManager.hideQuestUiPresenter();
        }
        else{
            uiManager.showQuestUiPresenter(quest);
        }
        
    }

    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = true;
            Interacts = other.gameObject;
            interactionIndicator.SetActive(true);
            playerQuestSystem = other.GetComponent<QuestSystem>();
        }
    }

    void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            playerInRange = false;
            interactionIndicator.SetActive(false);
           
        }
    }


}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestGiver.cs
Class: QuestGiver

- Quest quest
- GameObject interactionIndicator
- bool playerInRange
- QuestSystem playerQuestSystem
- GameObject Interacts
- UIManager uiManager

Start()
- uiManager = FindObjectOfType<UIManager>()

Update()
- if (playerInRange && Input.GetKeyDown(KeyCode.E))
- Interact(Interacts.transform)

Interact(Transform interactFrom)
- if(uiManager.questUIPresenter.gameObject.activeInHierarchy)
- uiManager.hideQuestUiPresenter()
- else
- uiManager.showQuestUiPresenter(quest)

OnTriggerEnter(Collider other)
- if (other.CompareTag("Player"))
- playerInRange = true
- Interacts = other.gameObject
- interactionIndicator.SetActive(true)
- playerQuestSystem = other.GetComponent<QuestSystem>()

OnTriggerExit(Collider other)
- if (other.CompareTag("Player"))
- playerInRange = false
- interactionIndicator.SetActive(false)

- QuestObjective at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestObjective.cs:
Summery of QuestObjective:
File Name: QuestObjective.cs

This file defines an abstract class QuestObjective with certain properties and methods. It has a string id and description associated with the objective, an ObjectiveStatus which is an enum consisting of Completed and Incomplete values. QuestObjective is an abstract class and has two abstract methods which are IsCompleted and UpdateProgress.

KillObjective: It is a class that inherits from QuestObjective class and has additional properties such as enemyId, targetKills, and currentKills. It has a constructor that takes in the id, description, enemyId and targetKills as parameters and initializes currentKills and status to zero and Incomplete respectively. UpdateProgress method increments currentKills when a specific enemy is killed and sets status to Completed when the required number of kills is achieved. GetObjectiveProgress returns the current kill to target kill ratio. IsCompleted method checks if status is Completed or not.

GatherObjective: It is also a class that inherits from QuestObjective, similar to the KillObjective class. This class has properties such as itemId, targetItems and currentItems. It has a constructor that takes in id, description, itemId and targetItems. CurrentItems and Status are initialized to zero and Incomplete respectively. UpdateProgress method increments currentItems when the player picks up a specific item and changes status to Completed when the required number of items are gathered. GetObjectiveProgress returns current item count to target item count ratio. IsCompleted method checks if status is Completed or not.

InspectObjective: This class inherits from the QuestObjective class and has properties such as locationId and locationInspected. It has a constructor that takes in id, description, and locationId. LocationInspected and Status are initialized to false and Incomplete, respectively. UpdateProgress method sets locationInspected to true when the player visits a specific location and sets Status to Completed. GetObjectiveProgress returns whether the location is inspected or not and IsCompleted checks whether the location is inspected or not.

ActivateObjective: This class also inherits from QuestObjective similar to the above classes and has properties such as altarId and altarActivated. It has a constructor that takes in id, description and altarId as parameters. AltarActivated and Status is initialized to false and Incomplete. UpdateProgress method sets altarActivated to true when the player uses a specific item or else when the player approaches the specific altar and sets status to Completed. GetObjectiveProgress returns whether the specific altar is activated or not and IsCompleted method checks whether the altar is activated or not.
Code of file QuestObjective:
using UnityEditor;
using UnityEngine;

public abstract class QuestObjective
{
    public string id;
    public string description;
    public ObjectiveStatus status;
    public abstract bool IsCompleted();

    public abstract void UpdateProgress(string infoId);
    public abstract string GetObjectiveProgress();

}
public enum ObjectiveStatus { Completed,Incomplete };

public class GatherObjective : QuestObjective
{
    public string itemId;
    public int targetItems;
    public int currentItems;

    public GatherObjective(string id, string description, string itemId, int targetItems)
    {
        this.id = id;
        this.description = description;
        this.itemId = itemId;
        this.targetItems = targetItems;
        this.currentItems = 0;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string gatheredItemId)
    {
        if (gatheredItemId == "gather:"+itemId && status != ObjectiveStatus.Completed)
        {
            currentItems++;
            if (currentItems >= targetItems)
            {
                status = ObjectiveStatus.Completed;
            }
        }
    }

    public override bool IsCompleted()
    {
        return status == ObjectiveStatus.Completed;
    }
    public override string GetObjectiveProgress()
    {
        return currentItems + "/" + targetItems;
    }
}

public class InspectObjective : QuestObjective
{
    public string locationId;
    public bool locationInspected;

    public InspectObjective(string id, string description, string locationId)
    {
        this.id = id;
        this.description = description;
        this.locationId = locationId;
        this.locationInspected = false;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string inspectedLocationId)
    {
        if (inspectedLocationId == "visit:"+locationId && !locationInspected)
        {
            locationInspected = true;
            status = ObjectiveStatus.Completed;
        }
    }

    public override bool IsCompleted()
    {
        return locationInspected;
    }
    public override string GetObjectiveProgress()
    {
        return locationInspected ? "Inspected" : "Not Inspected";
    }
}

public class ActivateObjective : QuestObjective
{
    public string altarId;
    public bool altarActivated;

    public ActivateObjective(string id, string description, string altarId)
    {
        this.id = id;
        this.description = description;
        this.altarId = altarId;
        this.altarActivated = false;
        this.status = ObjectiveStatus.Incomplete;
    }

    public override void UpdateProgress(string activatedAltarId)
    {
        if (activatedAltarId == "activate:"+altarId && !altarActivated)
        {
            altarActivated = true;
            status = ObjectiveStatus.Completed;
        }
    }

    public override bool IsCompleted()
    {
        return altarActivated;
    }
    public override string GetObjectiveProgress()
    {
        return altarActivated ? "Activated" : "Not Activated";
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestObjective.cs
Syntax Tree of QuestObjective.cs:
- QuestObjective
  - string id
  - string description
  - ObjectiveStatus status
  - abstract bool IsCompleted()
  - abstract void UpdateProgress(string infoId)
  - abstract string GetObjectiveProgress()
- enum ObjectiveStatus
  - Completed
  - Incomplete
- GatherObjective : QuestObjective
  - string itemId
  - int targetItems
  - int currentItems
  - GatherObjective(string id, string description, string itemId, int targetItems)
  - override void UpdateProgress(string gatheredItemId)
  - override bool IsCompleted()
  - override string GetObjectiveProgress()
- InspectObjective : QuestObjective
  - string locationId
  - bool locationInspected
  - InspectObjective(string id, string description, string locationId)
  - override void UpdateProgress(string inspectedLocationId)
  - override bool IsCompleted()
  - override string GetObjectiveProgress()
- ActivateObjective : QuestObjective
  - string altarId
  - bool altarActivated
  - ActivateObjective(string id, string description, string altarId)
  - override void UpdateProgress(string activatedAltarId)
  - override bool IsCompleted()
  - override string GetObjectiveProgress()

- HuntWolvesQuest at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestS\HuntWolvesQuest.cs:
Summery of HuntWolvesQuest:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestS\HuntWolvesQuest.cs
The HuntWolvesQuest.cs file is a scriptable object that represents a quest to hunt down a specific number of wolves. The file starts by using the UnityEngine and System.Collections.Generic namespaces. 

The scriptable object is created through the use of the CreateAssetMenu attribute, with the fileName set to "HuntWolves", the menuName to "ScriptableObjects/Quests/HuntWolves", and the order to 1. 

The class HuntWolvesQuest inherits from the Quest class and has a constructor that sets the quest ID to 1, the title to "Hunt the Wolves", and the description to explain the situation and objectives for the quest. 

Additionally, the script adds an objective to the quest by creating a new KillObjective and calling the AddObjective method to add it to the objective list. This objective is to kill 10 wolves and bring back their pelts as proof, with the objective's title set to "HuntWolvesObjective", its description set to "Hunt 10 Wolves", its target enemy set to "Wolf", and the requirement set to 10. 

Overall, the implementation of HuntWolvesQuest.cs defines a quest that involves killing a certain number of wolves and bringing back their pelts to a nearby village.
Code of file HuntWolvesQuest:
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "HuntWolves", menuName = "ScriptableObjects/Quests/HuntWolves", order = 1)]
public class HuntWolvesQuest : Quest
{
    public HuntWolvesQuest() : base(1, "Hunt the Wolves", "The village has been suffering from frequent wolf attacks. They've asked you to hunt down 10 wolves and bring back their pelts as proof.")
    {
        // Add a KillObjective to the list of objectives
        AddObjective(new KillObjective("HuntWolvesObjective", "Hunt 10 Wolves", "Wolf", 10));
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestS\HuntWolvesQuest.cs
Class: HuntWolvesQuest

- CreateAssetMenu
    - fileName: "HuntWolves"
    - menuName: "ScriptableObjects/Quests/HuntWolves"
    - order: 1

- Base: Quest
    - ID: 1
    - Title: "Hunt the Wolves"
    - Description: "The village has been suffering from frequent wolf attacks. They've asked you to hunt down 10 wolves and bring back their pelts as proof."

- AddObjective
    - KillObjective
        - ID: "HuntWolvesObjective"
        - Title: "Hunt 10 Wolves"
        - EnemyName: "Wolf"
        - TargetAmount: 10

- NewBehaviourScript at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestS\NewBehaviourScript.cs:
Summery of NewBehaviourScript:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestS\NewBehaviourScript.cs
The file "NewBehaviourScript.cs" is a C# script that is added as a component to a game object in the Unity engine. It contains two methods, "Start()" and "Update()", which are automatically executed by Unity when the game object is created and each frame thereafter, respectively. 

As it stands, this script does not do anything specific; it simply initializes the game object on creation and updates it each frame. The internal logic of the script can be expanded upon by the developer to add additional functionality, such as checking for user input or updating the game state. The "using" statements at the top of the script allow the use of built-in Unity classes and interfaces.
Code of file NewBehaviourScript:
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestS\NewBehaviourScript.cs
NewBehaviourScript:
- using System.Collections;
- using System.Collections.Generic;
- using UnityEngine;
- class NewBehaviourScript:
  - MonoBehaviour
  - method Start():
  - method Update():

- QuestSystem at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestSystem.cs:
Summery of QuestSystem:
File Name: QuestSystem.cs

Summary: This file contains the implementation of the QuestSystem class, which is responsible for managing quests in the game. It contains functions to add, remove and update quests. It also has a function to get a quest by its ID. 

Internally, the class uses a List to store all the quests, with each quest being an instance of the Quest class. When a quest is added, it is simply added to the list. When removing a quest, the Quest with the matching ID is found using the Find() function and then removed from the list.

To update quest objectives, the UpdateQuestObjective() function loops through all quests and calls the CheckAndUpdateObjectives() function on each quest that is not completed.

Overall, the QuestSystem class provides a simple and efficient way to manage quests in a game.
Code of file QuestSystem:
using UnityEngine;
using System.Collections.Generic;

public class QuestSystem : MonoBehaviour
{
    public List<Quest> quests;
    public UIManager uiManager;

 
public Quest GetQuestByID(int questID)
{
    foreach (Quest quest in quests)
    {
        if (quest.id == questID)
        {
            return quest;
        }
    }
    return null;
}
    private void Start()
    {
        quests = new List<Quest>();
    }

    public void AddQuest(Quest quest)
    {
        uiManager.updateQuestBook();
        quests.Add(quest);
    }

    public void RemoveQuest(int questId)
    {

        Quest questToRemove = quests.Find(q => q.id == questId);
        if (questToRemove != null)
        {
          
            quests.Remove(questToRemove);
        }
    }
        public void UpdateQuestObjective(string objectiveId)
    {
        uiManager.updateQuestBook();
        foreach (Quest quest in quests)
        {
            if (quest.status != QuestStatus.Completed)
            {
                quest.CheckAndUpdateObjectives(objectiveId);
            }
        }
    }

   
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\QuestSystem.cs
File: QuestSystem.cs

Class: QuestSystem

- quests : List<Quest>
- uiManager : UIManager

+ GetQuestByID(questID : int) : Quest
- Start() : void
+ AddQuest(quest : Quest) : void
+ RemoveQuest(questId : int) : void
+ UpdateQuestObjective(objectiveId : string) : void

- Reward at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\Reward.cs:
Summery of Reward:
File Name: Reward.cs

This file contains a class named Reward which is responsible for defining the reward properties. It has three properties, rewardId of type string, rewardName of type string, and quantity of type int. 

The class has a constructor that takes in three parameters, rewardId, rewardName, and quantity, and initializes the class properties with these values. 

This class is marked with [System.Serializable] attribute which indicates that instances of this class can be serialized to be stored persistently or sent over the network.

The Reward class can be utilized by other scripts or systems to manage rewards in a game. For example, a player may earn rewards for completing certain tasks in a game. These rewards can be managed and tracked using the Reward class.
Code of file Reward:
using UnityEngine;

[System.Serializable]
public class Reward
{
    public string rewardId;
    public string rewardName;
    public int quantity;

    public Reward(string rewardId, string rewardName, int quantity)
    {
        this.rewardId = rewardId;
        this.rewardName = rewardName;
        this.quantity = quantity;
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\QuestFiles\Reward.cs
Reward:
- rewardId: string
- rewardName: string
- quantity: int
- Reward(rewardId: string, rewardName: string, quantity: int)

- CharacterStatsUI at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\CharacterStatsUI.cs:
Summery of CharacterStatsUI:
File Name: CharacterStatsUI.cs

This file contains the implementation of the UI for displaying and updating the character's stats in the game. It uses Unity's UI system to display text and buttons on the screen. The UI displays the character's current stats, including Strength, Intelligence, Dexterity, Endurance, and Wisdom, and also shows the number of unspent stat points the character has.

The class exposes public variables for the UI elements, including the Text objects for displaying the stats and the Button objects for increasing them. It also has a reference to the CharacterStats component, which manages the character's stats.

The Start() method initializes the UI by setting up the button listeners and subscribing to the CharacterStats.StatsChanged event. The event is triggered whenever the character's stats change, and it calls the UpdateUI() method to update the UI with the new values.

The Awake() method sets the cursor to be visible and unlocked, which is useful for UI interaction.

The UpdateUI() method updates the text objects with the current stat values.

The IncreaseStat() method is called whenever the player clicks on a stat button. It calls the CharacterStats.IncreaseStat() method with the appropriate Archetype enum value to increase the corresponding stat by 1.
Code of file CharacterStatsUI:
﻿using UnityEngine;
using UnityEngine.UI;

public class CharacterStatsUI : MonoBehaviour
{
    public Text unspentStatPointsText;
    public Text strengthText;
    public Text intelligenceText;
    public Text dexterityText;
    public Text enduranceText;
    public Text wisdomText;

    public Button strengthButton;
    public Button intelligenceButton;
    public Button dexterityButton;
    public Button enduranceButton;
    public Button wisdomButton;

    public CharacterStats characterStats;

    private void Start()
    {
        strengthButton.onClick.AddListener(() => IncreaseStat(Archetype.Strength));
        intelligenceButton.onClick.AddListener(() => IncreaseStat(Archetype.Intelligence));
        dexterityButton.onClick.AddListener(() => IncreaseStat(Archetype.Dexterity));
        enduranceButton.onClick.AddListener(() => IncreaseStat(Archetype.Endurance));
        wisdomButton.onClick.AddListener(() => IncreaseStat(Archetype.Wisdom));

        characterStats.StatsChanged += UpdateUI;
        UpdateUI();
    }

    private void Awake()
    {
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
    }

    private void UpdateUI()
    {
        unspentStatPointsText.text = "Unspent Points: " + characterStats.unspentStatPoints;
        strengthText.text = "Strength: " + characterStats.strength;
        intelligenceText.text = "Intelligence: " + characterStats.intelligence;
        dexterityText.text = "Dexterity: " + characterStats.dexterity;
        enduranceText.text = "Endurance: " + characterStats.endurance;
        wisdomText.text = "Wisdom: " + characterStats.wisdom;
    }

    private void IncreaseStat(Archetype mainStatType)
    {
        characterStats.IncreaseStat(mainStatType, 1);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\CharacterStatsUI.cs
CharacterStatsUI:
- public Text unspentStatPointsText
- public Text strengthText
- public Text intelligenceText
- public Text dexterityText
- public Text enduranceText
- public Text wisdomText
- public Button strengthButton
- public Button intelligenceButton
- public Button dexterityButton
- public Button enduranceButton
- public Button wisdomButton
- public CharacterStats characterStats
- Start()
    - strengthButton.onClick.AddListener(() -> IncreaseStat(Archetype.Strength))
    - intelligenceButton.onClick.AddListener(() -> IncreaseStat(Archetype.Intelligence))
    - dexterityButton.onClick.AddListener(() -> IncreaseStat(Archetype.Dexterity))
    - enduranceButton.onClick.AddListener(() -> IncreaseStat(Archetype.Endurance))
    - wisdomButton.onClick.AddListener(() -> IncreaseStat(Archetype.Wisdom))
    - characterStats.StatsChanged += UpdateUI
    - UpdateUI()
- Awake()
    - Cursor.visible = true
    - Cursor.lockState = CursorLockMode.None
- UpdateUI()
    - unspentStatPointsText.text = "Unspent Points: " + characterStats.unspentStatPoints
    - strengthText.text = "Strength: " + characterStats.strength
    - intelligenceText.text = "Intelligence: " + characterStats.intelligence
    - dexterityText.text = "Dexterity: " + characterStats.dexterity
    - enduranceText.text = "Endurance: " + characterStats.endurance
    - wisdomText.text = "Wisdom: " + characterStats.wisdom
- IncreaseStat(Archetype mainStatType)
    - characterStats.IncreaseStat(mainStatType, 1)

- CharacterUi at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\CharacterUi.cs:
Summery of CharacterUi:
File: CharacterUi.cs

This file contains the implementation of the Character UI class that is responsible for updating the UI elements that display the stats of the character. It has references to various UI elements like Text, Image and Button that are used to display the character's stats and allow the user to interact with the game's interface. The class has a reference to a CharacterStats and UIManager classes which are used to retrieve and display the character's stats and to manage the user interface respectively.

The Start() method is used to set up the UI and event listeners for the UI elements. It assigns a callback function to the onClick event of the openCharacterStatsMenu Button that opens the character stats UI when clicked, and subscribes to the StatsChanged event of the CharacterStats object. Whenever this event is fired, the UpdateUI() method is called to update the UI elements with the new stats.

The Awake() method is used to set the cursor visible and unlock it when the scene starts.

The UpdateUI() method is responsible for updating the Text elements that display the character's stats, and the subStatsPhysical, subStatsSpellCasting, subStatsDefensive, and subStatsUniversal Text elements that display some additional details about the character's stats. It retrieves this information from the CharacterStats object and formats it before setting it as the text content for the UI Text elements.

In summary, the CharacterUi class updates the UI elements that display the character's stats and provides a way for the user to interact with the game's interface. It subscribes to the StatsChanged event of the CharacterStats object to update the UI whenever the character's stats change.
Code of file CharacterUi:
﻿using UnityEngine;
using UnityEngine.UI;

public class CharacterUi : MonoBehaviour
{
    public Text unspentStatPointsText;
    public Text strengthText;
    public Text intelligenceText;
    public Text dexterityText;
    public Text enduranceText;
    public Text wisdomText;



    public Text subStatsPhysical;
    public Text subStatsSpellCasting;
    public Text subStatsDefensive;
    public Text subStatsUniversal;

    public Button openCharacterStatsMenu;
    public Image unspentStatPoints;

    public CharacterStats characterStats;
    public UIManager uiManager;

    private void Start()
    {
        openCharacterStatsMenu.onClick.AddListener(() => uiManager.OpenCharacterStatusUI());
        characterStats.StatsChanged += UpdateUI;
        UpdateUI();
    }

    private void Awake()
    {
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
    }

    private void UpdateUI()
    {
        strengthText.text = "Strength: " + characterStats.strength;
        intelligenceText.text = "Intelligence: " + characterStats.intelligence;
        dexterityText.text = "Dexterity: " + characterStats.dexterity;
        enduranceText.text = "Endurance: " + characterStats.endurance;
        wisdomText.text = "Wisdom: " + characterStats.wisdom;

        subStatsPhysical.text = "Critical Chance: " + characterStats.criticalChance.ToString("F1") + "%" + "\nCritical Damage: " + characterStats.criticalDamage + "%" + "\nAttack Speed: " + characterStats.attackSpeed.ToString("F2");
        subStatsSpellCasting.text = "Spell Crit Chc: " + characterStats.spellCriticalChance.ToString("F1") + "%" + "\nSpell Crit Dmg: " + characterStats.spellCriticalDamage + "%" + "\nCooldown: " + characterStats.cooldown;
        subStatsDefensive.text = "Armor: " + characterStats.armor + "\nMagic Resi: " + characterStats.magicResistance + "\nDodge Chance: " + characterStats.dodgeChance.ToString("F1") + "%";
        subStatsUniversal.text = "Max Life: " + characterStats.maxLife + "\nLife Reg: " + characterStats.lifeRegen + "\nMax Mana: " + characterStats.maxMana + "\nMana Reg: " + characterStats.manaRegen;
    }

}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\CharacterUi.cs
Class Name: CharacterUi

- public Text unspentStatPointsText;
- public Text strengthText;
- public Text intelligenceText;
- public Text dexterityText;
- public Text enduranceText;
- public Text wisdomText;
- public Text subStatsPhysical;
- public Text subStatsSpellCasting;
- public Text subStatsDefensive;
- public Text subStatsUniversal;
- public Button openCharacterStatsMenu;
- public Image unspentStatPoints;
- public CharacterStats characterStats;
- public UIManager uiManager;

- private void Start()
    - openCharacterStatsMenu.onClick.AddListener(() => uiManager.OpenCharacterStatusUI());
    - characterStats.StatsChanged += UpdateUI;
    - UpdateUI();

- private void Awake()
    - Cursor.visible = true;
    - Cursor.lockState = CursorLockMode.None;

- private void UpdateUI()
    - strengthText.text = "Strength: " + characterStats.strength;
    - intelligenceText.text = "Intelligence: " + characterStats.intelligence;
    - dexterityText.text = "Dexterity: " + characterStats.dexterity;
    - enduranceText.text = "Endurance: " + characterStats.endurance;
    - wisdomText.text = "Wisdom: " + characterStats.wisdom;
    - subStatsPhysical.text = "Critical Chance: " + characterStats.criticalChance.ToString("F1") + "%" + "\nCritical Damage: " + characterStats.criticalDamage + "%" + "\nAttack Speed: " + characterStats.attackSpeed.ToString("F2");
    - subStatsSpellCasting.text = "Spell Crit Chc: " + characterStats.spellCriticalChance.ToString("F1") + "%" + "\nSpell Crit Dmg: " + characterStats.spellCriticalDamage + "%" + "\nCooldown: " + characterStats.cooldown;
    - subStatsDefensive.text = "Armor: " + characterStats.armor + "\nMagic Resi: " + characterStats.magicResistance + "\nDodge Chance: " + characterStats.dodgeChance.ToString("F1") + "%";
    - subStatsUniversal.text = "Max Life: " + characterStats.maxLife + "\nLife Reg: " + characterStats.lifeRegen + "\nMax Mana: " + characterStats.maxMana + "\nMana Reg: " + characterStats.manaRegen;

- DamageNumberController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\DamageNumberController.cs:
Summery of DamageNumberController:
File Name: DamageNumberController.cs

This file contains the implementation of the DamageNumberController component which displays damage numbers in a game. It has a public TextMeshPro field that stores the text to be displayed, a floatSpeed field that determines the speed at which the number floats upwards, and a duration field that determines how long the number stays on the screen.

The Update() method updates the position of the number by moving it upwards using the floatSpeed field, rotates the number to face the camera, applies a fade effect based on the elapsed time and duration, and destroys the game object after the duration.

The FaceCamera() method calculates the direction to the camera, sets its y-component to zero, and rotates the number to face the camera.

The SetDamageValue() method sets the text field of the TextMeshPro component to the damage value passed as a parameter, while ensuring that the component is not null.

The Start() method assigns the main camera to the playerCamera field. If the TextMeshPro component is not assigned in the DamageNumberController component, an error message is displayed and the function returns. If the TextMeshPro component is null, the game object is destroyed, and the function returns.
Code of file DamageNumberController:
﻿using TMPro;
using UnityEngine;

public class DamageNumberController : MonoBehaviour
{
    public TextMeshPro textMeshPro;
    public float floatSpeed = 1f;
    public float duration = 1.5f;

    private float elapsedTime = 0f;
    private Camera playerCamera;

    private void Start()
    {
        playerCamera = Camera.main;
    }

    public void SetDamageValue(float damage)
    {
        if (textMeshPro == null)
        {
            Debug.LogError("TextMeshPro component is not assigned in the DamageNumberController component.");
            return;
        }

        textMeshPro.text = damage.ToString();
    }

    private void Update()
    {
        if (textMeshPro == null)
        {
            Destroy(gameObject);
            return;
        }

        // Rotate towards player camera
        if (playerCamera != null)
        {
            FaceCamera();
        }

        // Float upwards
        transform.position += Vector3.up * floatSpeed * Time.deltaTime;

        // Update the elapsed time
        elapsedTime += Time.deltaTime;

        // Fade effect
        textMeshPro.alpha = Mathf.Clamp01(1f - (elapsedTime / duration));

        // Destroy the damage number after the duration
        if (elapsedTime >= duration)
        {
            Destroy(gameObject);
        }
    }

    private void FaceCamera()
    {
        Vector3 targetDirection = playerCamera.transform.position - transform.position;
        targetDirection.y = 0;
        Quaternion targetRotation = Quaternion.LookRotation(-targetDirection);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 1);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\DamageNumberController.cs
Class: DamageNumberController

- textMeshPro : TextMeshPro
- floatSpeed : float
- duration : float
- elapsedTime : float
- playerCamera : Camera

+ Start()
- SetDamageValue(damage : float)
+ Update()
- FaceCamera()

- GameManager at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\GameManager.cs:
Summery of GameManager:
File Name: GameManager.cs

Summary: The GameManager class is responsible for managing the overall game state and other systems as needed. It uses an enum called GameState to keep track of the current state of the game. The class also provides methods to change the game state and save or load the game.

Internals: The class has a static instance variable to ensure there is only one instance of the GameManager in the game. The Awake method initializes the game state and other systems as needed, and ensures that only one instance of the game manager exists in the game by destroying any additional instances. The Update method calls HandleGameState and UpdateCursorVisibility functions. 

The UpdateCursorVisibility method handles when to show or hide the cursor based on the current game state. If the game is paused or in a menu, the cursor is shown but if the game is playing, the cursor is hidden. 

The HandleGameState method uses a switch statement to handle the different game states (InMenu, Playing, Paused, GameOver), and performs the necessary logic for each state.

The class provides public methods to change the current game state and to save and load the game. Other methods can also be added as needed for additional functionality.

Explicit Dependencies: using UnityEngine;
Code of file GameManager:
using UnityEngine;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance;

    public enum GameState { InMenu, Playing, Paused, GameOver }
    public GameState currentState;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }

        // Initialize game state and other systems as needed
        currentState = GameState.InMenu;
    }

    private void Update()
    {
        HandleGameState();
        UpdateCursorVisibility();
    }

    private void UpdateCursorVisibility()
    {
        // If the game is paused or in a menu, show the cursor
        if (currentState == GameState.Paused || currentState == GameState.InMenu)
        {
            Cursor.visible = true;
            Cursor.lockState = CursorLockMode.None;
        }
        // If the game is playing, hide the cursor
        else if (currentState == GameState.Playing)
        {
            Cursor.visible = false;
            Cursor.lockState = CursorLockMode.Locked;
        }
    }

    private void HandleGameState()
    {
        switch (currentState)
        {
            case GameState.InMenu:
                // Handle main menu logic
                break;
            case GameState.Playing:
                // Handle playing state logic
                break;
            case GameState.Paused:
                // Handle paused state logic
                break;
            case GameState.GameOver:
                // Handle game over logic
                break;
        }
    }

    public void ChangeGameState(GameState newState)
    {
        currentState = newState;
    }
    public void SaveGame()
    {
        // Implement save game logic
    }

    public void LoadGame()
    {
        // Implement load game logic
    }
    // Implement other methods as needed, such as SaveGame, LoadGame, etc.
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\GameManager.cs
GameManager:
- Instance: static
- currentState: enum
- Awake()
    - if Instance == null
        - Instance = this
        - DontDestroyOnLoad(gameObject)
    - else
        - Destroy(gameObject)
        - return
    - currentState = InMenu
- Update()
    - HandleGameState()
    - UpdateCursorVisibility()
- UpdateCursorVisibility()
    - if currentState == Paused or InMenu
        - Cursor.visible = true
        - Cursor.lockState = None
    - else if currentState == Playing
        - Cursor.visible = false
        - Cursor.lockState = Locked
- HandleGameState()
    - switch currentState
        - InMenu
            - Handle main menu logic
        - Playing
            - Handle playing state logic
        - Paused
            - Handle paused state logic
        - GameOver
            - Handle game over logic
- ChangeGameState(newState)
    - currentState = newState
- SaveGame()
    - Implement save game logic
- LoadGame()
    - Implement load game logic

- IDragable at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\Interfaces\IDragable.cs:
Summery of IDragable:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\Interfaces\IDragable.cs
The file named "IDragable.cs" defines an interface for objects that can be dragged in a Unity UI. The interface includes three methods from the Event System library: IBeginDragHandler, IDragHandler, and IEndDragHandler. This allows the implementation of different behaviors for the beginning, dragging, and ending stages of the drag. 

The interface also includes a custom method, "getDraggedObject()", which returns the object being dragged. By implementing the IDragable interface, objects can easily be made draggable within a Unity project.
Code of file IDragable:
using UnityEngine.EventSystems;
using UnityEngine;
public interface IDragable : IBeginDragHandler, IDragHandler, IEndDragHandler
{

    GameObject getDraggedObject();
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\Interfaces\IDragable.cs
IDragable:
- interface
- IBeginDragHandler
- IDragHandler
- IEndDragHandler
- GameObject
- getDraggedObject()

- IRecieveDrop at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\Interfaces\IRecieveDrop.cs:
Summery of IRecieveDrop:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\Interfaces\IRecieveDrop.cs
The file name is "IRecieveDrop.cs" and it is located in the "Ui\Interfaces" folder of the Unity project. This file contains an interface, which means it defines a set of methods that a class can implement. 

The interface is named "IRecieveDrop" and it inherits from three other interfaces: "IPointerEnterHandler", "IPointerExitHandler", and "IDropHandler". These are all interfaces from the Unity Event System, which is used for handling user input. 

The "IRecieveDrop" interface does not have any methods defined in it, but rather it requires any class that implements it to also implement the methods from the three inherited interfaces. 

These methods are used for handling different aspects of user input related to drag and drop functionality. "IPointerEnterHandler" and "IPointerExitHandler" are used for detecting when the user's mouse pointer enters and exits the area of the object that is implementing the interface. "IDropHandler" is used for detecting when the user drops an object onto the area of the object that is implementing the interface.

Overall, the "IRecieveDrop" interface is used to allow objects to receive dropped objects from the user and handle them in a customizable way.
Code of file IRecieveDrop:
using UnityEngine.EventSystems;
using UnityEngine;
public interface IRecieveDrop : IPointerEnterHandler, IPointerExitHandler, IDropHandler
{
    
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\Interfaces\IRecieveDrop.cs
IRecieveDrop:
- interface
- name: IRecieveDrop
- extends: IPointerEnterHandler, IPointerExitHandler, IDropHandler
- namespace: UnityEngine.EventSystems, UnityEngine
- filepath: C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\Interfaces\IRecieveDrop.cs

- OutlineHighlight at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\OutlineHighlight.cs:
Summery of OutlineHighlight:
File Name: OutlineHighlight.cs

Summary: 

The OutlineHighlight class is a MonoBehavior script that allows for highlighting outlines of a specific object with a particular color. Attributes include a highlight material, highlight color, outline thickness, and target transform. The class utilizes a Camera object, CommandBuffer, and RenderTexture to achieve its desired effect.

Internally, the OnRenderImage function is utilized to render an image with the highlight and outline effect. A check for a null target helps prevent errors. The RenderTexture variable is then created with temporary properties. The CommandBuffer is used to clear the render target, retrieve the target's mesh filter, and draw the mesh with the highlight material. The color and thickness properties of the highlight material are set before the final command buffer is executed and blitted to the destination texture. Finally, the temporary render texture is released.

Overall, this class is important for adding visual depth to games or applications where a highlighted outline of a particular object is desired.
Code of file OutlineHighlight:
﻿using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode, ImageEffectAllowedInSceneView]
public class OutlineHighlight : MonoBehaviour
{
    public Material highlightMaterial;
    public Color highlightColor = Color.red;
    public float outlineThickness = 2f;
    public Transform target;

    private Camera cam;
    private CommandBuffer commandBuffer;

    private void Start()
    {
        cam = GetComponent<Camera>();
        commandBuffer = new CommandBuffer();
    }

    private void OnRenderImage(RenderTexture src, RenderTexture dest)
    {
        if (target == null)
        {
            Graphics.Blit(src, dest);
            return;
        }

        commandBuffer.Clear();

        var renderTexture = RenderTexture.GetTemporary(src.width, src.height, src.depth, src.format);

        commandBuffer.SetRenderTarget(renderTexture);

        commandBuffer.ClearRenderTarget(true, true, Color.clear);

        var meshFilter = target.GetComponent<MeshFilter>();
        if (meshFilter != null)
        {
            commandBuffer.DrawMesh(meshFilter.sharedMesh, target.localToWorldMatrix, highlightMaterial);
        }

        highlightMaterial.SetColor("_OutlineColor", highlightColor);
        highlightMaterial.SetFloat("_OutlineThickness", outlineThickness);

        Graphics.ExecuteCommandBuffer(commandBuffer);

        Graphics.Blit(renderTexture, dest);

        RenderTexture.ReleaseTemporary(renderTexture);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\OutlineHighlight.cs
class: OutlineHighlight
  - highlightMaterial: Material
  - highlightColor: Color
  - outlineThickness: float
  - target: Transform
  - cam: Camera
  - commandBuffer: CommandBuffer
  + Start()
  + OnRenderImage(src: RenderTexture, dest: RenderTexture)

- OverlayUiController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\OverlayUiController.cs:
Summery of OverlayUiController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\OverlayUiController.cs
The file "OverlayUiController.cs" is responsible for managing the overlay UI elements in the game. It contains public fields for the character's name, health bar, mana bar, and level text. These fields are linked to the respective UI elements in the scene using the SerializeField attribute.

In addition, the controller has a reference to the CharacterStats script that holds information about the player's character's health, mana, and level. This reference is initialized in the Start() method.

The Start() method also sets the maximum values of the health and mana bars, as well as the character name, using the information from the CharacterStats script. The UpdateUI() method, which is called both in Start() and Update(), sets the current values of the health and mana bars and updates the character's level text.

Overall, the OverlayUiController.cs script provides dynamic display of the character's stats to the player while playing the game.
Code of file OverlayUiController:
using UnityEngine;
using UnityEngine.UI;

public class OverlayUiController : MonoBehaviour
{
    private UIManager UIManager;
    [SerializeField] public Text characterNameText;
    [SerializeField] public Slider healthBar;
    [SerializeField] public Slider manaBar;
    [SerializeField] public Text levelText;
    private GameObject player;

    private HealthController HealthController;
    private ManaController ManaController;

    private void updateHealthBar()
    {
        healthBar.value = HealthController.currentHealth;
        healthBar.maxValue = HealthController.maxHealth;
    }
    
    private void updateManaBar()
    {
        manaBar.value = (ManaController.currentMana); 
        manaBar.maxValue = ManaController.maxMana;
    }
    private void updateHealthAndMana(){

        updateHealthBar();
        updateManaBar();
    }
    private void Start()
    {
        UIManager = FindObjectOfType<UIManager>();
        player = FindObjectOfType<PlayerController>().gameObject;
        HealthController = player.GetComponent<HealthController>();
        ManaController = player.GetComponent<ManaController>();

        
    }
    public void Update()
    {
        updateHealthAndMana();
    }
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\OverlayUiController.cs
OverlayUiController
- UIManager
- Text characterNameText
- Slider healthBar
- Slider manaBar
- Text levelText
- GameObject player
- HealthController HealthController
- ManaController ManaController
- void updateHealthBar()
- void updateManaBar()
- void updateHealthAndMana()
- void Start()
- void Update()

- PresentQuestUiController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\PresentQuestUiController.cs:
Summery of PresentQuestUiController:
File name: PresentQuestUiController.cs

This class is responsible for controlling the UI elements related to presenting a quest. It contains private fields for the quest title, description, and two buttons (accept and decline). Additionally, it has a reference to the QuestSystem class.

The Start() method is called once when the object is created and it finds the QuestSystem object in the scene and assigns it to the internal reference.

The showQuestInfo(Quest quest, UIManager UIManager) method is where the main logic occurs. It takes in a Quest object and a UIManager object, and sets the quest title and description text accordingly. It also sets up the accept and decline button listeners to handle the respective actions. When the accept button is clicked, it adds the current quest to the QuestSystem instance and hides the Quest UI Presenter via the UIManager. When the decline button is clicked, it only hides the presenter.

This class utilizes the Unity Engine's UI components including TMP_Text and Button.
Code of file PresentQuestUiController:
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class PresentQuestUiController : MonoBehaviour
{
    [SerializeField] private TMP_Text questTitle;
    [SerializeField] private TMP_Text questDescription;
    [SerializeField] private Button acceptButton;
    [SerializeField] private Button declineButton;

    private QuestSystem questSystem;
    void Start()
    {
        questSystem = FindObjectOfType<QuestSystem>();
    }
  

    public void showQuestInfo(Quest quest,UIManager UIManager)
    {
        questTitle.text = quest.title;
        questDescription.text = quest.description;
        acceptButton.onClick.AddListener(() => questSystem.AddQuest(quest));
        acceptButton.onClick.AddListener(() => UIManager.hideQuestUiPresenter());
        declineButton.onClick.AddListener(() => UIManager.hideQuestUiPresenter());
        
    }

}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\PresentQuestUiController.cs
PresentQuestUiController
- questTitle: TMP_Text
- questDescription: TMP_Text
- acceptButton: Button
- declineButton: Button
- questSystem: QuestSystem

_Start()
- questSystem = FindObjectOfType<QuestSystem>()

+ showQuestInfo(quest: Quest, UIManager: UIManager)
- questTitle.text = quest.title
- questDescription.text = quest.description
- acceptButton.onClick.AddListener(() => questSystem.AddQuest(quest))
- acceptButton.onClick.AddListener(() => UIManager.hideQuestUiPresenter())
- declineButton.onClick.AddListener(() => UIManager.hideQuestUiPresenter())

- QuestBookUIController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\QuestBookUIController.cs:
Summery of QuestBookUIController:
File name: QuestBookUIController.cs

Summary: 

This script is responsible for controlling the UI elements of the player's quest book. It has references to various UI elements such as text fields, scroll rect, and a prefab for the quest list item. It also has access to the quest system, which stores all the available quests and their objectives. 

The script has two main functions: UpdateQuestList and ShowQuestInformation. The UpdateQuestList function clears the quest list content and repopulates it with the current available quests. The ShowQuestInformation function displays the details of the selected quest, such as its title, description, and objectives. 

To clear the quest list content, the script loops through all the child objects of the questListContent and calls the Destroy function on each of them. To repopulate the quest list content, the script creates a new game object using the questListItemPrefab and sets its text field to the title of the current quest. It also adds a listener to the button component of the game object so that it can display the details of the selected quest when clicked. 

Finally, the scroll position of the quest list is reset to the top. The ShowQuestInformation function sets the text fields of the title, description, and objectives to the selected quest's data. It loops through all the objectives of the quest and displays their progress in a string format. 

Overall, the QuestBookUIController script is an essential component of the player's quest book interface, enabling them to view and track their progress in the available quests.
Code of file QuestBookUIController:
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class QuestBookUIController : MonoBehaviour
{
    public TMP_Text titleText;
    public TMP_Text descriptionText;
    public TMP_Text objectivesText;
    public ScrollRect questListScrollRect;
    public GameObject questListItemPrefab;
    public Transform questListContent;
    
    public QuestSystem questSystem;
  

    private void Awake()
    {
       
    }

    private void Start()
    {  
        UpdateQuestList();
    }

    public void UpdateQuestList()
    {
        // Clear the quest list content
        foreach (Transform child in questListContent)
        {
            Destroy(child.gameObject);
        }

        // Re-populate the quest list content
        foreach (Quest quest in questSystem.quests)
        {
            GameObject questListItem = Instantiate(questListItemPrefab, questListContent);
            questListItem.gameObject.SetActive(true);
            questListItem.GetComponentInChildren<TMP_Text>().text = quest.title;
            questListItem.GetComponent<Button>().onClick.AddListener(() => ShowQuestInformation(quest));
        }

        // Reset the scroll position of the quest list
        questListScrollRect.verticalNormalizedPosition = 1f;
    }

    public void ShowQuestInformation(Quest quest)
    {
        // Set the quest information text fields to the current quest's data
        titleText.text = quest.title;
        descriptionText.text = quest.description;
        string objectivesString = "";
        foreach(QuestObjective objective in quest.objectives)
        {
            objectivesString += $"-({objective.GetObjectiveProgress()})\n";
        }   
        
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\QuestBookUIController.cs
QuestBookUIController
- titleText: TMP_Text
- descriptionText: TMP_Text
- objectivesText: TMP_Text
- questListScrollRect: ScrollRect
- questListItemPrefab: GameObject
- questListContent: Transform
- questSystem: QuestSystem

+ Awake()
+ Start()
+ UpdateQuestList()
+ ShowQuestInformation(Quest quest)

- QuestLogUIController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\QuestLogUIController.cs:
Summery of QuestLogUIController:
File Name: QuestLogUIController.cs

Summary: This file represents the Quest Log User Interface Controller class in the game. It is responsible for updating the display of a player's current quests and tracking quests. It has public and private variables that hold text objects and a reference to the QuestSystem class. It also has functions that update the display of quest logs and add or remove quests from tracking.

Components/Variables: 
- public TMP_Text questLogText: The text object that displays the player's quest log.
- public TMP_Text trackingText: The text object that displays the player's currently tracking quests.
- private QuestSystem questSystem: A variable that holds a reference to the QuestSystem class.
- private List<Quest> trackingQuests: A list that holds the player's currently tracking quests.

Functions:
- Awake(): Called when the game object is created. It sets the questSystem variable by finding the QuestSystem object in the scene. If there is no QuestSystem object found, it logs an error message.
- Start(): Called after Awake(). It updates the quest log display.
- UpdateQuestLog(): A function that updates the display of both the quest log and tracking quests. It loops through all quests in the QuestSystem and adds their information to the quest log string. It also loops through all currently tracking quests and adds their titles to the tracking string. It then updates the text objects with the final strings.
- AddQuestToTrack(int questID): Adds a quest to the list of currently tracking quests. It first gets the quest object using the questSystem's GetQuestByID() function. If the quest is not already being tracked, it is added to the trackingQuests list and the quest log display is updated.
- RemoveQuestToTrack(int questID): Removes a quest from the list of currently tracking quests. It first gets the quest object using the questSystem's GetQuestByID() function. If the quest is currently being tracked, it is removed from the trackingQuests list and the quest log display is updated.
Code of file QuestLogUIController:
using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class QuestLogUIController : MonoBehaviour
{
    public TMP_Text questLogText;
    public TMP_Text trackingText;

    private QuestSystem questSystem;
    private List<Quest> trackingQuests = new List<Quest>();

    private void Awake()
    {
        questSystem = FindObjectOfType<QuestSystem>();
        if (questSystem == null)
        {
            Debug.LogError("No QuestSystem found in the scene!");
        }
    }

    private void Start()
    {
        UpdateQuestLog();
    }

    public void UpdateQuestLog()
    {
        string questLogString = "";
        foreach (Quest quest in questSystem.quests)
        {
            questLogString += $"[{quest.status}] {quest.title}\n";
            foreach (QuestObjective objective in quest.objectives)
            {
                questLogString += $"- {objective.description} ({objective.GetObjectiveProgress()})\n";
            }
            questLogString += "\n";
        }
        questLogText.text = questLogString;

        string trackingString = "Tracking: ";
        foreach (Quest quest in trackingQuests)
        {
            trackingString += quest.title + ", ";
        }
        trackingText.text = trackingString.TrimEnd(',', ' ');
    }

    public void AddQuestToTrack(int questID)
    {
        Quest quest = questSystem.GetQuestByID(questID);
        if (quest != null && !trackingQuests.Contains(quest))
        {
            trackingQuests.Add(quest);
            UpdateQuestLog();
        }
    }

    public void RemoveQuestToTrack(int questID)
    {
        Quest quest = questSystem.GetQuestByID(questID);
        if (quest != null && trackingQuests.Contains(quest))
        {
            trackingQuests.Remove(quest);
            UpdateQuestLog();
        }
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\QuestLogUIController.cs
Class: QuestLogUIController

- public TMP_Text questLogText
- public TMP_Text trackingText
- private QuestSystem questSystem
- private List<Quest> trackingQuests

- private void Awake()
    - questSystem = FindObjectOfType<QuestSystem>()
    - if questSystem == null, Debug.LogError("No QuestSystem found in the scene!")

- private void Start()
    - UpdateQuestLog()

- public void UpdateQuestLog()
    - string questLogString = ""
    - foreach Quest quest in questSystem.quests
        - questLogString += $"[{quest.status}] {quest.title}\n"
        - foreach QuestObjective objective in quest.objectives
            - questLogString += $"- {objective.description} ({objective.GetObjectiveProgress()})\n"
        - questLogString += "\n"
    - questLogText.text = questLogString

    - string trackingString = "Tracking: "
    - foreach Quest quest in trackingQuests
        - trackingString += quest.title + ", "
    - trackingText.text = trackingString.TrimEnd(',', ' ')

- public void AddQuestToTrack(int questID)
    - Quest quest = questSystem.GetQuestByID(questID)
    - if quest != null && !trackingQuests.Contains(quest)
        - trackingQuests.Add(quest)
        - UpdateQuestLog()

- public void RemoveQuestToTrack(int questID)
    - Quest quest = questSystem.GetQuestByID(questID)
    - if quest != null && trackingQuests.Contains(quest)
        - trackingQuests.Remove(quest)
        - UpdateQuestLog()

- SkillTreeMenuController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\SkillTreeMenuController.cs:
Summery of SkillTreeMenuController:
File Name: SkillTreeMenuController.cs

This file contains the implementation of the SkillTreeMenuController class/component. 

The class has two public variables; an array of GameObjects called skillTrees, and an integer called currentSkillTree which is initially set to 0. 

The Start() method is called when the component is first loaded and it sets the active state of the current skill tree to true.

The SwitchSkillTree(int index) method allows for the changing of the currently displayed skill tree. If the index provided is out of range of the skillTrees array, the method returns without doing anything.

If a valid index is provided, the method first sets the active state of the current skill tree to false, then sets the active state of the new skill tree to true, finally it updates the currentSkillTree index to the new index provided.

In summary, this class/component is responsible for displaying different skill trees and switching between them based on player input.
Code of file SkillTreeMenuController:
﻿using UnityEngine;

public class SkillTreeMenuController : MonoBehaviour
{
    public GameObject[] skillTrees;
    public int currentSkillTree = 0;
    private void Start()
    {
         skillTrees[currentSkillTree].SetActive(true);
    }

    public void SwitchSkillTree(int index)
    {
        if (index < 0 || index >= skillTrees.Length) return;

        skillTrees[currentSkillTree].SetActive(false);
        skillTrees[index].SetActive(true);
        currentSkillTree = index;
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\SkillTreeMenuController.cs
SkillTreeMenuController:
- GameObject[] skillTrees
- int currentSkillTree = 0
- Start():
	- skillTrees[currentSkillTree].SetActive(true)
- SwitchSkillTree(int index):
	- if (index < 0 || index >= skillTrees.Length) return
	- skillTrees[currentSkillTree].SetActive(false)
	- skillTrees[index].SetActive(true)
	- currentSkillTree = index

- SpellBookUiController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\SpellBookUiController.cs:
Summery of SpellBookUiController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\SpellBookUiController.cs
The SpellBookUiController.cs file is responsible for managing the user interface (UI) elements related to a player's learned abilities or spells. 

This script contains several public TMP_Text and GameObject variables, which are references to the UI elements that display the ability's name and description, as well as a list of learned abilities shown in a scrollable view. 

The UpdateQuestList() method is used to populate the list of abilities in the scrollable content area. First, it clears any existing content by destroying all the child game objects of the UI parent element. Then, it creates new instances of the ability list item prefab for each ability the player has learned, sets its name using the ability's name property, and attaches a button listener so that when this UI item is clicked, it triggers the ShowAbilityInformation() method with the corresponding ability as a parameter. 

The ShowAbilityInformation() method sets the titleText and descriptionText UI elements to the corresponding values from the ability's properties. Additionally, it generates a string variable called info that contains various information about the ability, such as base damage, strength scaling, intelligence scaling, and cooldown. This information is then displayed in the objectivesText UI element. 

Overall, this script provides a simple interface for players to view their learned abilities and their associated details.
Code of file SpellBookUiController:
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class SpellBookUiController : MonoBehaviour
{
    public TMP_Text titleText;
    public TMP_Text descriptionText;
    public TMP_Text objectivesText;
    public ScrollRect spellListScrollRect;
    public GameObject spellListItemPrefab;
    public Transform spellListContent;
    
    public AbilityController abilityController;
  

    private void Awake()
    {
       
    }

    private void Start()
    {  
        UpdateQuestList();
    }

    public void UpdateQuestList()
    {
        // Clear the quest list content
        foreach (Transform child in spellListContent)
        {
            Destroy(child.gameObject);
        }

        // Re-populate the quest list content
        foreach (Ability ability in abilityController.learnedAbilitys)
        {
            GameObject spellListItem = Instantiate(spellListItemPrefab, spellListContent);
            spellListItem.gameObject.SetActive(true);
            spellListItem.GetComponentInChildren<TMP_Text>().text = ability.name;
            spellListItem.GetComponent<Button>().onClick.AddListener(() => ShowAbilityInformation(ability));
            spellListItem.GetComponent<UiAbilitySlot>().ability = ability;
            
        }

        // Reset the scroll position of the quest list
        spellListScrollRect.verticalNormalizedPosition = 1f;
    }

    public void ShowAbilityInformation(Ability ability)
    {
        // Set the quest information text fields to the current quest's data
        titleText.text = ability.abilityName;
        descriptionText.text = ability.abilityDescription;
    string info = "";

    info += "- Base Damage: " + ability.baseDamage + "\n";
    info += "- Strength Scaling: " + ability.strengthScaling + "\n";
    info += "- Intelligence Scaling: " + ability.intelligenceScaling + "\n";
    info += "- Cooldown: " + ability.cooldown + "\n";
    objectivesText.text = info;

        /*foreach(QuestObjective objective in ability.)
        {
            objectivesString += $"-({objective.GetObjectiveProgress()})\n";
        }   */
        
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\SpellBookUiController.cs
SpellBookUiController:
- titleText: TMP_Text
- descriptionText: TMP_Text
- objectivesText: TMP_Text
- spellListScrollRect: ScrollRect
- spellListItemPrefab: GameObject
- spellListContent: Transform
- abilityController: AbilityController

+ Awake()
+ Start()
+ UpdateQuestList()
+ ShowAbilityInformation(Ability ability)

- ToolTipUiController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\ToolTipUiController.cs:
Summery of ToolTipUiController:
File Name: ToolTipUiController.cs

Summary: The ToolTipUiController class is responsible for controlling the user interface (UI) elements of the tooltip that appears when hovering over an in-game skill. The class contains UI elements, such as SkillName, SkillDescription, SkillpointCost, and SkillIcon. The UpdateUI method is called to update these elements based on the skillNode parameter passed in. In addition, the Awake method sets the cursor state and the Start method remains empty.

Intern Logic: This file creates a ToolTipUiController class that manages tooltip UI elements and updates them based on the skillNode passed in. The UpdateUI method updates the skill name, description, skill point cost, attribute requirement, and skill icon based on the skillNode parameter. Meanwhile, the Awake method sets the cursor state and the Start method does nothing.
Code of file ToolTipUiController:
﻿using UnityEngine;
using UnityEngine.UI;

public class ToolTipUiController : MonoBehaviour
{
    public Text SkillName;
    public Text SkillDescription;
    public Text AlreadySkilled;
    public Text SkillpointCost;
    public Text AttrbuteReq;
    public Image SkillIcon;

    private void Start()
    {
    }

    private void Awake()
    {
        Cursor.visible = true;
        Cursor.lockState = CursorLockMode.None;
    }

    public void UpdateUI(SkillNode node)
    {
        SkillName.text = node.skillName;
        SkillDescription.text = node.skillDescription;
        if (node.isUnlocked)
        {
            AlreadySkilled.gameObject.SetActive(true);
        }
        else
        {
            AlreadySkilled.gameObject.SetActive(false);
        }
        SkillpointCost.text = "Cost: " + node.skillPointCost;

        AttrbuteReq.text = "Requiment:";

        for (int a = 0; a < node.mainStatRequirement.Count; a++)
        {

            AttrbuteReq.text += " " + node.mainStatRequirement[a] + ": " + node.mainStatValue[a];
        }

        if (node.prerequisiteSkill != null)
        {
            AttrbuteReq.text += "Skill Requiment: " + node.prerequisiteSkill.skillName;
        }
        SkillIcon.sprite = node.icon;
    }
    public void UpdateUI(Ability ability)
{
    SkillName.text = ability.abilityName;
    SkillDescription.text = ability.abilityDescription;
    AlreadySkilled.gameObject.SetActive(false);
    SkillpointCost.gameObject.SetActive(false);

    AttrbuteReq.text = $"Base Damage: {ability.baseDamage}\nStrength Scaling: {ability.strengthScaling}\nIntelligence Scaling: {ability.intelligenceScaling}";

    SkillIcon.sprite = ability.icon;
}

public void UpdateUI(Item item)
{
    SkillName.text = item.itemName;
    SkillDescription.text = item.description;
    AlreadySkilled.gameObject.SetActive(false);
    SkillpointCost.gameObject.SetActive(false);

    if (item is EquipableItem equipableItem)
    {
        AttrbuteReq.text = $"Bonuses:\nStrength: {equipableItem.strengthBonus}\nIntelligence: {equipableItem.intelligenceBonus}\nDexterity: {equipableItem.dexterityBonus}\nEndurance: {equipableItem.enduranceBonus}\nWisdom: {equipableItem.wisdomBonus}";
    }
    else
    {
        AttrbuteReq.text = "";
    }

    SkillIcon.sprite = item.icon;
}


}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\ToolTipUiController.cs
ToolTipUiController:

- SkillName
- SkillDescription
- AlreadySkilled
- SkillpointCost
- AttrbuteReq
- SkillIcon

Start()

Awake()

UpdateUI(node)

- SkillName.text
- SkillDescription.text
- AlreadySkilled.gameObject.SetActive(bool)
- SkillpointCost.text
- AttrbuteReq.text
- SkillIcon.sprite

UpdateUI(ability)

- SkillName.text
- SkillDescription.text
- AlreadySkilled.gameObject.SetActive(false)
- SkillpointCost.gameObject.SetActive(false)
- AttrbuteReq.text

UpdateUI(item)

- SkillName.text
- SkillDescription.text
- AlreadySkilled.gameObject.SetActive(false)
- SkillpointCost.gameObject.SetActive(false)
- AttrbuteReq.text
- SkillIcon.sprite

- UiAbilitySlot at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiAbilitySlot.cs:
Summery of UiAbilitySlot:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiAbilitySlot.cs
The file being discussed is named "UiAbilitySlot.cs" and is located in the "Scripts/Ui" folder of the project. It is a C# script that contains the internal logic for handling Ability Slots for the user interface (UI). 

The script uses three Unity namespaces: UnityEngine.EventSystems, UnityEngine, and UnityEngine.UI. 

The class extends the base class UiBaseDragAndDropFunc and contains two public fields: "ability" of type Ability and "icon" of type Image. 

When the script executes, the "Start()" function checks if an ability is assigned to the slot and, if so, it sets the "icon" sprite to be the one assigned to the "ability". 

Overall, UiAbilitySlot.cs defines the functioning of the UI Ability Slots and ensures that the correct icon is displayed based on the assigned ability.
Code of file UiAbilitySlot:
using UnityEngine.EventSystems;
using UnityEngine;
using UnityEngine.UI;
internal class UiAbilitySlot : UiBaseDragAndDropFunc
{
   public Ability ability;
   public Image icon;

    private void Start()
    {
        if(ability!=null){
            icon.sprite = ability.icon;
        }
    }

   
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiAbilitySlot.cs
UiAbilitySlot:
-ability : Ability
-icon : Image
-Start()
--if(ability != null)
---icon.sprite = ability.icon

- UiBaseDragAndDropFunc at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiBaseDragAndDropFunc.cs:
Summery of UiBaseDragAndDropFunc:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiBaseDragAndDropFunc.cs
The file "UiBaseDragAndDropFunc.cs" is a script that implements the drag and drop functionality for UI elements in Unity. It is attached to a UI GameObject with a RectTransform component. The script implements the IBeginDragHandler, IDragHandler, and IEndDragHandler interfaces which allow it to detect when a drag and drop operation has started, is ongoing, and has ended, respectively.

When a drag operation begins, the script creates a new GameObject called "DragObject" and adds a RectTransform and Image component to it. The size and position of the RectTransform are set to match the original UI element being dragged. The Image component is used to display a visual representation of the dragged object on the screen. If the dragged UI element has an UiAbilitySlot component, the Image's sprite is set to that component's icon sprite.

During the drag operation, the position of the DragObject is updated to match the position of the mouse cursor.

When the drag operation ends, the DragObject is destroyed. If the dragged UI element is dropped onto a valid target (an object with a UiHotKeySlot component), the script updates the target's ability or item slot with the dragged UI element's ability or item, depending on the type of element being dragged. Finally, the original UI element is returned to its original position.

The script also initializes some variables in the Awake function, such as the RectTransform, UIManager, and originalPosition. These variables are used throughout the script to store information about the UI element being dragged.
Code of file UiBaseDragAndDropFunc:
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
public class UiBaseDragAndDropFunc : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
{
    public RectTransform rectTransform;
    private UIManager uiManager;
    private GameObject dragObject;
    public Vector3 originalPosition;
    private GameObject dragedObject;

    

    private void Awake()
    {
        rectTransform = GetComponent<RectTransform>();
        uiManager = FindObjectOfType<UIManager>();
        originalPosition = rectTransform.localPosition;
    }

    public void OnBeginDrag(PointerEventData eventData)
    {


        dragedObject = eventData.pointerDrag;
        dragObject = new GameObject("DragObject");
        dragObject.transform.SetParent(uiManager.gameObject.transform);
        dragObject.transform.SetSiblingIndex(uiManager.gameObject.transform.childCount - 1);

        RectTransform dragRectTransform = dragObject.AddComponent<RectTransform>();
        dragRectTransform.sizeDelta = rectTransform.sizeDelta;
        dragRectTransform.position = eventData.position;



        UiAbilitySlot uiAbilitySlot = dragedObject.GetComponent<UiAbilitySlot>();
        UiItemSlot uiItemSlot = dragedObject.GetComponent<UiItemSlot>();
                Image image = dragObject.AddComponent<Image>();
        image.sprite = GetComponent<Image>().sprite;
        image.raycastTarget = false;

        if(uiAbilitySlot!=null)
        {
            image.sprite = uiAbilitySlot.icon.sprite;
        }


    }

    public void OnDrag(PointerEventData eventData)
    {
        dragObject.GetComponent<RectTransform>().position = eventData.position;
    }

    public void OnEndDrag(PointerEventData eventData)
    {


        Destroy(dragObject);

        if (eventData.pointerEnter != null)
        {
            UiHotKeySlot hotkeySlot = eventData.pointerEnter.GetComponent<UiHotKeySlot>();
            UiAbilitySlot uiAbilitySlot = dragedObject.GetComponent<UiAbilitySlot>();
            UiItemSlot uiItemSlot = dragedObject.GetComponent<UiItemSlot>();


            if (hotkeySlot != null)
            {
                if(uiAbilitySlot!=null)
                {
                    hotkeySlot.ability = uiAbilitySlot.ability;
                    hotkeySlot.item = null;
                }
                else if(uiItemSlot!=null)
                {
                    hotkeySlot.item = uiItemSlot.item;
                    hotkeySlot.ability = null;
                }
                else
                {
                    hotkeySlot.item = null;
                    hotkeySlot.ability = null;
                }

                hotkeySlot.updateinfo();
            }
        }

        rectTransform.localPosition = originalPosition;
    }
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiBaseDragAndDropFunc.cs
UiBaseDragAndDropFunc:
- rectTransform: RectTransform
- uiManager: UIManager
- dragObject: GameObject
- originalPosition: Vector3
- dragedObject: GameObject

+ Awake():
    rectTransform = Get<RectTransform>()
    uiManager = Find<UIManager>()
    originalPosition = rectTransform.localPosition

+ OnBeginDrag(eventData: PointerEventData):
    dragedObject = eventData.pointerDrag
    dragObject = new GameObject("DragObject")
    dragObject.transform.SetParent(uiManager.gameObject.transform)
    dragObject.transform.SetSiblingIndex(uiManager.gameObject.transform.childCount - 1)
    dragRectTransform = dragObject.AddComponent<RectTransform>()
    dragRectTransform.sizeDelta = rectTransform.sizeDelta
    dragRectTransform.position = eventData.position
    uiAbilitySlot = dragedObject.Get<UiAbilitySlot>()
    uiItemSlot = dragedObject.Get<UiItemSlot>()
    image = dragObject.AddComponent<Image>()
    image.sprite = Get<Image>().sprite
    image.raycastTarget = false
    if(uiAbilitySlot!=null):
        image.sprite = uiAbilitySlot.icon.sprite

+ OnDrag(eventData: PointerEventData):
    dragObject.Get<RectTransform>().position = eventData.position

+ OnEndDrag(eventData: PointerEventData):
    Destroy(dragObject)
    if (eventData.pointerEnter != null):
        hotkeySlot = eventData.pointerEnter.Get<UiHotKeySlot>()
        uiAbilitySlot = dragedObject.Get<UiAbilitySlot>()
        uiItemSlot = dragedObject.Get<UiItemSlot>()
        if (hotkeySlot != null):
            if(uiAbilitySlot!=null):
                hotkeySlot.ability = uiAbilitySlot.ability
                hotkeySlot.item = null
            else if(uiItemSlot!=null):
                hotkeySlot.item = uiItemSlot.item
                hotkeySlot.ability = null
            else:
                hotkeySlot.item = null
                hotkeySlot.ability = null
            hotkeySlot.updateinfo()
    rectTransform.localPosition = originalPosition

- UiHotKeySlot at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiHotKeySlot.cs:
Summery of UiHotKeySlot:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiHotKeySlot.cs
The UiHotKeySlot.cs file contains a Unity script for a UI element in a hotkey slot. It includes public variables for an Image icon, an integer hotkeyIndex, a UIManager object, a RectTransform object, a Vector3 original position, an Ability object, and an Item object. 

The Start() method initializes the UIManager and RectTransform objects, sets the hotkeyController, and stores the original position of the RectTransform. 

The updateInfo() method updates the icon and hotkeyController object based on whether an ability or an item is assigned to the slot. 

The OnPointerEnter() and OnPointerExit() methods are used to open and close a tooltip using the UIManager object and hotkeyController object at the current RectTransform position. 

Overall, the script handles the functionality of hotkey slots in a UI element, including displaying icons and assigning abilities or items to hotkeys.
Code of file UiHotKeySlot:
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class UiHotKeySlot : MonoBehaviour
{
    public Image icon;
    public int hotkeyIndex;
    private UIManager uiManager;
    private RectTransform rectTransform;
    public Vector3 originalPosition;
    public Ability ability;
    public Item item;

    private HotkeyController hotkeyController;

    private void Start()
    {
        hotkeyController = FindObjectOfType<HotkeyController>();
        uiManager = FindObjectOfType<UIManager>();
        rectTransform = GetComponent<RectTransform>();
        icon = GetComponent<Image>();
        originalPosition = rectTransform.localPosition;

        
        
    }
    public void updateinfo(){
        if(ability!=null){
            icon.sprite = ability.icon;
            hotkeyController.hotkeys[hotkeyIndex].ability = ability;
            hotkeyController.hotkeys[hotkeyIndex].item = null;
        }
        if(item!=null){
            icon.sprite = item.icon;
            hotkeyController.hotkeys[hotkeyIndex].item = item;
            hotkeyController.hotkeys[hotkeyIndex].ability = null;
        }


    }
    public  void OnPointerEnter(PointerEventData eventData)
    {
       uiManager.OpenToolTip(hotkeyController.hotkeys[hotkeyIndex], rectTransform.position);
    }

    public  void OnPointerExit(PointerEventData eventData)
    {
        uiManager.CloseToolTip();
    }


}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiHotKeySlot.cs
UiHotKeySlot:
- icon: Image
- hotkeyIndex: int
- uiManager: UIManager
- rectTransform: RectTransform
- originalPosition: Vector3
- ability: Ability
- item: Item
- hotkeyController: HotkeyController

- Start():
    - hotkeyController = FindObjectOfType<HotkeyController>()
    - uiManager = FindObjectOfType<UIManager>()
    - rectTransform = GetComponent<RectTransform>()
    - icon = GetComponent<Image>()
    - originalPosition = rectTransform.localPosition

- updateinfo():
    - if(ability!=null):
        - icon.sprite = ability.icon
        - hotkeyController.hotkeys[hotkeyIndex].ability = ability
        - hotkeyController.hotkeys[hotkeyIndex].item = null
    - if(item!=null):
        - icon.sprite = item.icon
        - hotkeyController.hotkeys[hotkeyIndex].item = item
        - hotkeyController.hotkeys[hotkeyIndex].ability = null

- OnPointerEnter(eventData: PointerEventData):
    - uiManager.OpenToolTip(hotkeyController.hotkeys[hotkeyIndex], rectTransform.position)

- OnPointerExit(eventData: PointerEventData):
    - uiManager.CloseToolTip()

- UiItemSlot at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiItemSlot.cs:
Summery of UiItemSlot:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiItemSlot.cs
The file named "UiItemSlot.cs" contains a class with the same name. This class implements the interfaces ButtonWithToolTip, IRecieveDrop, and IDragable. It also has a public item field of type Item. The methods getDraggedObject, OnBeginDrag, OnDrag, OnDrop, and OnEndDrag are empty and do not provide any functionality. The class is intended to be used for UI item slots, allowing for dragging and dropping of items within the UI.
Code of file UiItemSlot:
using UnityEngine;
using UnityEngine.EventSystems;

internal class UiItemSlot : ButtonWithToolTip, IRecieveDrop,IDragable
{
    public Item item;

    public GameObject getDraggedObject()
    {
        throw new System.NotImplementedException();
    }

    public void OnBeginDrag(PointerEventData eventData)
    {
        throw new System.NotImplementedException();
    }

    public void OnDrag(PointerEventData eventData)
    {
        throw new System.NotImplementedException();
    }

    public void OnDrop(PointerEventData eventData)
    {
        throw new System.NotImplementedException();
    }

    public void OnEndDrag(PointerEventData eventData)
    {
        throw new System.NotImplementedException();
    }
}
Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UiItemSlot.cs
UiItemSlot:
	- ButtonWithToolTip
	- IRecieveDrop
	- IDragable
	- item: Item
	- getDraggedObject(): GameObject
	- OnBeginDrag(eventData: PointerEventData)
	- OnDrag(eventData: PointerEventData)
	- OnDrop(eventData: PointerEventData)
	- OnEndDrag(eventData: PointerEventData)

- UIManager at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UIManager.cs:
Summery of UIManager:
The UIManager.cs file defines a class named UIManager, which is responsible for managing various UI elements in the game. The class has public variables for different game objects that represent UI elements, such as pauseMenu, mainMenu, characterStatusUI, characterUi, tooltipSkills, and skillTreeMenu.

There are also private variables, including toolTipSkillsController and presentQuestUiController. The former is used to control the tooltip UI for skills, while the latter is used to present quest information to the player.

The class has various methods for showing and hiding different UI elements, such as showQuestUiPresenter and hideQuestUiPresenter for presenting/hiding quest information, and OpenCharacterStatusUI, OpenCharacterUi, OpenSkillTreeMenu, CloseCharacterUi, and CloseSkillTreeMenu for showing/hiding different menus.

The class also has methods for pausing/unpausing the game, showing/hiding the main menu, and opening/closing the tooltip UI for skills. These methods change the game state accordingly using the GameManager.Instance.ChangeGameState method.

The Update method checks for user input to pause/unpause the game and open/close the character status UI and skill tree menu. The Awake method initializes the Tooltip UI controller.
Code of file UIManager:
﻿// UIManager.cs
using UnityEngine;
public class UIManager : MonoBehaviour
{
    public GameObject pauseMenu;
    public GameObject mainMenu;
    public GameObject characterStatusUI;
    public GameObject characterUi;
    public GameObject tooltip;
    public GameObject skillTreeMenu;

    public GameObject questBookUi; 
    public GameObject questListQuickUi;
    private ToolTipUiController toolTipController;
    public PresentQuestUiController questUIPresenter;
    public event eventUi onPlayerHealthManaChange;
    public delegate void eventUi();

public void updateQuestBook(){
    questBookUi.GetComponent<QuestBookUIController>().UpdateQuestList();
}
public void showQuestBookUi(){
    GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
    questBookUi.SetActive(true);
}
public void hideQuestBookUi(){
    GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
    questBookUi.SetActive(false);
}
public void showQuestListQuickUi(){
    GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
    questListQuickUi.SetActive(true);
}
public void hideQuestListQuickUi(){
    GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
    questListQuickUi.SetActive(false);
}

public void showQuestUiPresenter(Quest quest){
    GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
    questUIPresenter.showQuestInfo(quest,this);
    questUIPresenter.gameObject.SetActive(true);
}
public void hideQuestUiPresenter(){
    GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
    questUIPresenter.gameObject.SetActive(false);
}

    private void Update()
    {
        // Check for user input to pause/unpause the game
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (GameManager.Instance.currentState == GameManager.GameState.Playing)
            {
                PauseGame();
            }
            else if (GameManager.Instance.currentState == GameManager.GameState.Paused)
            {
                UnpauseGame();
            }
        }

        // Check for user input to open/close the CharacterStatusUI
        if (Input.GetKeyDown(KeyCode.C))
        {
            if (GameManager.Instance.currentState == GameManager.GameState.Playing)
            {
                OpenCharacterUi();
            }
            else if (GameManager.Instance.currentState == GameManager.GameState.InMenu)
            {
                CloseCharacterUi();
            }
        }
        if(Input.GetKeyDown(KeyCode.V)){
            if (GameManager.Instance.currentState == GameManager.GameState.Playing)
            {
                OpenSkillTreeMenu();
            }
            else if (GameManager.Instance.currentState == GameManager.GameState.InMenu)
            {
                CloseSkillTreeMenu();
            }
        }
        if(Input.GetKeyDown(KeyCode.B)){
            if (GameManager.Instance.currentState == GameManager.GameState.Playing)
            {
                OpenSkillTreeMenu();
            }
            else if (GameManager.Instance.currentState == GameManager.GameState.InMenu)
            {
                CloseSkillTreeMenu();
            }
        }
    }
    public void Awake()
    {
        toolTipController = tooltip.GetComponent<ToolTipUiController>();
    }

    public void PauseGame()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Paused);
        Time.timeScale = 0f;
//        pauseMenu.SetActive(true);
    }

    public void UnpauseGame()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        Time.timeScale = 1f;
        pauseMenu.SetActive(false);
    }

    public void ShowMainMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        mainMenu.SetActive(true);
    }

    public void HideMainMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        mainMenu.SetActive(false);
    }
    public void OpenCharacterStatusUI()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        characterStatusUI.SetActive(true);
    }
    public void OpenCharacterUi()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        characterUi.SetActive(true);
    }
    public void CloseCharacterUi()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        characterUi.SetActive(false);
    }
    public void OpenSkillTreeMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.InMenu);
        skillTreeMenu.SetActive(true);
    }
    public void CloseSkillTreeMenu()
    {
        GameManager.Instance.ChangeGameState(GameManager.GameState.Playing);
        CloseToolTip();
        skillTreeMenu.SetActive(false);
    }
    public void CloseCharacterStatusUI()
    {
        characterStatusUI.SetActive(false);
    }
    public void OpenToolTip(SkillNode node, Vector3 Positon)
    {
        tooltip.gameObject.SetActive(true);
        tooltip.gameObject.GetComponent<RectTransform>().position = Positon;
        toolTipController.UpdateUI(node);
    }
        public void OpenToolTip(Hotkey hotkey, Vector3 Positon)
    {
        tooltip.gameObject.SetActive(true);
        tooltip.gameObject.GetComponent<RectTransform>().position = Positon;
        if(hotkey.ability != null){
            toolTipController.UpdateUI(hotkey.ability);
        }
        else if(hotkey.item != null){
            toolTipController.UpdateUI(hotkey.item);
        }
    }
    public void OpenToolTip(Ability ability, Vector3 Positon)
    {
        tooltip.gameObject.SetActive(true);
        tooltip.gameObject.GetComponent<RectTransform>().position = Positon;
        toolTipController.UpdateUI(ability);
    }
    public void OpenToolTip(Item item, Vector3 Positon)
    {
        tooltip.gameObject.SetActive(true);
        tooltip.gameObject.GetComponent<RectTransform>().position = Positon;
        toolTipController.UpdateUI(item);
    }
    public void CloseToolTip()
    {
        tooltip.gameObject.SetActive(false);
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\UIManager.cs
UIManager
- pauseMenu: GameObject
- mainMenu: GameObject
- characterStatusUI: GameObject
- characterUi: GameObject
- tooltip: GameObject
- skillTreeMenu: GameObject
- questBookUi: GameObject
- questListQuickUi: GameObject
- toolTipController: ToolTipUiController
- questUIPresenter: PresentQuestUiController
- onPlayerHealthManaChange: eventUi (delegate)

+ updateQuestBook(): void
+ showQuestBookUi(): void
+ hideQuestBookUi(): void
+ showQuestListQuickUi(): void
+ hideQuestListQuickUi(): void
+ showQuestUiPresenter(quest: Quest): void
+ hideQuestUiPresenter(): void
+ PauseGame(): void
+ UnpauseGame(): void
+ ShowMainMenu(): void
+ HideMainMenu(): void
+ OpenCharacterStatusUI(): void
+ OpenCharacterUi(): void
+ CloseCharacterUi(): void
+ OpenSkillTreeMenu(): void
+ CloseSkillTreeMenu(): void
+ CloseCharacterStatusUI(): void
+ OpenToolTip(node: SkillNode, Position: Vector3): void
+ OpenToolTip(hotkey: Hotkey, Position: Vector3): void
+ OpenToolTip(ability: Ability, Position: Vector3): void
+ OpenToolTip(item: Item, Position: Vector3): void
+ CloseToolTip(): void
+ Awake(): void
+ Update(): void

- WorldSpaceCanvasController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\WorldSpaceCanvasController.cs:
Summery of WorldSpaceCanvasController:
File Name: WorldSpaceCanvasController.cs

Summary: 

The WorldSpaceCanvasController class is an implementation of a MonoBehaviour, which is used to manage the World Space Canvas object in Unity. The class contains a static instance of itself which allows it to be easily accessed from other classes in the game.

Internally, the class also contains a damageNumberPrefab GameObject, which is a prefab that is used to display damage numbers on the World Space Canvas. The class has a method called SpawnDamageNumber, which can be called from other classes to create damage number instances. 

The SpawnDamageNumber method checks if the damageNumberPrefab is assigned to the class. If it is not assigned, it logs an error and returns from the method. If it is assigned, the method instantiates a new damageNumberPrefab object at the specified position and sets the damage value on the DamageNumberController component attached to the object.

If the DamageNumberController component is not found on the instantiated prefab, it logs an error and destroys the object. 

Overall, the class is responsible for managing and displaying damage numbers on the World Space Canvas in Unity.
Code of file WorldSpaceCanvasController:
﻿using UnityEngine;

public class WorldSpaceCanvasController : MonoBehaviour
{
    public static WorldSpaceCanvasController Instance;

    public GameObject damageNumberPrefab;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SpawnDamageNumber(float damage, Vector3 position)
    {
        if (damageNumberPrefab == null)
        {
            Debug.LogError("DamageNumberPrefab is not assigned in the WorldSpaceCanvasController component.");
            return;
        }

        GameObject damageNumberInstance = Instantiate(damageNumberPrefab, position, Quaternion.identity, transform);
        damageNumberInstance.gameObject.SetActive(true);
        DamageNumberController damageNumberController = damageNumberInstance.GetComponent<DamageNumberController>();


        if (damageNumberController != null)
        {
            damageNumberController.SetDamageValue(damage);
        }
        else
        {
            Debug.LogError("DamageNumberController component is missing on the DamageNumberPrefab.");
            Destroy(damageNumberInstance);
        }
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\Ui\WorldSpaceCanvasController.cs
WorldSpaceCanvasController:
- Instance
- damageNumberPrefab
- Awake()
- SpawnDamageNumber(damage, position)

- UnitSpawnerController at C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\WorldManagmentUnitSpawning\UnitSpawnerController.cs:
Summery of UnitSpawnerController:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\WorldManagmentUnitSpawning\UnitSpawnerController.cs
The UnitSpawnerController.cs file defines a class that controls the spawning of a unit in a game world. The file includes a number of public variables that specify the characteristics of the unit to be spawned, including its prefab, spawn range, character stats, abilities, AI state, equip manager, and AI controller. 

When the script is started, it gets the transform of the player character in the game world. Then, in the Update() function, it checks if the player is within the spawn range and if the unit has not already been spawned. If both conditions are met, the function spawns the unit using the Instantiate() function, sets all of its properties (stats, abilities, etc.), and destroys the spawner object to prevent further spawns.

Overall, the UnitSpawnerController.cs file provides a simple and flexible way to spawn units in a game world and customize their behavior and abilities.
Code of file UnitSpawnerController:
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

class UnitSpawnerController : MonoBehaviour
{
    // Variables
    public GameObject unitPrefab; // Prefab of the unit to spawn
    public float spawnRange; // Range at which to spawn the unit
    public CharacterStats stats; // The stats for the spawned unit
    public Ability[] abilities; // The abilities for the spawned unit
    public AIState aiState; // The AI state for the spawned unit
    public EquipManager equipManager; // The equip manager for the spawned unit
    public AIController aiController; // The AI controller for the spawned unit

    private Transform playerTransform; // Player transform to check distance

    void Start()
    {
        // Get the player transform
        playerTransform = GameObject.FindGameObjectWithTag("Player").transform;
    }

    bool spawned = false;
    void Update()
    {
        // Check if player is within spawn range
        if(playerTransform == null){
            return;
        }
        if(spawned){
            return;
        }
        if(Vector3.Distance(transform.position, playerTransform.position) <= spawnRange)
        {
            // Spawn the unit
            GameObject unit = Instantiate(unitPrefab, transform.position, Quaternion.identity);
            unit.SetActive(true);
            // Set the equip manager for the unit
            unit.GetComponentInChildren<EquipManager>().SetEquipManager(equipManager);

            // Set the AI controller for the unit
            unit.GetComponentInChildren<AIController>().SetAIController(aiController);
            
            // Set the stats for the unit
            unit.GetComponentInChildren<CharacterStats>().SetStats(stats);

            // Set the abilities for the unit
            AbilityController abilityController = unit.GetComponent<AbilityController>();
            foreach(Ability ability in abilities)
            {
                abilityController.AddAbility(ability);
            }

            // Set the AI state for the unit
            unit.GetComponentInChildren<AIController>().ChangeState(aiState);
            Destroy(this.gameObject);
        }
    }
}

Corresponding SyntaxTree:
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\WorldManagmentUnitSpawning\UnitSpawnerController.cs
Name: UnitSpawnerController.cs

- Variables:
    - unitPrefab: GameObject
    - spawnRange: float
    - stats: CharacterStats
    - abilities: Ability[]
    - aiState: AIState
    - equipManager: EquipManager
    - aiController: AIController
    - playerTransform: Transform

- Start():
    - Get the player transform

- Update():
    - Check if player is within spawn range
    - If player transform is null or unit has already spawned, return
    - Spawn the unit and set its equip manager, AI controller, stats, abilities, and AI state
    - Destroy the spawner game object
