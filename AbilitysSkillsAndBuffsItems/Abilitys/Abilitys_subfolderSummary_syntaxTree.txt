C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityControllData.cs
Unfortunately, as an AI language model, I am unable to generate detailed syntax trees of each class in C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityControllData.cs, including the internal logic of each method. However, I can explain the basic structure and purpose of the code.

The code defines a class named AbilityControllData, which has four public properties: type (a string), direction (a Vector3), target (a GameObject), and targetPosition (another Vector3). These properties are used to store data related to controlling an ability in a game.

There are no methods defined in this class, so there is no internal logic to describe. Instead, this class serves as a data structure that can be used by other parts of the game to store and retrieve information about abilities and their controls.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityModifierManager.cs
AbilityModifierManager:
-ScriptableObject
--private List<AbilityModifiers> modifierList
--private AbilityStats abilityStats

--private void OnEnable()
---abilityStats = new AbilityStats()

+public string printAllModifiers()
+public void AddModifier(AbilityModifiers modifiers)
+public void RemoveModifier(AbilityModifiers modifier)
+public AbilityStats GetAdditionalModifiedValue()
+public AbilityStats CalculateModifiedValue()

printAllModifiers:
-string s
-foreach (AbilityModifiers modifier in modifierList)
--s += " - " + modifier.modifierName + " - " + "\n"
--s += modifier.modifierDescription + "\n"
--s += modifier.abilityStats.printStats()
-return s

AddModifier:
-ModifierList.Add(modifiers)
-CalculateModifiedValue()

RemoveModifier:
-modifierList.Remove(modifier)
-CalculateModifiedValue()

GetAdditionalModifiedValue:
-return abilityStats

CalculateModifiedValue:
-abilityStats.setZero()
-foreach (AbilityModifiers modifier in modifierList)
--modifier.ApplyModifier(ref abilityStats)
-return abilityStats
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityModifier.cs
File: AbilityModifier.cs

Class: AbilityModifiers
- public string modifierName;
- public string modifierDescription;
- public char operation;
- public AbilityStats abilityStats;

- public AbilityModifiers(string modifierName="Default", string modifierDescription="")
    - this.modifierName = modifierName;
    - this.modifierDescription = modifierDescription;
    - abilityStats = new AbilityStats();

- public virtual void ApplyModifier(ref AbilityStats abilityStats)
    - abilityStats.addStats(this.abilityStats);

Syntax Tree:
AbilityModifiers
├── modifierName
├── modifierDescription
├── operation
├── abilityStats
│   ├── AbilityStats
│   ├── ...
│   └── ...
├── AbilityModifiers(string modifierName="Default", string modifierDescription="")
│   ├── this.modifierName = modifierName
│   ├── this.modifierDescription = modifierDescription
│   ├── abilityStats = new AbilityStats()
│   ├── ...
│   └── ...
└── ApplyModifier(ref AbilityStats abilityStats)
    ├── abilityStats.addStats(this.abilityStats)
    ├── ...
    └── ...
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityObject.cs
Unfortunately, as an AI language model, I cannot generate an image of a syntax tree. However, I can provide a textual description of the syntax tree for each class in the given file. 

For class AbilityObject:
- The class declaration has 3 events: OnUpdate, OnSpawn, OnDelete, and 1 event with a GameObject parameter: OnHit
- The class has a public field data of type AbilityData
- The class has two public boolean fields: shouldDestroy and deleteOnCollision
- The class has two public float fields: timerMax and timer, and a boolean field deleteOnTimer
- The class has a public property ParentAbility of type Ability
- The class has a private method HandleOnHit with a parameter of type GameObject
- The class has a public method Delete()
- The class has an implementation of the Unity method Awake()
- The class has a list alreadyHit of tuples containing a GameObject and a float value, and a list alreadyHitRemoveIndeces of integers
- The class has two OnTrigger methods: OnTriggerEnter() and OnTriggerStay()
- The class implements three interfaces: IBouncingAbilityObject, IPiercingAbilityObject, IHomingAbilityObject

For interface IBouncingAbilityObject:
- The interface declares properties BounceIntensity and BounceDuration of type float
- The interface declares a method Bounce with a parameter of type GameObject

For interface IPiercingAbilityObject:
- The interface declares a method Pierce with a parameter of type GameObject

For interface IHomingAbilityObject:
- The interface declares a method Home with a parameter of type GameObject
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityStats.cs
AbilityStats class:

                      AbilityStats
                           |
                           |
                 ---------------------
                 |                   |
             float               float
                 |                   |
       baseDamage         strengthScaling
                 |                   |
       -------------------     -------------------
       |                 |     |                 |
   float            float       float         float
       |                 |     |                 |
intelligenceScaling cooldown     manaCost      range
       |                                       |
    float                                 float
       |                                       |
  projectileSpeed                         stunDuration

Methods:

- AbilityStats(): constructor method that takes no arguments.
- setZero(): method that sets all of the AbilityStats' float variables to 0.
- addStats(): method that takes another AbilityStats object as an argument and adds its values to the current AbilityStats object.
- printStats(): method that prints out the values of all the non-zero AbilityStats variables, formatted as a string. If a variable has a value of 0, it is not included in the string. Returns the string.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\Ability.cs
Unfortunately, as an AI language model, I am not able to generate syntax trees. However, I can provide an overview of the classes and their methods:

- Ability: This is an abstract class that extends ScriptableObject and represents the base class for all abilities. It contains properties for ability name, description, icon, stats, modifiers, animation, and timing. It also has methods for updating ability stats, adding and removing modifiers, activating the ability, and handling events related to ability object spawning, hitting, and activation.

- AbilityData: This is a data class that contains information about an ability and its context, such as the target object, caster stats, controller, position, and damage. It also has a method for creating a clone of the ability data object.

- AnimingMode: This is an enum that specifies the animation mode for an ability, which can be Default or PrePositionPlacement.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ChainLightning.cs
ChainLightning.cs

- using UnityEngine;
- using System.Collections.Generic;
- [CreateAssetMenu(menuName = "Abilities/ChainLightningAbility")]

public class ChainLightning : Ability {

    - public int maxBounceCount = 5;
    - public float bounceRange = 5f;
    - public GameObject chainLightningPrefab;
    - public Material lineMaterial;

    - [SerializeField]
    - private float ChainLightningTickness = 1f;

    - public override void Activate(AbilityData abilityData) {
        - Transform firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint;

        - AbilityObject abilityObject = Instantiate(chainLightningPrefab, firePoint.transform.position, firePoint.transform.rotation).GetComponent<AbilityObject>();
        - if(abilityObject == null) {
            - Debug.LogError("AbilityObject is null");
        }
        - abilityObject.data = abilityData;
        - abilityObject.ParentAbility = this;
    }

    - public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target) {
        - VisualEffectController visualEffectController = target.GetComponent<VisualEffectController>();
        - HealthController healthController = target.GetComponent<HealthController>();
        - if (healthController != null) {
            - healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject);
            - visualEffectController.SpawnEffect("LightningHitWeak",1.4f,effectUnitPosition.underFeet);
        }
        - List<GameObject> hitTargets = new List<GameObject> { target };
        - Vector3 lastPosition = abilityObject.transform.position;
        - for (int i = 0; i < maxBounceCount; i++) {
            - Collider[] colliders = Physics.OverlapSphere(lastPosition, bounceRange);
            - GameObject newTarget = null;
            - foreach (Collider collider in colliders) {
                - if (!hitTargets.Contains(collider.gameObject) && collider.gameObject.GetComponent<HealthController>() != null && collider.gameObject != abilityObject.data.CasterStats.gameObject) {
                    - newTarget = collider.gameObject;
                    - hitTargets.Add(newTarget);
                    - break;
                }
            }

            - if (newTarget != null) {
                - target = newTarget;
                - healthController = target.GetComponent<HealthController>();
                - visualEffectController = target.GetComponent<VisualEffectController>();
                - if (healthController != null) {
                    - healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject);
                    - visualEffectController.SpawnEffect("LightningHitWeak",1.4f,effectUnitPosition.underFeet);
                }
                
                - GameObject lineObject = new GameObject();
                - LineRenderer lineRenderer = lineObject.AddComponent<LineRenderer>();
                - lineRenderer.material = lineMaterial;
                - lineRenderer.startWidth = ChainLightningTickness;
                - lineRenderer.endWidth = ChainLightningTickness;
                - lineRenderer.positionCount = 2;
                - lineRenderer.SetPosition(0, lastPosition);
                - lineRenderer.SetPosition(1, visualEffectController.positionStomach.position);
                - Destroy(lineObject, 0.3f);

                - lastPosition = visualEffectController.positionStomach.position;
            } 
            - else {
                - break;
            }
        }
    }
}
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultSkill.cs
Unfortunately, as an AI language model and unable to view the dependencies which the code is tied to, I cannot provide a detailed syntax tree of each class in the mentioned file without an error. However, I can give a brief explanation of the code.

This code is a C# script, using Unity's 'CreateAssetMenu' attribute to create an Asset menu for the Skill class. This script is a child of the Skill class and has the same name as its file, 'DefaultSkill.cs'. It does not have any methods or logic of its own, but instead inherits all of its properties and behaviors from the parent class, Skill.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\FireBall.cs
Syntax Tree:

FireBall
- DefaultProjectileAbility
  - Ability (abstract)
    - ScriptableObject
      - Object
        - ValueType
- OnAbilityObjectHit (virtual method)
  - parameter abilityObject: AbilityObject
  - parameter target: GameObject
  - if (abilityObject.data.CasterStats != null)
    - targetHealth = target.GetComponent<HealthController>();
    - if (targetHealth != null)
      - damage = abilityObject.data.damage;
      - targetHealth.TakeDamage(damage, abilityObject.data.CasterStats.gameObject);
  - RaiseOnObjectHit(abilityObject, target)
- Activate (abstract method)
  - parameter abilityData: AbilityData
  - if (abilityData.CasterStats == null) return
  - firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint
  - projectileInstance = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation)
  - abilityObject = projectileInstance.GetComponent<BaseProjectileObject>()
  - RaiseOnObjectSpawned(abilityObject, null)
  - rb = projectileInstance.GetComponent<Rigidbody>()
  - rb.velocity = firePoint.forward * abilityData.projectileSpeed
  - abilityObject.ParentAbility = this
  - abilityObject.data = abilityData

The FireBall class extends the DefaultProjectileAbility class, which in turn implements the Ability abstract class. The Ability class is a ScriptableObject that inherits from Object and therefore from ValueType.

The class has two methods, OnAbilityObjectHit and Activate, both of which override abstract methods defined in the parent classes.

In the OnAbilityObjectHit method, the abilityObject parameter is used to access the caster stats and damage values. If the target object has a HealthController component, its TakeDamage method is called with the damage and the caster's game object as parameters. Afterwards, the RaiseOnObjectHit event is triggered.

The Activate method is responsible for instantiating and configuring a projectile object. First, it checks if the caster stats are not null, returning early if they are. Then, it retrieves the fire point transform from the caster's AbilityController component. It instantiates a projectile prefab at that position and rotation, gets its BaseProjectileObject component, and sets the ParentAbility and data properties of the abilityObject. Finally, it retrieves the Rigidbody component and sets its velocity based on the fire point direction and the projectile speed. The RaiseOnObjectSpawned event is triggered with the abilityObject parameter.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\FrostBolt.cs
[CreateAssetMenu(menuName = "Abilities/FrostBolt")]
- Initializes a new asset menu item for the FrostBolt class in Unity's editor.

public class FrostBolt : DefaultProjectileAbility
- Defines a public class FrostBolt that extends the DefaultProjectileAbility class.

public Buff chillBuff;
- Defines a public variable chillBuff of type Buff.

public void OnEnable()
- A public method that sets up the variables for the class.
- Creates a new Chill Buff with the BuffFactory, assigning stat modifiers and duration.
- Sets the abilityName and abilityDescription for FrostBolt.

public override void Activate(AbilityData abilityData)
- Overrides the Activate() method of the DefaultProjectileAbility class.
- Calls the base method of Activate() with the ability data passed into it.

public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
- Overrides the OnAbilityObjectHit method of the DefaultProjectileAbility class.
- Calls the base method of OnAbilityObjectHit() with the abilityObject and target passed into it.
- Debug.Logs "FrostBolt hit".
- Checks if the ability object has a CasterStats component.
- If so, attempts to retrieve the target's HealthController component.
- If found, deals damage to the target and applies a Chill buff to it using the BuffSystem and CasterStats.
- Debug.Logs "Applying Chill buff".
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\LivingBombAbility.cs
LivingBombAbility class syntax tree:

LivingBombAbility
-DefaultAbility
--Ability
---ScriptableObject
+firstExplosionAbility: LivingBombFirstExplosion
+secondExplosionAbility: LivingBombSecondExplosion
+livingBombBuff: LivingBombBuff
+livingBombSecondBuff: LivingBombSecondBuff
+abilityObjectFirstExplostionPrefab: GameObject
+abilityObjectSecondExplostionPrefab: GameObject
-Awake()
--base.Awake()
--abilityName = "Living Bomb"
--abilityDescription = "This is a living bomb ability"
--BaseAbilityStats.cooldown = 10
--BaseAbilityStats.intelligenceScaling = 1
--livingBombBuff = CreateInstance<LivingBombBuff>()
--livingBombSecondBuff = CreateInstance<LivingBombSecondBuff>()
--firstExplosionAbility = CreateInstance<LivingBombFirstExplosion>()
---firstExplosionAbility.abilityObjectFirstExplostionPrefab = abilityObjectFirstExplostionPrefab
---firstExplosionAbility.secondBombBuff = livingBombSecondBuff
--secondExplosionAbility = CreateInstance<LivingBombSecondExplosion>()
---secondExplosionAbility.abilityObjectSecondExplostionPrefab = abilityObjectSecondExplostionPrefab
--livingBombBuff.firstExplosionAbility = firstExplosionAbility
--livingBombSecondBuff.secondExplosionAbility = secondExplosionAbility
-Activate(AbilityData abilityData)
--targetBuffSystem = abilityData.Target.GetComponent<BuffSystem>()
--casterBuffSystem = abilityData.CasterStats.GetComponent<BuffSystem>()
--if targetBuffSystem != null
---targetBuffSystem.AddBuff(livingBombBuff, abilityData.Target, casterBuffSystem)
-OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)

LivingBombBuff class syntax tree:

LivingBombBuff
-Buff
+firstExplosionAbility: Ability
-InvokeOnFade(BuffInstance buffInstance, GameObject target)
--base.InvokeOnFade(buffInstance, target)
--abilityData = new AbilityData { CasterStats = buffInstance.target.GetComponent<CharacterStats>(), Target = buffInstance.target }
--firstExplosionAbility.Activate(abilityData)
+InvokeOnApply(BuffInstance buffInstance, GameObject target)

LivingBombFirstExplosion class syntax tree:

LivingBombFirstExplosion
-Ability
+abilityObjectFirstExplostionPrefab: GameObject
+secondBombBuff: Buff
+-casterBuffSystem: BuffSystem
-OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
--targetBuffSystem = target.GetComponent<BuffSystem>()
--casterBuffSystem = abilityObject.data.CasterStats.GetComponent<BuffSystem>()
--if targetBuffSystem != null
---targetBuffSystem.AddBuff(secondBombBuff, target, casterBuffSystem)
-Activate(AbilityData abilityData)
--abiltiyObject = GameObject.Instantiate(abilityObjectFirstExplostionPrefab, abilityData.Target.transform.position, Quaternion.identity).GetComponent<AbilityObject>()
--abiltiyObject.data = abilityData
--abiltiyObject.ParentAbility = this

LivingBombSecondBuff class syntax tree:

LivingBombSecondBuff
-Buff
+secondExplosionAbility: Ability
-InvokeOnFade(BuffInstance buffInstance, GameObject target)
--base.InvokeOnFade(buffInstance, target)
--abilityData = new AbilityData { CasterStats = buffInstance.target.GetComponent<CharacterStats>(), Target = buffInstance.target }
--secondExplosionAbility.Activate(abilityData)

LivingBombSecondExplosion class syntax tree:

LivingBombSecondExplosion
-Ability
+abilityObjectSecondExplostionPrefab: GameObject
-OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
--healthController = target.GetComponent<HealthController>()
--if healthController != null
---healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject)
-Activate(AbilityData abilityData)
--abilityObject = Instantiate(abilityObjectSecondExplostionPrefab, abilityData.Target.transform.position, Quaternion.identity).GetComponent<AbilityObject>()
--abilityObject.data = abilityData
--abilityObject.ParentAbility = this
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ShieldBash.cs
(Sorry, as an AI language model, I am not able to display an image or structure such as syntax tree, but I can provide further information about each method within the ShieldBash class)

Explanation: The ShieldBash class is a C# script that inherits from the DefaultAbility class. The purpose of this class is to define the behavior and logic of a Shield Bash ability. 

Variables:
- prefabAbilityObject: A GameObject that represents the visual effect of the ability.
- abilityName: A string that represents the name of the ability.
- baseDamage: An integer that represents the base amount of damage inflicted by the ability.
- strengthScaling: A float that represents the scaling ratio of the ability based on the caster's strength attribute.
- intelligenceScaling: A float that represents the scaling ratio of the ability based on the caster's intelligence attribute.
- animationName: A string that represents the name of the animation played when the ability is used.
- stunDuration: A float that represents the duration of the stun effect applied by the ability.

Awake():
- This method overrides the Awake method of the base class and is invoked when the ShieldBash object is instantiated.
- It sets the values of the variables mentioned above to the desired values.

OnAbilityObjectHit():
- This method is overridden from the base class and is invoked when the ability hits a target object.
- It checks if the caster of the ability has stats, and if the target object has a HealthController component.
- If both conditions are true, it calculates the damage based on baseDamage, strengthScaling, and intelligenceScaling, and applies it to the target's HealthController component.
- If the stunDuration is greater than or equal to 0, it applies a stun effect to the target using the Stun method of the IStunnable interface.
- It then raises an event to signal that the ability hit an object.

Activate():
- This method is also overridden from the base class and is invoked when the ability is activated.
- It checks if the caster of the ability has stats, and if not, it returns and does nothing.
- It gets the forward direction of the caster and creates an instance of the prefabAbilityObject at the caster's position with the proper rotation.
- It then gets the Rigidbody component of the instance and sets its velocity to the forward direction multiplied by the projectileSpeed of the abilityData.
- It sets some data related to the ability on the abilityObject's data field, including the duration of the stun effect. 
- It then raises an event to signal that the ability object was spawned.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\SimpleStrike.cs
(Since this is just one class, there will only be one syntax tree)

```
SimpleStrike.cs
├── [CreateAssetMenu(menuName = "Abilities/SimpleStrike")]
├── public class SimpleStrike : DefaultAbility
│   ├── public GameObject MeelePrefab;
│   ├── public float lifeTime = 0.5f;
│   ├── public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
│   │   ├── HealthController healthController = target.GetComponent<HealthController>();
│   │   ├── if (healthController != null)
│   │   │   ├── healthController.TakeDamage(abilityObject.data.damage,abilityObject.data.CasterStats.gameObject);
│   ├── public override void Activate(AbilityData abilityData)
│       ├── GameObject meleeStrikeInstance = Instantiate(MeelePrefab, abilityData.CasterController.firePoint.position, Quaternion.identity);
│       ├── AbilityObject abilityObject = meleeStrikeInstance.GetComponent<AbilityObject>();
│       │   ├── abilityObject.ParentAbility = this;
│       │   └── abilityObject.data = abilityData;
│       └── Destroy(meleeStrikeInstance, lifeTime);
```
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultAbility.cs
(DefaultAbility.cs)
	
DefaultAbility
	|
	|--- public void Awake()
	|	|--- Set abilityName to "Default"
	|	|--- Set abilityDescription to "Default"
	|
	|--- public void OnEnable()
	|	|--- Check if BaseAbilityStats is null, if yes, create an instance of AbilityStats and assign it to BaseAbilityStats
	|	|--- Check if TotalAbilityStats is null, if yes, create an instance of AbilityStats and assign it to TotalAbilityStats
	|	|--- Check if abilityModifierManager is null, if yes, create an instance of AbilityModifierManager and assign it to abilityModifierManager
	|	|--- Call updateAbilityStats()
	|
	|--- public override void Activate(AbilityData abilityData)
	|	|--- Print "Default Ability" to the console using Debug.Log()
	|
	|--- public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
	|	|--- Do nothing
	|
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultAuraAbility.cs
(DefaultAuraAbility.cs)

- DefaultAuraAbility
  - Inherits from DefaultAbility
  - Public Variables
    - auraPrefab: GameObject
    - damageInterval: float
  - Private Variables
    - lastDamageTime: float
    - abilityObject: AbilityObject
  - Methods
    - OnEnable(): void
      - Calls BaseAbilityStats = new AbilityStats()
      - Calls TotalAbilityStats = new AbilityStats()
      - Sets BaseAbilityStats.cooldown to 2
      - Calls updateAbilityStats()
      - Sets animingMode to AnimingMode.PrePositionPlacement
    - Activate(abilityData: AbilityData): void
      - Logs "Activate"
      - Sets useUpdate to true
      - Instantiates auraPrefab at the position of abilityData.Target with a Quaternion.identity rotation, and gets the AbilityObject component from it and assigns it to abilityObject
      - Sets abilityObject.data to abilityData
      - Sets abilityObject.ParentAbility to this
      - Subscribes DeactivateUpdate to abilityObject.OnDelete event
    - OnAbilityObjectHit(abilityObject: AbilityObject, target: GameObject): void
      - If timestart is 0, sets it to Time.time
      - Gets HealthController component from target as healthController variable
      - If healthController is not null, calls healthController.TakeDamage with parameters abilityObject.data.damage and abilityObject.data.CasterStats.gameObject
    - OnUpdate(): void
    - DeactivateUpdate(): void
      - Sets useUpdate to false
    - Deactivate(): void
      - If abilityObject is not null, calls abilityObject.Delete()
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultComboAbility.cs
(DefaultComboAbility.cs)

Class: DefaultComboAbility

Properties:
- MeelePrefab: GameObject
- lifeTime: float
- comboDamage: float[]

Methods:
+ OnAbilityObjectHit(abilityObject: AbilityObject, target: GameObject): void
+ PreActivateAbility(abilityData: AbilityData): void
+ Activate(abilityData: AbilityData): void

OnAbilityObjectHit(abilityObject, target):
1. Get the HealthController component from the target GameObject.
2. If HealthController exists, call its TakeDamage method with parameters of abilityObject's data.damage and abilityObject's data.CasterStats.gameObject.

PreActivateAbility(abilityData):
1. Get the ComboController component from abilityData's CasterCombatController property.
2. Set the comboName variable to "ThreeHitComboAbility".
3. Get the comboCount variable from comboController's GetComboCounter method with parameter of comboName, minus 1.
4. If comboCount is less than 2, call comboController's IncreaseComboCounter method with parameter of comboName.
5. Else, call comboController's ResetComboCounter method with parameter of comboName.
6. Add to abilityData's damage the value of comboDamage at index of comboCount, BaseAbilityStats.baseDamage, and abilityModifierManager's GetAdditionalModifiedValue() method's baseDamage property.
7. Depending on comboCount value, set animationName variable to "1HandSwordLightAttack1", "1HandSwordLightAttack2", or "1HandSwordLightAttack3".

Activate(abilityData):
1. Instantiate a new object of MeelePrefab at the position and rotation of abilityData's CasterStats transform location.
2. Get its AbilityObject component and set its data property to abilityData.
3. Call RaiseOnObjectSpawned event with parameters of abilityObject and null.
4. Set abilityObject's ParentAbility to this class instance.
5. Destroy the meleeStrikeInstance object after lifeTime seconds.
6. Log "Activate".
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultGroupBuffAbility.cs
(DefaultGroupBuffAbility) -> Ability
  -buff: Buff
  -radius: float
  +Activate(abilityData: AbilityData): void
  +OnAbilityObjectHit(abilityObject: AbilityObject, target: GameObject): void
  +OnEnable(): void
  -aIController: AIController
  -playerController: PlayerController
  -buffSystem: BuffSystem

Activate(abilityData: AbilityData): void
  -abilityName: string = "DefaultGroupBuffAbility"
  -abilityDescription: string = "This is a DefaultGroupBuffAbility"
  -BaseAbilityStats.cooldown: int = 10
  -BaseAbilityStats.intelligenceScaling: int = 1
  -colliders: Collider[] = Physics.OverlapSphere(abilityData.CasterStats.transform.position, radius)
  -casterBuffSystem: BuffSystem = abilityData.CasterStats.GetComponent<BuffSystem>()
  foreach (Collider collider in colliders)
  {
    buffSystem = collider.gameObject.GetComponent<BuffSystem>()
    if (buffSystem == null)
    {
      continue
    }
    aIController = collider.gameObject.GetComponent<AIController>()
    playerController = collider.gameObject.GetComponent<PlayerController>()
    if (aIController != null)
    {
      if (aIController.aggroTag == "Player")
      {
        continue
      }
      buffSystem.AddBuff(buff, collider.gameObject, casterBuffSystem)
      continue
    }
    else if (playerController != null)
    {
      buffSystem.AddBuff(buff, collider.gameObject, casterBuffSystem)
      continue
    }
  }

OnEnable(): void
  buff = BuffFactory.CreateBuff("Default Self Buff", 5f, true, 3, new StatsModifier(criticalDamage: 10))
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultProjectileAbility.cs
Not included as it is not present in the given file.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultSelfBuffAbility.cs
The syntax tree for DefaultSelfBuffAbility.cs:

- using UnityEngine;
  - imports the UnityEngine package

- [CreateAssetMenu(menuName = "Abilities/DefaultSelfBuffAbility")]
  - a custom editor attribute that creates a menu item in the Unity editor for creating a new DefaultSelfBuffAbility asset

- public class DefaultSelfBuffAbility : Ability
  - a public class that inherits from the Ability class

- public Buff buff;
  - a public Buff variable representing the buff that this ability will apply

- void OnEnable()
  - an event method that is called when the script is enabled
  - creates a new Buff object with the name "Default Self Buff", duration of 5 seconds, true for self-targeting, 3 as the maximum stack count, and a StatsModifier object with a critical damage value of 10

- public override void Activate(AbilityData abilityData)
  - a public method that overrides the Activate method of the Ability class
  - assigns values to the abilityName, abilityDescription, BaseAbilityStats.cooldown, and BaseAbilityStats.intelligenceScaling variables
  - checks if the CasterStats attribute of the abilityData object is null, logs an error and returns if it is
  - gets the BuffSystem component from the caster's stats, logs an error and returns if it is null
  - adds the buff to the BuffSystem component of the caster's stats game object

- public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
  - a public method that overrides the OnAbilityObjectHit method of the Ability class, but does not contain any logic
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityObejcts\BaseProjectileObject.cs
BaseProjectileObject:
- public class
- Inherits from AbilityObject, IBouncingAbilityObject, IPiercingAbilityObject
- Implements BounceIntensity and BounceDuration properties

Methods:
- HandleOnHit(target: GameObject)
  - Protected method
  - Takes in a target GameObject parameter
  - Applies damage to the target if available
  - Determines whether bounceCount or pierceCount is greater, then executes Bounce or Pierce methods respectively
  - Handles object deletion if necessary

- Bounce(target: GameObject)
  - Public method
  - Takes in a target GameObject parameter
  - Reflects transform forward based on target transform up
  - Sets Rigidbody velocity based on new transform forward and projectile speed
  - Decrements bounceCount

- Pierce(target: GameObject)
  - Public method
  - Takes in a target GameObject parameter
  - Decrements pierceCount

Properties:
- BounceIntensity: float
- BounceDuration: float
- bounceCount: int
- pierceCount: int
