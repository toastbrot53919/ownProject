C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ChainLightning.cs
Filename: ChainLightning.cs

Syntax tree:

- using UnityEngine;
- using System.Collections.Generic;

- [CreateAssetMenu(menuName = "Abilities/ChainLightningAbility")]
- public class ChainLightning : Ability

- public int maxBounceCount = 5;
- public float bounceRange = 5f;
- public GameObject chainLightningPrefab;
- public Material lineMaterial;
- [SerializeField] private float ChainLightningTickness = 1f;

- public override void Activate(AbilityData abilityData)

- Transform firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint;
- AbilityObject abilityObject = Instantiate(chainLightningPrefab, firePoint.transform.position, firePoint.transform.rotation).GetComponent<AbilityObject>();
- if (abilityObject == null) { Debug.LogError("AbilityObject is null"); }
- abilityObject.data = abilityData;
- abilityObject.ParentAbility = this;

- public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)

- VisualEffectController visualEffectController = target.GetComponent<VisualEffectController>();
- HealthController healthController = target.GetComponent<HealthController>();
- if (healthController != null) {

- healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject);
- visualEffectController.SpawnEffect("LightningHitWeak", 1.4f, effectUnitPosition.underFeet);

- List<GameObject> hitTargets = new List<GameObject> { target };
- Vector3 lastPosition = abilityObject.transform.position;

- for (int i = 0; i < maxBounceCount; i++)

- Collider[] colliders = Physics.OverlapSphere(lastPosition, bounceRange);
- GameObject newTarget = null;
- foreach (Collider collider in colliders)

- if (!hitTargets.Contains(collider.gameObject) && collider.gameObject.GetComponent<HealthController>() != null && collider.gameObject != abilityObject.data.CasterStats.gameObject) {

- newTarget = collider.gameObject;
- hitTargets.Add(newTarget);
- break;

- }
- if (newTarget != null) {

- target = newTarget;
- healthController = target.GetComponent<HealthController>();
- visualEffectController = target.GetComponent<VisualEffectController>();
- if (healthController != null) {

- healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject);
- visualEffectController.SpawnEffect("LightningHitWeak", 1.4f, effectUnitPosition.underFeet);

- }
- GameObject lineObject = new GameObject();
- LineRenderer lineRenderer = lineObject.AddComponent<LineRenderer>();
- lineRenderer.material = lineMaterial;
- lineRenderer.startWidth = ChainLightningTickness;
- lineRenderer.endWidth = ChainLightningTickness;
- lineRenderer.positionCount = 2;
- lineRenderer.SetPosition(0, lastPosition);
- lineRenderer.SetPosition(1, visualEffectController.positionStomach.position);
- Destroy(lineObject, 0.3f);
- lastPosition = visualEffectController.positionStomach.position;

- } else { break; }

Explanation:

- The ChainLightning class is defined, which inherits from the Ability class.
- Several public fields are declared to set values such as the maximum number of bounces or the range in which lightning can jump between targets. A prefab for the lightning effect and a material for the line renderer are also declared.
- A private field for the thickness of the lightning effect is marked as serializable so that it can be modified in the Unity inspector.
- An override method is implemented for when the ability is activated. This instantiates the lightning effect and assigns necessary data to the ability object.
- Another override method is implemented for when the ability object hits a target. In this method, damage is dealt to the target and a visual effect is spawned. The method then checks nearby colliders to see if the lightning can jump to another target. If so, damage is dealt to that target and another visual effect is spawned. A line renderer is created to connect the two targets together to create the appearance of lightning. This process is repeated up to the maximum number of bounces or until there is no target to jump to.