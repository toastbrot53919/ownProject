C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\IStatsProvider.cs
(IStatsProvider)
        |
   (interface)
        |
  (GetCharacterStats)
        |
    (return)
        |
(CharacterStats)
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\SkillTree.cs
Script: SkillTree.cs

Syntax tree:

ScriptableObject
|- SkillTree 
   |- List<SkillNode> skillNodes
   |- SkillTree() 
   |  |- skillNodes = new List<SkillNode>()
   |- void AddSkillNode(SkillNode skillNode)
   |  |- skillNodes.Add(skillNode)
   |- bool IsVisible(SkillNode skillNode)
   |  |- return true
   |- void Awake()
   |  |- resetAllNodes()
   |- void resetAllNodes()
      |- foreach(SkillNode node in skillNodes)
      |  |- node.isUnlocked = false


Internal Logic:

- SkillTree class extends ScriptableObject and has a public List of SkillNodes and a parameterless constructor.
- SkillTree has a public method AddSkillNode which receives a SkillNode object and add it to the list of skillNodes.
- SkillTree has an internal method IsVisible which receives a SkillNode object and returns true.
- SkillTree has a private method Awake which calls resetAllNodes method.
- SkillTree has a public method resetAllNodes which loops through all SkillNodes in skillNodes list and sets isUnlocked property to false.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\StatsModifier.cs
File: StatsModifier.cs

Class: StatsModifier
- [Serializable]
- Public Fields:
  - Strength: float
  - Intelligence: float
  - Dexterity: float
  - Endurance: float
  - Wisdom: float
  - attackSpeed: float
  - criticalChance: float
  - criticalDamage: float
  - spellCriticalChance: float
  - spellCriticalDamage: float
  - cooldown: float
  - dodgeChance: float
  - armor: float
  - magicResistance: float
  - maxLife: float
  - maxMana: float
  - lifeRegen: float
  - manaRegen: float
  - movementSpeed: float

- Public Methods:
  + StatsModifier(float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float)
  + void Add(StatsModifier)
  + void Sub(StatsModifier)

- StatsModifier(float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float):
  - Parameters:
    - strength: float
    - intelligence: float
    - dexterity: float
    - endurance: float
    - wisdom: float
    - attackSpeed: float
    - criticalChance: float
    - criticalDamage: float
    - spellCriticalChance: float
    - spellCriticalDamage: float
    - cooldown: float
    - dodgeChance: float
    - armor: float
    - magicResistance: float
    - maxLife: float
    - maxMana: float
    - lifeRegen: float
    - manaRegen: float
    - movementSpeed: float
  - Set Public Fields to Parameters

- void Add(StatsModifier):
  - Add other.Strength to Strength
  - Add other.Intelligence to Intelligence
  - Add other.Dexterity to Dexterity
  - Add other.Endurance to Endurance
  - Add other.Wisdom to Wisdom
  - Add other.attackSpeed to attackSpeed
  - Add other.criticalChance to criticalChance
  - Add other.criticalDamage to criticalDamage
  - Add other.spellCriticalChance to spellCriticalChance
  - Add other.spellCriticalDamage to spellCriticalDamage
  - Add other.cooldown to cooldown
  - Add other.dodgeChance to dodgeChance
  - Add other.armor to armor
  - Add other.magicResistance to magicResistance
  - Add other.maxLife to maxLife
  - Add other.maxMana to maxMana
  - Add other.lifeRegen to lifeRegen
  - Add other.manaRegen to manaRegen
  - Add other.movementSpeed to movementSpeed

- void Sub(StatsModifier):
  - Subtract other.Strength from Strength
  - Subtract other.Intelligence from Intelligence
  - Subtract other.Dexterity from Dexterity
  - Subtract other.Endurance from Endurance
  - Subtract other.Wisdom from Wisdom
  - Subtract other.attackSpeed from attackSpeed
  - Subtract other.criticalChance from criticalChance
  - Subtract other.criticalDamage from criticalDamage
  - Subtract other.spellCriticalChance from spellCriticalChance
  - Subtract other.spellCriticalDamage from spellCriticalDamage
  - Subtract other.cooldown from cooldown
  - Subtract other.dodgeChance from dodgeChance
  - Subtract other.armor from armor
  - Subtract other.magicResistance from magicResistance
  - Subtract other.maxLife from maxLife
  - Subtract other.maxMana from maxMana
  - Subtract other.lifeRegen from lifeRegen
  - Subtract other.manaRegen from manaRegen
  - Subtract other.movementSpeed from movementSpeed
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityControllData.cs
Unfortunately, as an AI language model, I am unable to generate detailed syntax trees of each class in C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityControllData.cs, including the internal logic of each method. However, I can explain the basic structure and purpose of the code.

The code defines a class named AbilityControllData, which has four public properties: type (a string), direction (a Vector3), target (a GameObject), and targetPosition (another Vector3). These properties are used to store data related to controlling an ability in a game.

There are no methods defined in this class, so there is no internal logic to describe. Instead, this class serves as a data structure that can be used by other parts of the game to store and retrieve information about abilities and their controls.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityModifierManager.cs
AbilityModifierManager:
-ScriptableObject
--private List<AbilityModifiers> modifierList
--private AbilityStats abilityStats

--private void OnEnable()
---abilityStats = new AbilityStats()

+public string printAllModifiers()
+public void AddModifier(AbilityModifiers modifiers)
+public void RemoveModifier(AbilityModifiers modifier)
+public AbilityStats GetAdditionalModifiedValue()
+public AbilityStats CalculateModifiedValue()

printAllModifiers:
-string s
-foreach (AbilityModifiers modifier in modifierList)
--s += " - " + modifier.modifierName + " - " + "\n"
--s += modifier.modifierDescription + "\n"
--s += modifier.abilityStats.printStats()
-return s

AddModifier:
-ModifierList.Add(modifiers)
-CalculateModifiedValue()

RemoveModifier:
-modifierList.Remove(modifier)
-CalculateModifiedValue()

GetAdditionalModifiedValue:
-return abilityStats

CalculateModifiedValue:
-abilityStats.setZero()
-foreach (AbilityModifiers modifier in modifierList)
--modifier.ApplyModifier(ref abilityStats)
-return abilityStats
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityModifier.cs
File: AbilityModifier.cs

Class: AbilityModifiers
- public string modifierName;
- public string modifierDescription;
- public char operation;
- public AbilityStats abilityStats;

- public AbilityModifiers(string modifierName="Default", string modifierDescription="")
    - this.modifierName = modifierName;
    - this.modifierDescription = modifierDescription;
    - abilityStats = new AbilityStats();

- public virtual void ApplyModifier(ref AbilityStats abilityStats)
    - abilityStats.addStats(this.abilityStats);

Syntax Tree:
AbilityModifiers
├── modifierName
├── modifierDescription
├── operation
├── abilityStats
│   ├── AbilityStats
│   ├── ...
│   └── ...
├── AbilityModifiers(string modifierName="Default", string modifierDescription="")
│   ├── this.modifierName = modifierName
│   ├── this.modifierDescription = modifierDescription
│   ├── abilityStats = new AbilityStats()
│   ├── ...
│   └── ...
└── ApplyModifier(ref AbilityStats abilityStats)
    ├── abilityStats.addStats(this.abilityStats)
    ├── ...
    └── ...
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityObject.cs
Unfortunately, as an AI language model, I cannot generate an image of a syntax tree. However, I can provide a textual description of the syntax tree for each class in the given file. 

For class AbilityObject:
- The class declaration has 3 events: OnUpdate, OnSpawn, OnDelete, and 1 event with a GameObject parameter: OnHit
- The class has a public field data of type AbilityData
- The class has two public boolean fields: shouldDestroy and deleteOnCollision
- The class has two public float fields: timerMax and timer, and a boolean field deleteOnTimer
- The class has a public property ParentAbility of type Ability
- The class has a private method HandleOnHit with a parameter of type GameObject
- The class has a public method Delete()
- The class has an implementation of the Unity method Awake()
- The class has a list alreadyHit of tuples containing a GameObject and a float value, and a list alreadyHitRemoveIndeces of integers
- The class has two OnTrigger methods: OnTriggerEnter() and OnTriggerStay()
- The class implements three interfaces: IBouncingAbilityObject, IPiercingAbilityObject, IHomingAbilityObject

For interface IBouncingAbilityObject:
- The interface declares properties BounceIntensity and BounceDuration of type float
- The interface declares a method Bounce with a parameter of type GameObject

For interface IPiercingAbilityObject:
- The interface declares a method Pierce with a parameter of type GameObject

For interface IHomingAbilityObject:
- The interface declares a method Home with a parameter of type GameObject
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\AbilityStats.cs
AbilityStats class:

                      AbilityStats
                           |
                           |
                 ---------------------
                 |                   |
             float               float
                 |                   |
       baseDamage         strengthScaling
                 |                   |
       -------------------     -------------------
       |                 |     |                 |
   float            float       float         float
       |                 |     |                 |
intelligenceScaling cooldown     manaCost      range
       |                                       |
    float                                 float
       |                                       |
  projectileSpeed                         stunDuration

Methods:

- AbilityStats(): constructor method that takes no arguments.
- setZero(): method that sets all of the AbilityStats' float variables to 0.
- addStats(): method that takes another AbilityStats object as an argument and adds its values to the current AbilityStats object.
- printStats(): method that prints out the values of all the non-zero AbilityStats variables, formatted as a string. If a variable has a value of 0, it is not included in the string. Returns the string.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\Ability.cs
Unfortunately, as an AI language model, I am not able to generate syntax trees. However, I can provide an overview of the classes and their methods:

- Ability: This is an abstract class that extends ScriptableObject and represents the base class for all abilities. It contains properties for ability name, description, icon, stats, modifiers, animation, and timing. It also has methods for updating ability stats, adding and removing modifiers, activating the ability, and handling events related to ability object spawning, hitting, and activation.

- AbilityData: This is a data class that contains information about an ability and its context, such as the target object, caster stats, controller, position, and damage. It also has a method for creating a clone of the ability data object.

- AnimingMode: This is an enum that specifies the animation mode for an ability, which can be Default or PrePositionPlacement.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ChainLightning.cs
ChainLightning.cs

- using UnityEngine;
- using System.Collections.Generic;
- [CreateAssetMenu(menuName = "Abilities/ChainLightningAbility")]

public class ChainLightning : Ability {

    - public int maxBounceCount = 5;
    - public float bounceRange = 5f;
    - public GameObject chainLightningPrefab;
    - public Material lineMaterial;

    - [SerializeField]
    - private float ChainLightningTickness = 1f;

    - public override void Activate(AbilityData abilityData) {
        - Transform firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint;

        - AbilityObject abilityObject = Instantiate(chainLightningPrefab, firePoint.transform.position, firePoint.transform.rotation).GetComponent<AbilityObject>();
        - if(abilityObject == null) {
            - Debug.LogError("AbilityObject is null");
        }
        - abilityObject.data = abilityData;
        - abilityObject.ParentAbility = this;
    }

    - public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target) {
        - VisualEffectController visualEffectController = target.GetComponent<VisualEffectController>();
        - HealthController healthController = target.GetComponent<HealthController>();
        - if (healthController != null) {
            - healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject);
            - visualEffectController.SpawnEffect("LightningHitWeak",1.4f,effectUnitPosition.underFeet);
        }
        - List<GameObject> hitTargets = new List<GameObject> { target };
        - Vector3 lastPosition = abilityObject.transform.position;
        - for (int i = 0; i < maxBounceCount; i++) {
            - Collider[] colliders = Physics.OverlapSphere(lastPosition, bounceRange);
            - GameObject newTarget = null;
            - foreach (Collider collider in colliders) {
                - if (!hitTargets.Contains(collider.gameObject) && collider.gameObject.GetComponent<HealthController>() != null && collider.gameObject != abilityObject.data.CasterStats.gameObject) {
                    - newTarget = collider.gameObject;
                    - hitTargets.Add(newTarget);
                    - break;
                }
            }

            - if (newTarget != null) {
                - target = newTarget;
                - healthController = target.GetComponent<HealthController>();
                - visualEffectController = target.GetComponent<VisualEffectController>();
                - if (healthController != null) {
                    - healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject);
                    - visualEffectController.SpawnEffect("LightningHitWeak",1.4f,effectUnitPosition.underFeet);
                }
                
                - GameObject lineObject = new GameObject();
                - LineRenderer lineRenderer = lineObject.AddComponent<LineRenderer>();
                - lineRenderer.material = lineMaterial;
                - lineRenderer.startWidth = ChainLightningTickness;
                - lineRenderer.endWidth = ChainLightningTickness;
                - lineRenderer.positionCount = 2;
                - lineRenderer.SetPosition(0, lastPosition);
                - lineRenderer.SetPosition(1, visualEffectController.positionStomach.position);
                - Destroy(lineObject, 0.3f);

                - lastPosition = visualEffectController.positionStomach.position;
            } 
            - else {
                - break;
            }
        }
    }
}
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\DefaultSkill.cs
Unfortunately, as an AI language model and unable to view the dependencies which the code is tied to, I cannot provide a detailed syntax tree of each class in the mentioned file without an error. However, I can give a brief explanation of the code.

This code is a C# script, using Unity's 'CreateAssetMenu' attribute to create an Asset menu for the Skill class. This script is a child of the Skill class and has the same name as its file, 'DefaultSkill.cs'. It does not have any methods or logic of its own, but instead inherits all of its properties and behaviors from the parent class, Skill.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\FireBall.cs
Syntax Tree:

FireBall
- DefaultProjectileAbility
  - Ability (abstract)
    - ScriptableObject
      - Object
        - ValueType
- OnAbilityObjectHit (virtual method)
  - parameter abilityObject: AbilityObject
  - parameter target: GameObject
  - if (abilityObject.data.CasterStats != null)
    - targetHealth = target.GetComponent<HealthController>();
    - if (targetHealth != null)
      - damage = abilityObject.data.damage;
      - targetHealth.TakeDamage(damage, abilityObject.data.CasterStats.gameObject);
  - RaiseOnObjectHit(abilityObject, target)
- Activate (abstract method)
  - parameter abilityData: AbilityData
  - if (abilityData.CasterStats == null) return
  - firePoint = abilityData.CasterStats.GetComponent<AbilityController>().firePoint
  - projectileInstance = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation)
  - abilityObject = projectileInstance.GetComponent<BaseProjectileObject>()
  - RaiseOnObjectSpawned(abilityObject, null)
  - rb = projectileInstance.GetComponent<Rigidbody>()
  - rb.velocity = firePoint.forward * abilityData.projectileSpeed
  - abilityObject.ParentAbility = this
  - abilityObject.data = abilityData

The FireBall class extends the DefaultProjectileAbility class, which in turn implements the Ability abstract class. The Ability class is a ScriptableObject that inherits from Object and therefore from ValueType.

The class has two methods, OnAbilityObjectHit and Activate, both of which override abstract methods defined in the parent classes.

In the OnAbilityObjectHit method, the abilityObject parameter is used to access the caster stats and damage values. If the target object has a HealthController component, its TakeDamage method is called with the damage and the caster's game object as parameters. Afterwards, the RaiseOnObjectHit event is triggered.

The Activate method is responsible for instantiating and configuring a projectile object. First, it checks if the caster stats are not null, returning early if they are. Then, it retrieves the fire point transform from the caster's AbilityController component. It instantiates a projectile prefab at that position and rotation, gets its BaseProjectileObject component, and sets the ParentAbility and data properties of the abilityObject. Finally, it retrieves the Rigidbody component and sets its velocity based on the fire point direction and the projectile speed. The RaiseOnObjectSpawned event is triggered with the abilityObject parameter.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\FrostBolt.cs
[CreateAssetMenu(menuName = "Abilities/FrostBolt")]
- Initializes a new asset menu item for the FrostBolt class in Unity's editor.

public class FrostBolt : DefaultProjectileAbility
- Defines a public class FrostBolt that extends the DefaultProjectileAbility class.

public Buff chillBuff;
- Defines a public variable chillBuff of type Buff.

public void OnEnable()
- A public method that sets up the variables for the class.
- Creates a new Chill Buff with the BuffFactory, assigning stat modifiers and duration.
- Sets the abilityName and abilityDescription for FrostBolt.

public override void Activate(AbilityData abilityData)
- Overrides the Activate() method of the DefaultProjectileAbility class.
- Calls the base method of Activate() with the ability data passed into it.

public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
- Overrides the OnAbilityObjectHit method of the DefaultProjectileAbility class.
- Calls the base method of OnAbilityObjectHit() with the abilityObject and target passed into it.
- Debug.Logs "FrostBolt hit".
- Checks if the ability object has a CasterStats component.
- If so, attempts to retrieve the target's HealthController component.
- If found, deals damage to the target and applies a Chill buff to it using the BuffSystem and CasterStats.
- Debug.Logs "Applying Chill buff".
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\LivingBombAbility.cs
LivingBombAbility class syntax tree:

LivingBombAbility
-DefaultAbility
--Ability
---ScriptableObject
+firstExplosionAbility: LivingBombFirstExplosion
+secondExplosionAbility: LivingBombSecondExplosion
+livingBombBuff: LivingBombBuff
+livingBombSecondBuff: LivingBombSecondBuff
+abilityObjectFirstExplostionPrefab: GameObject
+abilityObjectSecondExplostionPrefab: GameObject
-Awake()
--base.Awake()
--abilityName = "Living Bomb"
--abilityDescription = "This is a living bomb ability"
--BaseAbilityStats.cooldown = 10
--BaseAbilityStats.intelligenceScaling = 1
--livingBombBuff = CreateInstance<LivingBombBuff>()
--livingBombSecondBuff = CreateInstance<LivingBombSecondBuff>()
--firstExplosionAbility = CreateInstance<LivingBombFirstExplosion>()
---firstExplosionAbility.abilityObjectFirstExplostionPrefab = abilityObjectFirstExplostionPrefab
---firstExplosionAbility.secondBombBuff = livingBombSecondBuff
--secondExplosionAbility = CreateInstance<LivingBombSecondExplosion>()
---secondExplosionAbility.abilityObjectSecondExplostionPrefab = abilityObjectSecondExplostionPrefab
--livingBombBuff.firstExplosionAbility = firstExplosionAbility
--livingBombSecondBuff.secondExplosionAbility = secondExplosionAbility
-Activate(AbilityData abilityData)
--targetBuffSystem = abilityData.Target.GetComponent<BuffSystem>()
--casterBuffSystem = abilityData.CasterStats.GetComponent<BuffSystem>()
--if targetBuffSystem != null
---targetBuffSystem.AddBuff(livingBombBuff, abilityData.Target, casterBuffSystem)
-OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)

LivingBombBuff class syntax tree:

LivingBombBuff
-Buff
+firstExplosionAbility: Ability
-InvokeOnFade(BuffInstance buffInstance, GameObject target)
--base.InvokeOnFade(buffInstance, target)
--abilityData = new AbilityData { CasterStats = buffInstance.target.GetComponent<CharacterStats>(), Target = buffInstance.target }
--firstExplosionAbility.Activate(abilityData)
+InvokeOnApply(BuffInstance buffInstance, GameObject target)

LivingBombFirstExplosion class syntax tree:

LivingBombFirstExplosion
-Ability
+abilityObjectFirstExplostionPrefab: GameObject
+secondBombBuff: Buff
+-casterBuffSystem: BuffSystem
-OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
--targetBuffSystem = target.GetComponent<BuffSystem>()
--casterBuffSystem = abilityObject.data.CasterStats.GetComponent<BuffSystem>()
--if targetBuffSystem != null
---targetBuffSystem.AddBuff(secondBombBuff, target, casterBuffSystem)
-Activate(AbilityData abilityData)
--abiltiyObject = GameObject.Instantiate(abilityObjectFirstExplostionPrefab, abilityData.Target.transform.position, Quaternion.identity).GetComponent<AbilityObject>()
--abiltiyObject.data = abilityData
--abiltiyObject.ParentAbility = this

LivingBombSecondBuff class syntax tree:

LivingBombSecondBuff
-Buff
+secondExplosionAbility: Ability
-InvokeOnFade(BuffInstance buffInstance, GameObject target)
--base.InvokeOnFade(buffInstance, target)
--abilityData = new AbilityData { CasterStats = buffInstance.target.GetComponent<CharacterStats>(), Target = buffInstance.target }
--secondExplosionAbility.Activate(abilityData)

LivingBombSecondExplosion class syntax tree:

LivingBombSecondExplosion
-Ability
+abilityObjectSecondExplostionPrefab: GameObject
-OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
--healthController = target.GetComponent<HealthController>()
--if healthController != null
---healthController.TakeDamage(abilityObject.data.damage, abilityObject.data.CasterStats.gameObject)
-Activate(AbilityData abilityData)
--abilityObject = Instantiate(abilityObjectSecondExplostionPrefab, abilityData.Target.transform.position, Quaternion.identity).GetComponent<AbilityObject>()
--abilityObject.data = abilityData
--abilityObject.ParentAbility = this
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\ShieldBash.cs
(Sorry, as an AI language model, I am not able to display an image or structure such as syntax tree, but I can provide further information about each method within the ShieldBash class)

Explanation: The ShieldBash class is a C# script that inherits from the DefaultAbility class. The purpose of this class is to define the behavior and logic of a Shield Bash ability. 

Variables:
- prefabAbilityObject: A GameObject that represents the visual effect of the ability.
- abilityName: A string that represents the name of the ability.
- baseDamage: An integer that represents the base amount of damage inflicted by the ability.
- strengthScaling: A float that represents the scaling ratio of the ability based on the caster's strength attribute.
- intelligenceScaling: A float that represents the scaling ratio of the ability based on the caster's intelligence attribute.
- animationName: A string that represents the name of the animation played when the ability is used.
- stunDuration: A float that represents the duration of the stun effect applied by the ability.

Awake():
- This method overrides the Awake method of the base class and is invoked when the ShieldBash object is instantiated.
- It sets the values of the variables mentioned above to the desired values.

OnAbilityObjectHit():
- This method is overridden from the base class and is invoked when the ability hits a target object.
- It checks if the caster of the ability has stats, and if the target object has a HealthController component.
- If both conditions are true, it calculates the damage based on baseDamage, strengthScaling, and intelligenceScaling, and applies it to the target's HealthController component.
- If the stunDuration is greater than or equal to 0, it applies a stun effect to the target using the Stun method of the IStunnable interface.
- It then raises an event to signal that the ability hit an object.

Activate():
- This method is also overridden from the base class and is invoked when the ability is activated.
- It checks if the caster of the ability has stats, and if not, it returns and does nothing.
- It gets the forward direction of the caster and creates an instance of the prefabAbilityObject at the caster's position with the proper rotation.
- It then gets the Rigidbody component of the instance and sets its velocity to the forward direction multiplied by the projectileSpeed of the abilityData.
- It sets some data related to the ability on the abilityObject's data field, including the duration of the stun effect. 
- It then raises an event to signal that the ability object was spawned.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\SimpleStrike.cs
(Since this is just one class, there will only be one syntax tree)

```
SimpleStrike.cs
├── [CreateAssetMenu(menuName = "Abilities/SimpleStrike")]
├── public class SimpleStrike : DefaultAbility
│   ├── public GameObject MeelePrefab;
│   ├── public float lifeTime = 0.5f;
│   ├── public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
│   │   ├── HealthController healthController = target.GetComponent<HealthController>();
│   │   ├── if (healthController != null)
│   │   │   ├── healthController.TakeDamage(abilityObject.data.damage,abilityObject.data.CasterStats.gameObject);
│   ├── public override void Activate(AbilityData abilityData)
│       ├── GameObject meleeStrikeInstance = Instantiate(MeelePrefab, abilityData.CasterController.firePoint.position, Quaternion.identity);
│       ├── AbilityObject abilityObject = meleeStrikeInstance.GetComponent<AbilityObject>();
│       │   ├── abilityObject.ParentAbility = this;
│       │   └── abilityObject.data = abilityData;
│       └── Destroy(meleeStrikeInstance, lifeTime);
```
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultAbility.cs
(DefaultAbility.cs)
	
DefaultAbility
	|
	|--- public void Awake()
	|	|--- Set abilityName to "Default"
	|	|--- Set abilityDescription to "Default"
	|
	|--- public void OnEnable()
	|	|--- Check if BaseAbilityStats is null, if yes, create an instance of AbilityStats and assign it to BaseAbilityStats
	|	|--- Check if TotalAbilityStats is null, if yes, create an instance of AbilityStats and assign it to TotalAbilityStats
	|	|--- Check if abilityModifierManager is null, if yes, create an instance of AbilityModifierManager and assign it to abilityModifierManager
	|	|--- Call updateAbilityStats()
	|
	|--- public override void Activate(AbilityData abilityData)
	|	|--- Print "Default Ability" to the console using Debug.Log()
	|
	|--- public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
	|	|--- Do nothing
	|
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultAuraAbility.cs
(DefaultAuraAbility.cs)

- DefaultAuraAbility
  - Inherits from DefaultAbility
  - Public Variables
    - auraPrefab: GameObject
    - damageInterval: float
  - Private Variables
    - lastDamageTime: float
    - abilityObject: AbilityObject
  - Methods
    - OnEnable(): void
      - Calls BaseAbilityStats = new AbilityStats()
      - Calls TotalAbilityStats = new AbilityStats()
      - Sets BaseAbilityStats.cooldown to 2
      - Calls updateAbilityStats()
      - Sets animingMode to AnimingMode.PrePositionPlacement
    - Activate(abilityData: AbilityData): void
      - Logs "Activate"
      - Sets useUpdate to true
      - Instantiates auraPrefab at the position of abilityData.Target with a Quaternion.identity rotation, and gets the AbilityObject component from it and assigns it to abilityObject
      - Sets abilityObject.data to abilityData
      - Sets abilityObject.ParentAbility to this
      - Subscribes DeactivateUpdate to abilityObject.OnDelete event
    - OnAbilityObjectHit(abilityObject: AbilityObject, target: GameObject): void
      - If timestart is 0, sets it to Time.time
      - Gets HealthController component from target as healthController variable
      - If healthController is not null, calls healthController.TakeDamage with parameters abilityObject.data.damage and abilityObject.data.CasterStats.gameObject
    - OnUpdate(): void
    - DeactivateUpdate(): void
      - Sets useUpdate to false
    - Deactivate(): void
      - If abilityObject is not null, calls abilityObject.Delete()
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultComboAbility.cs
(DefaultComboAbility.cs)

Class: DefaultComboAbility

Properties:
- MeelePrefab: GameObject
- lifeTime: float
- comboDamage: float[]

Methods:
+ OnAbilityObjectHit(abilityObject: AbilityObject, target: GameObject): void
+ PreActivateAbility(abilityData: AbilityData): void
+ Activate(abilityData: AbilityData): void

OnAbilityObjectHit(abilityObject, target):
1. Get the HealthController component from the target GameObject.
2. If HealthController exists, call its TakeDamage method with parameters of abilityObject's data.damage and abilityObject's data.CasterStats.gameObject.

PreActivateAbility(abilityData):
1. Get the ComboController component from abilityData's CasterCombatController property.
2. Set the comboName variable to "ThreeHitComboAbility".
3. Get the comboCount variable from comboController's GetComboCounter method with parameter of comboName, minus 1.
4. If comboCount is less than 2, call comboController's IncreaseComboCounter method with parameter of comboName.
5. Else, call comboController's ResetComboCounter method with parameter of comboName.
6. Add to abilityData's damage the value of comboDamage at index of comboCount, BaseAbilityStats.baseDamage, and abilityModifierManager's GetAdditionalModifiedValue() method's baseDamage property.
7. Depending on comboCount value, set animationName variable to "1HandSwordLightAttack1", "1HandSwordLightAttack2", or "1HandSwordLightAttack3".

Activate(abilityData):
1. Instantiate a new object of MeelePrefab at the position and rotation of abilityData's CasterStats transform location.
2. Get its AbilityObject component and set its data property to abilityData.
3. Call RaiseOnObjectSpawned event with parameters of abilityObject and null.
4. Set abilityObject's ParentAbility to this class instance.
5. Destroy the meleeStrikeInstance object after lifeTime seconds.
6. Log "Activate".
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultGroupBuffAbility.cs
(DefaultGroupBuffAbility) -> Ability
  -buff: Buff
  -radius: float
  +Activate(abilityData: AbilityData): void
  +OnAbilityObjectHit(abilityObject: AbilityObject, target: GameObject): void
  +OnEnable(): void
  -aIController: AIController
  -playerController: PlayerController
  -buffSystem: BuffSystem

Activate(abilityData: AbilityData): void
  -abilityName: string = "DefaultGroupBuffAbility"
  -abilityDescription: string = "This is a DefaultGroupBuffAbility"
  -BaseAbilityStats.cooldown: int = 10
  -BaseAbilityStats.intelligenceScaling: int = 1
  -colliders: Collider[] = Physics.OverlapSphere(abilityData.CasterStats.transform.position, radius)
  -casterBuffSystem: BuffSystem = abilityData.CasterStats.GetComponent<BuffSystem>()
  foreach (Collider collider in colliders)
  {
    buffSystem = collider.gameObject.GetComponent<BuffSystem>()
    if (buffSystem == null)
    {
      continue
    }
    aIController = collider.gameObject.GetComponent<AIController>()
    playerController = collider.gameObject.GetComponent<PlayerController>()
    if (aIController != null)
    {
      if (aIController.aggroTag == "Player")
      {
        continue
      }
      buffSystem.AddBuff(buff, collider.gameObject, casterBuffSystem)
      continue
    }
    else if (playerController != null)
    {
      buffSystem.AddBuff(buff, collider.gameObject, casterBuffSystem)
      continue
    }
  }

OnEnable(): void
  buff = BuffFactory.CreateBuff("Default Self Buff", 5f, true, 3, new StatsModifier(criticalDamage: 10))
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultProjectileAbility.cs
Not included as it is not present in the given file.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityClasses\DefaultSelfBuffAbility.cs
The syntax tree for DefaultSelfBuffAbility.cs:

- using UnityEngine;
  - imports the UnityEngine package

- [CreateAssetMenu(menuName = "Abilities/DefaultSelfBuffAbility")]
  - a custom editor attribute that creates a menu item in the Unity editor for creating a new DefaultSelfBuffAbility asset

- public class DefaultSelfBuffAbility : Ability
  - a public class that inherits from the Ability class

- public Buff buff;
  - a public Buff variable representing the buff that this ability will apply

- void OnEnable()
  - an event method that is called when the script is enabled
  - creates a new Buff object with the name "Default Self Buff", duration of 5 seconds, true for self-targeting, 3 as the maximum stack count, and a StatsModifier object with a critical damage value of 10

- public override void Activate(AbilityData abilityData)
  - a public method that overrides the Activate method of the Ability class
  - assigns values to the abilityName, abilityDescription, BaseAbilityStats.cooldown, and BaseAbilityStats.intelligenceScaling variables
  - checks if the CasterStats attribute of the abilityData object is null, logs an error and returns if it is
  - gets the BuffSystem component from the caster's stats, logs an error and returns if it is null
  - adds the buff to the BuffSystem component of the caster's stats game object

- public override void OnAbilityObjectHit(AbilityObject abilityObject, GameObject target)
  - a public method that overrides the OnAbilityObjectHit method of the Ability class, but does not contain any logic
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Abilitys\CDefaultAbilityObejcts\BaseProjectileObject.cs
BaseProjectileObject:
- public class
- Inherits from AbilityObject, IBouncingAbilityObject, IPiercingAbilityObject
- Implements BounceIntensity and BounceDuration properties

Methods:
- HandleOnHit(target: GameObject)
  - Protected method
  - Takes in a target GameObject parameter
  - Applies damage to the target if available
  - Determines whether bounceCount or pierceCount is greater, then executes Bounce or Pierce methods respectively
  - Handles object deletion if necessary

- Bounce(target: GameObject)
  - Public method
  - Takes in a target GameObject parameter
  - Reflects transform forward based on target transform up
  - Sets Rigidbody velocity based on new transform forward and projectile speed
  - Decrements bounceCount

- Pierce(target: GameObject)
  - Public method
  - Takes in a target GameObject parameter
  - Decrements pierceCount

Properties:
- BounceIntensity: float
- BounceDuration: float
- bounceCount: int
- pierceCount: int
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\BuffInstance.cs
BuffInstance: 
    - Public variables: 
        - Buff buff 
        - GameObject target 
        - int currentStacks 
        - float remainingDuration 
        - StatsModifier characterStatsTarget 
        - BuffSystem buffSystemCaster 
    - Constructor: 
        - Parameters: 
            - Buff buff 
            - GameObject target 
            - GameObject caster 
            - int initialStacks 
            - float initialDuration 
        - Logic: 
            - Set buff to the passed in buff 
            - Set target to the passed in target 
            - Set currentStacks to the passed in initialStacks 
            - Set remainingDuration to the passed in initialDuration 
            - Set characterStatsTarget to the TotalstatsModifier of the target's BuffSystem component 
            - Set buffSystemCaster to the BuffSystem component of the passed in caster 
    - Public method: 
        - Update() 
            - Logic: 
                - Subtract Time.deltaTime from remainingDuration 
                - If remainingDuration is less than or equal to 0: 
                    - Call OnBuffFade() 
                    - Call RemoveBuff() on the target's BuffSystem component with the buff and buffSystemCaster as parameters 
                    - Return 
                - Else: 
                    - Perform any other update logic specific to the buff 
        - Refresh(float duration) 
            - Parameters: 
                - float duration 
            - Logic: 
                - Set remainingDuration to the passed in duration 
        - AddStack() 
            - Logic: 
                - Increment currentStacks by 1 
                - Call OnBuffApply() 
        - OnBuffApply() 
            - Logic: 
                - If the buff's statModifier is not null: 
                    - Add the statModifier to the characterStatsTarget 
                    - Call UpdateSubStats() on the target's CharacterStats component 
                - Call InvokeOnApply() on the buff with the BuffInstance and target as parameters 
                - Call CallEventFromBuff() on the buffSystemCaster with the buff's buffName, "OnApply", the BuffInstance, and target as parameters 
        - OnBuffFade() 
            - Logic: 
                - If the buff's statModifier is not null: 
                    - Subtract the statModifier from the characterStatsTarget 
                    - Call UpdateSubStats() on the target's CharacterStats component 
                - Call InvokeOnFade() on the buff with the BuffInstance and target as parameters 
                - Call CallEventFromBuff() on the buffSystemCaster with the buff's buffName, "OnFade", the BuffInstance, and target as parameters 
        - OnBuffHit() 
            - Logic: 
                - Call InvokeOnHit() on the buff with the BuffInstance and target as parameters 
                - Call CallEventFromBuff() on the buffSystemCaster with the buff's buffName, "OnHit", the BuffInstance, and target as parameters
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Buffs\Buff.cs
File: Buff.cs

- Class: Buff
    - Access Modifier: public
    - Inheritance: ScriptableObject
    - Attributes:
        - [System.Serializable]
    - Fields:
        - Access Modifier: public
        - Name: statModifier
        - Data Type: StatsModifier
        - Description: Holds a modifier for the stats of a buff.
        - Name: buffName
        - Data Type: string
        - Description: The name of the buff.
        - Name: duration
        - Data Type: float
        - Description: The duration of the buff.
        - Name: stackable
        - Data Type: bool
        - Description: Indicates if the buff can stack.
        - Name: maxStacks
        - Data Type: int
        - Description: The maximum number of stacks the buff can have.
    - Events:
        - Name: OnApply
        - Data Type: System.Action<BuffInstance, GameObject>
        - Description: Event that is triggered when the buff is applied.
        - Name: OnFade
        - Data Type: System.Action<BuffInstance, GameObject>
        - Description: Event that is triggered when the buff fades.
        - Name: OnHit
        - Data Type: System.Action<BuffInstance, GameObject>
        - Description: Event that is triggered when the buff is hit.
    - Methods:
        - Access Modifier: public
        - Name: Buff
        - Description: Constructor for the Buff class.
        - Parameters: None.
        - Returns: None.
        - Name: InvokeOnApply
        - Description: Invokes the OnApply event.
        - Parameters:
            - buffInstance: BuffInstance
            - interactTarget: GameObject
        - Returns: None.
        - Name: AddInvokeOnApply
        - Description: Adds an action to the OnApply event.
        - Parameters:
            - action: System.Action<BuffInstance, GameObject>
        - Returns: None.
        - Name: InvokeOnFade
        - Description: Invokes the OnFade event.
        - Parameters:
            - buffInstance: BuffInstance
            - interactTarget: GameObject
        - Returns: None.
        - Name: AddInvokeOnFade
        - Description: Adds an action to the OnFade event.
        - Parameters:
            - action: System.Action<BuffInstance, GameObject>
        - Returns: None.
        - Name: InvokeOnHit
        - Description: Invokes the OnHit event.
        - Parameters:
            - buffInstance: BuffInstance
            - interactTarget: GameObject
        - Returns: None.
        - Name: AddInvokeOnHit
        - Description: Adds an action to the OnHit event.
        - Parameters:
            - action: System.Action<BuffInstance, GameObject>
        - Returns: None.

C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Factorys\BuffFactory.cs
(S: Start, E: End, C: Child)

S BuffFactory.cs
|
C public static class BuffFactory
|   |
|   C public static Buff CreateBuff(string buffName = "Default Buff", float duration = 5f, bool stackable = true, int maxStacks = 3, StatsModifier statModifier = null)
|   |   |
|   |   C Buff newBuff = ScriptableObject.CreateInstance<Buff>()
|   |   newBuff.buffName = buffName;
|   |   newBuff.duration = duration;
|   |   newBuff.stackable = stackable;
|   |   newBuff.maxStacks = maxStacks;
|   |   newBuff.statModifier = statModifier ?? new StatsModifier();
|   |
|   return newBuff;
|
E BuffFactory.cs
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\items\Item.cs
```
+----------------+
| Item           |
|----------------|
| itemName       |
| description    |
| icon           |
+----------------+

+----------------+
| EquipableItem  |
|----------------|
| equipmentType  |
| strengthBonus  |
| intelligenceBonus|
| dexterityBonus |
| enduranceBonus |
| wisdomBonus    |
| subStatsModifier|
+----------------+
      |
      V
+-------------------------+
| StatsModifier           |
|-------------------------|
| strengthModifier        |
| intelligenceModifier    |
| dexterityModifier       |
| enduranceModifier       |
| wisdomModifier          |
| agilityModifier         |
| criticalChanceModifier  |
| criticalDamageModifier  |
+-------------------------+
```

In `Item`:
- `itemName`: a public string variable that stores the name of the item.
- `description`: a public string variable that stores the description of the item.
- `icon`: a public Sprite variable that stores the icon of the item.

In `EquipableItem`:
- `equipmentType`: a public variable that stores the type of equipment the item belongs to.
- `strengthBonus`: a public float variable that stores the bonus strength value the item gives to the equipment it's equipped on.
- `intelligenceBonus`: a public float variable that stores the bonus intelligence value the item gives to the equipment it's equipped on.
- `dexterityBonus`: a public float variable that stores the bonus dexterity value the item gives to the equipment it's equipped on.
- `enduranceBonus`: a public float variable that stores the bonus endurance value the item gives to the equipment it's equipped on.
- `wisdomBonus`: a public float variable that stores the bonus wisdom value the item gives to the equipment it's equipped on.
- `subStatsModifier`: a public `StatsModifier` object that stores additional stat modifiers for the item.

In `StatsModifier`:
- `strengthModifier`: a public float that stores the strength modifier value.
- `intelligenceModifier`: a public float that stores the intelligence modifier value.
- `dexterityModifier`: a public float that stores the dexterity modifier value.
- `enduranceModifier`: a public float that stores the endurance modifier value.
- `wisdomModifier`: a public float that stores the wisdom modifier value.
- `agilityModifier`: a public float that stores the agility modifier value.
- `criticalChanceModifier`: a public float that stores the critical chance modifier value.
- `criticalDamageModifier`: a public float that stores the critical damage modifier value.

C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\FireballMasterySkill.cs
Here is the detailed syntax tree for the FireballMasterySkill class:

- namespace
  - UnityEngine
    - CreateAssetMenuAttribute
  - AbilitysSkillsAndBuffsItems
    - Skills
      - FireballMasterySkill.cs
        - public class FireballMasterySkill : Skill
          - [SerializeField]
            - private GameObject explosionPrefab
          - public override void ApplySkill(CharacterStats playerStats)
            - Debug.Log("Apply Skill")
            - FireBall fireballAbility = GetFireballAbility(playerStats)
            - if (fireballAbility != null)
              - Debug.Log("Fireball Ability found")
              - fireballAbility.OnAbilityObjectHitEvent += ExplodeOnHit
          - public override void RemoveSkill(CharacterStats playerStats)
            - FireBall fireballAbility = GetFireballAbility(playerStats)
            - if (fireballAbility != null)
              - fireballAbility.OnAbilityObjectHitEvent -= ExplodeOnHit
          - private FireBall GetFireballAbility(CharacterStats playerStats)
            - AbilityController abilityController = playerStats.GetComponent<AbilityController>()
            - return abilityController.learnedAbilitys.Find(a => a is FireBall) as FireBall
          - private void ExplodeOnHit(AbilityObject abilityObject, GameObject target)
            - Debug.Log("EXPLODE ON Hit")
            - ApplyDamageToTargets(abilityObject.transform.position, 2f, abilityObject.data.damage * 0.5f)
            - InstantiateExplosion(abilityObject.transform.position)
          - private void ApplyDamageToTargets(Vector3 position, float radius, float damage)
          - private void InstantiateExplosion(Vector3 position)
            - if (explosionPrefab != null)
              - GameObject explosion = Instantiate(explosionPrefab, position, Quaternion.identity);
              - <additional logic for explosion>
            - else
              - Debug.LogWarning("No explosion prefab assigned to FireballMasterySkill.")
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\FrostBoltMastery.cs
FrostBoltMastery.cs:

[CreateAssetMenu(fileName = "FrostBoltMastery", menuName = "Skill/FrostBoltMastery", order = 1)]
public class FrostBoltMastery : Skill
{
    [SerializeField]
    private Buff frozenBuff;

    public void OnEnable()
    {
        skillName = "FrostBoltMastery";
        frozenBuff = BuffFactory.CreateBuff("Frozen", 5f, true, 3, new StatsModifier());
        frozenBuff.AddInvokeOnApply(OnApplyFrozen);
    }

    public void OnApplyFrozen(BuffInstance instance, GameObject target)
    {
        Debug.Log("OnApplyFrozen" + skillName);
        IStunnable stunnable = target.GetComponent<IStunnable>();
        if (stunnable != null)
        {
            stunnable.Stun(10f);
        }
    }

    public override void ApplySkill(CharacterStats playerStats)
    {
        base.ApplySkill(playerStats);
        playerStats.GetComponent<BuffSystem>().AddEventForBuff("Chill", "OnApply", OnApplyCheckForChillStacks);
    }

    public override void RemoveSkill(CharacterStats playerStats)
    {
        base.RemoveSkill(playerStats);
        playerStats.GetComponent<BuffSystem>().RemoveEventForBuff("Chill", "OnApply", OnApplyCheckForChillStacks);
    }

    public void OnApplyCheckForChillStacks(BuffInstance instance, GameObject target)
    {
        Debug.Log("OnApplyCheckForChillStacks");

        if (instance.buff.buffName == "Chill")
        {
            if (instance.currentStacks >= instance.buff.maxStacks)
            {
                Debug.Log("OnApplyCheckForChillStacks" + "Triggerd");
                instance.currentStacks = 0;
                instance.target.GetComponent<BuffSystem>().RemoveBuff(instance.buff, instance.buffSystemCaster);
                instance.target.GetComponent<BuffSystem>().AddBuff(frozenBuff, instance.target, instance.buffSystemCaster);
            }
        }
    }
}

Syntax tree:

1. FrostBoltMastery: Skill
   - frozenBuff: Buff
   - OnEnable(): void
       - skillName = "FrostBoltMastery"
       - frozenBuff = BuffFactory.CreateBuff("Frozen", 5f, true, 3, new StatsModifier())
       - frozenBuff.AddInvokeOnApply(OnApplyFrozen)
   - OnApplyFrozen(instance: BuffInstance, target: GameObject): void
       - Debug.Log("OnApplyFrozen" + skillName)
       - stunnable = target.GetComponent<IStunnable>()
       - if (stunnable != null)
           - stunnable.Stun(10f)
   - ApplySkill(playerStats: CharacterStats): void
       - base.ApplySkill(playerStats)
       - playerStats.GetComponent<BuffSystem>().AddEventForBuff("Chill", "OnApply", OnApplyCheckForChillStacks)
   - RemoveSkill(playerStats: CharacterStats): void
       - base.RemoveSkill(playerStats)
       - playerStats.GetComponent<BuffSystem>().RemoveEventForBuff("Chill", "OnApply", OnApplyCheckForChillStacks)
   - OnApplyCheckForChillStacks(instance: BuffInstance, target: GameObject): void
       - Debug.Log("OnApplyCheckForChillStacks")
       - if (instance.buff.buffName == "Chill")
           - if (instance.currentStacks >= instance.buff.maxStacks)
               - Debug.Log("OnApplyCheckForChillStacks" + "Triggerd")
               - instance.currentStacks = 0
               - instance.target.GetComponent<BuffSystem>().RemoveBuff(instance.buff, instance.buffSystemCaster)
               - instance.target.GetComponent<BuffSystem>().AddBuff(frozenBuff, instance.target, instance.buffSystemCaster)
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNodeFactory.cs
(S) SkillNodeFactory
 |
 |_(M) CreateSkillNode(SkillNodeFactoryDataClass data)

(S) SkillNodeFactoryDataClass
 |
 |_(S) SkillNodeFactoryDataClass(string skillName, string skillDescription, int skillPointCost, Sprite icon, List<Archetype> mainStatRequirement, List<int> mainStatValue, Skill skill, SkillNode prerequisiteSkill, bool isUnlocked)
 |  |_(P) skillName
 |  |_(P) skillDescription
 |  |_(P) skillPointCost
 |  |_(P) icon
 |  |_(P) mainStatRequirement
 |  |_(P) mainStatValue
 |  |_(P) skill
 |  |_(P) prerequisiteSkill
 |  |_(P) isUnlocked
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\SkillNode.cs
 FILE: SkillNode.cs
 
                                             SkillNode
                                                  |
      -------------------------------------------------------------------------------
      |       |     |       |           |           |            |              |    
 skillName  skill- skill- skillPoint-   icon      mainStat-     skill-     prerequisite- isUnlocked
                     Description    cost                 Requirement     name        SkillNode

METHODS:
    No internal methods are present in this class.
C:\Users\Toastbrot\Downloads\STRATEGY 01.04.2022\My project\Assets\Scripts\AbilitysSkillsAndBuffsItems\Skills\Skill.cs
File: Skill.cs

Syntax Tree:
- abstract class Skill : ScriptableObject
  - public string skillName
  - public List<Archetype> archTypes
  - public StatsModifier statModifier
  - public virtual void ApplySkill(CharacterStats characterStats)
    - Debug.Log("Applying skill: " + skillName)
    - // Implement skill-specific behavior in derived classes
  - public virtual void RemoveSkill(CharacterStats characterStats)
    - Debug.Log("Removing skill: " + skillName)
    - // Implement skill-specific behavior in derived classes
  - public virtual void OnSpawnAbilityObject(AbilityObject abilityObject, AbilityData abilityData)
    - // no implementation
- enum Archetype
  - Strength
  - Intelligence 
  - Dexterity
  - Endurance 
  - Wisdom

Explanation:
- The Skill class is an abstract class that inherits from ScriptableObject.
- It has three public properties: skillName, archTypes (which is a list of Archetype enum), and statModifier (which is a StatsModifier object).
- It has three virtual methods that can be overridden by derived classes: ApplySkill, RemoveSkill, and OnSpawnAbilityObject.
- The ApplySkill and RemoveSkill methods are empty in the base class but can be implemented in derived classes to provide skill-specific behavior.
- The OnSpawnAbilityObject method has no implementation in the base class.
- The Archetype enum is defined with five values: Strength, Intelligence, Dexterity, Endurance, and Wisdom.
