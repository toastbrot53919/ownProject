using System.Collections.Generic; using UnityEngine; public class Inventory : MonoBehaviour { public List<Item> items; public QuestSystem questSystem; private void Start() { questSystem = GetComponent<QuestSystem>(); } public void AddItem(Item item) { items.Add(item); if(questSystem!=null) // Check if questSystem is not null { Debug.Log("collect:"+item.name); questSystem.UpdateQuestObjective("collect:"+item.name); // Call UpdateQuestObjective method with item id } } public void RemoveItem(Item item) { items.Remove(item); } public bool HasItem(Item item) { return items.Contains(item); } }
using UnityEngine; using UnityEngine.AI; public class MovementController : MonoBehaviour { public Transform target; public float stoppingDistance = 2f; private NavMeshAgent agent; private void Start() { agent = GetComponent<NavMeshAgent>(); } private void Update() { if (target != null) { agent.SetDestination(target.position); agent.stoppingDistance = stoppingDistance; } } }
using System.Collections.Generic; using UnityEngine; public class Hotkey { public Ability ability; } public class PlayerController : MonoBehaviour { [Header("Controller")] BuffSystem buffSystem; ExperienceSystem experienceSystem; CharacterStats characterStats; CharacterCombatController combatController; SkillController skillController; SkillTree skillTree; public Ability Ability1; public List<Hotkey> hotkeys; public Dictionary<KeyCode, Hotkey> hotkeyMapping; [Header("Movement")] public float moveSpeed = 5f; public float rotationSpeed = 720f; public float jumpForce = 1f; public LayerMask groundLayer; [Header("Camera")] public Transform cameraTarget; public float cameraDistance = 5f; public float cameraHeight = 2f; public float cameraRotationSpeed = 2f; private Rigidbody rb; private Animator animator; private Vector3 moveDirection; private bool isGrounded; private Transform mainCamera; private float cameraRotationY; private void Start() { combatController = GetComponent<CharacterCombatController>(); characterStats = GetComponent<CharacterStats>(); skillController = GetComponent<SkillController>(); //EDITOR CODE skillController.skillTree.resetAllNodes(); hotkeys = new List<Hotkey>(); for (int i = 0; i < 9; i++) { hotkeys.Add(new Hotkey()); } hotkeyMapping = new Dictionary<KeyCode, Hotkey> { { KeyCode.Alpha1, hotkeys[0] }, { KeyCode.Alpha2, hotkeys[1] }, { KeyCode.Alpha3, hotkeys[2] }, { KeyCode.Alpha4, hotkeys[3] }, { KeyCode.Alpha5, hotkeys[4] }, { KeyCode.Alpha6, hotkeys[5] }, { KeyCode.Alpha7, hotkeys[6] }, { KeyCode.Alpha8, hotkeys[7] }, { KeyCode.E, hotkeys[8] } }; rb = GetComponent<Rigidbody>(); animator = GetComponent<Animator>(); mainCamera = Camera.main.transform; Cursor.lockState = CursorLockMode.Locked; Cursor.visible = false; Hotkey hotkeyTest = new Hotkey(); hotkeyTest.ability = Ability1; hotkeys[0].ability = Ability1; skillController.OnSkillUnlocked += UpdateToSkillEvents; } private void Update() { HandleMovement(); HandleJump(); HandleCamera(); HandleHotkey(); } private void UpdateToSkillEvents(SkillNode node) { characterStats.UpdateSubStats(); } private void HandleHotkey() { foreach (KeyValuePair<KeyCode, Hotkey> entry in hotkeyMapping) { if (Input.GetKeyDown(entry.Key)) { Hotkey hotkey = entry.Value; if (hotkey.ability != null) { combatController.PerformAbility(hotkey.ability, this.gameObject); } // else if (hotkey.item != null) { // UseItem(hotkey.item); } } } } private void HandleMovement() { float horizontal = Input.GetAxis("Horizontal"); float vertical = Input.GetAxis("Vertical"); moveDirection = mainCamera.forward * vertical + mainCamera.right * horizontal; moveDirection.y = 0f; moveDirection.Normalize(); if (moveDirection != Vector3.zero) { Quaternion targetRotation = Quaternion.LookRotation(moveDirection); transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime); } animator.SetFloat("Speed", moveDirection.magnitude); } private void HandleJump() { isGrounded = Physics.Raycast(transform.position, Vector3.down, 0.4f, groundLayer); if (Input.GetButtonDown("Jump") && isGrounded) { rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse); } // animator.SetBool("IsGrounded", isGrounded); } private void HandleCamera() { float mouseX = Input.GetAxis("Mouse X"); float mouseY = Input.GetAxis("Mouse Y"); cameraRotationY -= mouseY * cameraRotationSpeed; cameraRotationY = Mathf.Clamp(cameraRotationY, -80f, 80f); mainCamera.RotateAround(cameraTarget.position, Vector3.up, mouseX * cameraRotationSpeed); mainCamera.localRotation = Quaternion.Euler(cameraRotationY, mainCamera.localEulerAngles.y, 0f); Vector3 cameraOffset = new Vector3(0f, cameraHeight, -cameraDistance); Vector3 targetPosition = cameraTarget.position + mainCamera.TransformDirection(cameraOffset); mainCamera.position = Vector3.Lerp(mainCamera.position, targetPosition, Time.deltaTime * rotationSpeed); mainCamera.LookAt(cameraTarget); } private void FixedUpdate() { rb.MovePosition(rb.position + moveDirection * moveSpeed * Time.fixedDeltaTime); } // Your existing code... public bool TryUnlockSkillNode(SkillNode skillNode) { if (skillNode == null) { Debug.LogWarning("Invalid skill node."); return false; } if (skillNode.isUnlocked) { Debug.LogWarning("Already learned."); return false; } // Check if the character has enough skill points to unlock the node. if (skillController.availableSkillPoints < skillNode.skillPointCost) { Debug.LogWarning("Not enough skill points."); return false; } // Check if the required main stat meets the node's requirement. bool statRequirementsMet = true; for (int i = 0; i < skillNode.mainStatRequirement.Count; i++) { Archetype statName = skillNode.mainStatRequirement[i]; int requiredValue = skillNode.mainStatValue[i]; switch (statName) { case Archetype.Strength: if (characterStats.strength < requiredValue) statRequirementsMet = false; break; case Archetype.Intelligence: if (characterStats.intelligence < requiredValue) statRequirementsMet = false; break; case Archetype.Dexterity: if (characterStats.dexterity < requiredValue) statRequirementsMet = false; break; case Archetype.Endurance: if (characterStats.endurance < requiredValue) statRequirementsMet = false; break; case Archetype.Wisdom: if (characterStats.wisdom < requiredValue) statRequirementsMet = false; break; default: Debug.LogWarning("Invalid stat name in the skill node."); break; } } if (!statRequirementsMet) { Debug.LogWarning("Main stat requirement not met."); return false; } // Check if the required prerequisite skill has been unlocked. if (skillNode.prerequisiteSkill != null && !skillNode.prerequisiteSkill.isUnlocked) { Debug.LogWarning("Prerequisite skill not unlocked."); return false; } // Check if the skill node is visible based on the fog of war mechanic. if (!skillController.skillTree.IsVisible(skillNode)) { Debug.LogWarning("Skill node is not visible."); return false; } // Unlock the skill node. skillNode.isUnlocked = true; skillController.LearnSkill(skillNode); return true; } public bool TryUnLearnSkillNode(SkillNode skillNode) { if (skillNode.isUnlocked == false) { return false; } skillNode.isUnlocked = false; skillController.UnlearnSkill(skillNode); return true; } }
﻿using System.Collections.Generic; using UnityEngine; class SkillController : MonoBehaviour { public List<Skill> activeSkills; public SkillTree skillTree; public int availableSkillPoints; public StatsModifier totalStatsModier; public delegate void SkillEvent(SkillNode skillNode); public event SkillEvent OnSkillUnlocked; public event SkillEvent OnSkillUnlearnd; public void LearnSkill(SkillNode skillNode) { // Call event to update the UI, etc. activeSkills.Add(skillNode.skill); totalStatsModier.Add(skillNode.skill.statModifier); availableSkillPoints -= skillNode.skillPointCost; OnSkillUnlocked?.Invoke(skillNode); } public void UnlearnSkill(SkillNode skillNode) { if (activeSkills.Remove(skillNode.skill)) { totalStatsModier.Sub(skillNode.skill.statModifier); } availableSkillPoints += skillNode.skillPointCost; OnSkillUnlearnd?.Invoke(skillNode); } }
﻿using UnityEngine; public class TargetingSystem : MonoBehaviour { public Camera playerCamera; public LayerMask targetLayerMask; public GameObject currentTarget; public GameObject crosshair; public float maxTargetingDistance = 100f; public Material highlightMaterial; private GameObject lastTarget; private Material originalMaterial; public OutlineHighlight outlineHighlightController; private void Update() { HandleCrosshairTargeting(); HandleMouseClickTargeting(); HighlightTarget(); } private void Start() { } private void HandleCrosshairTargeting() { RaycastHit hit; Ray ray = playerCamera.ScreenPointToRay(crosshair.transform.position); if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask)) { currentTarget = hit.collider.gameObject; } else { currentTarget = null; } } private void HandleMouseClickTargeting() { if (Input.GetMouseButtonDown(0)) { RaycastHit hit; Ray ray = playerCamera.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask)) { currentTarget = hit.collider.gameObject; } } } public GameObject GetTarget() { return currentTarget; } private void HighlightTarget() { if (currentTarget != null) { outlineHighlightController.target = currentTarget.transform; lastTarget = currentTarget; } else { outlineHighlightController.target = null; } } }
﻿using UnityEngine; using UnityEngine.UI; public class ToolTipUiController : MonoBehaviour { public Text SkillName; public Text SkillDescription; public Text AlreadySkilled; public Text SkillpointCost; public Text AttrbuteReq; public Image SkillIcon; private void Start() { } private void Awake() { Cursor.visible = true; Cursor.lockState = CursorLockMode.None; } public void UpdateUI(SkillNode node) { SkillName.text = node.skillName; SkillDescription.text = node.skillDescription; if (node.isUnlocked) { AlreadySkilled.gameObject.SetActive(true); } else { AlreadySkilled.gameObject.SetActive(false); } SkillpointCost.text = "Cost: " + node.skillPointCost; AttrbuteReq.text = "Requiment:"; for (int a = 0; a < node.mainStatRequirement.Count; a++) { AttrbuteReq.text += " " + node.mainStatRequirement[a] + ": " + node.mainStatValue[a]; } if (node.prerequisiteSkill != null) { AttrbuteReq.text += "Skill Requiment: " + node.prerequisiteSkill.skillName; } SkillIcon.sprite = node.icon; } }
