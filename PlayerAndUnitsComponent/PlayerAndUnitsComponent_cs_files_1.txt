using System.Collections.Generic; using UnityEngine; public class AbilityController : MonoBehaviour { public Transform firePoint; public float projectileSpeed = 5f; public List<Ability> learnedAbilitys; private IStatsProvider statsProvider; private void Awake() { statsProvider = GetComponent<IStatsProvider>(); } public void CastAbility(Ability ability, AbilityData abilityData) { ability.Activate(abilityData); } }
using UnityEngine; public class AIController : MonoBehaviour { public AIState currentState; public IdleState idleState; public FollowState followState; public AssistState assistState; public PatrolState patrolState; public ChaseState chaseState; public AttackState attackState; public Transform target; private void Start() { currentState = idleState; PatrolStateMonoBehaviour patrolStateMonoBehaviour = GetComponent<PatrolStateMonoBehaviour>(); if (patrolStateMonoBehaviour != null) { patrolState.waypoints = new System.Collections.Generic.List<Transform>(); foreach (GameObject g in patrolStateMonoBehaviour.waypoints) { patrolState.waypoints.Add(g.transform); } } } private void Update() { currentState.UpdateState(this); } public void ChangeState(AIState newState) { currentState.ExitState(this); currentState = newState; newState.EnterState(this); } } public abstract class AIState : ScriptableObject { public abstract void EnterState(AIController aiController); public abstract void UpdateState(AIController aiController); public abstract void ExitState(AIController aiController); }
﻿using System.Collections.Generic; using UnityEngine; public class AnimationController : MonoBehaviour { [SerializeField] private Animator animator; [SerializeField] private List<VisualEffectData> visualEffectDataList; private Dictionary<string, GameObject> visualEffects; private void Awake() { // Initialize the visualEffects dictionary. visualEffects = new Dictionary<string, GameObject>(); foreach (VisualEffectData effectData in visualEffectDataList) { visualEffects.Add(effectData.name, effectData.visualEffectPrefab); } } public void PlayAnimation(string animationName) { // Play the specified animation. if (animationName == "attack") { animator.SetTrigger("attack"); return; } animator.Play(animationName); } public void ApplyVisualEffect(string effectName, Vector3 position, Quaternion rotation) { // Instantiate the specified visual effect at the given position and rotation. if (visualEffects.TryGetValue(effectName, out GameObject effectPrefab)) { Instantiate(effectPrefab, position, rotation); } else { Debug.LogWarning($"Visual effect '{effectName}' not found."); } } } [System.Serializable] public class VisualEffectData { public string name; public GameObject visualEffectPrefab; }
﻿using System.Collections.Generic; using UnityEngine; public class BuffSystem : MonoBehaviour { private Dictionary<string, BuffInstance> activeBuffs; private Dictionary<string, System.Action<BuffInstance>> eventHandlers; private void Awake() { activeBuffs = new Dictionary<string, BuffInstance>(); eventHandlers = new Dictionary<string, System.Action<BuffInstance>>(); } public void AddBuff(Buff buff, GameObject target) { if (activeBuffs.ContainsKey(buff.buffName)) { BuffInstance existingBuff = activeBuffs[buff.buffName]; if (buff.stackable && existingBuff.currentStacks < buff.maxStacks) { existingBuff.AddStack(); existingBuff.Refresh(buff.duration); } else { existingBuff.Refresh(buff.duration); } } else { BuffInstance newBuff = new BuffInstance(buff, target, 1, buff.duration); activeBuffs.Add(buff.buffName, newBuff); AddEventHandlers(buff); newBuff.OnBuffApply(); } } public void RemoveBuff(Buff buff) { if (activeBuffs.ContainsKey(buff.buffName)) { BuffInstance existingBuff = activeBuffs[buff.buffName]; existingBuff.RemoveStack(); if (existingBuff.currentStacks <= 0) { RemoveEventHandlers(buff); activeBuffs.Remove(buff.buffName); } } } public BuffInstance GetBuffInstance(string buffName) { if (activeBuffs.ContainsKey(buffName)) { return activeBuffs[buffName]; } return null; } private void AddEventHandlers(Buff buff) { List<string> eventTypes = buff.GetEventTypes(); foreach (string eventType in eventTypes) { if (!eventHandlers.ContainsKey(eventType)) { eventHandlers.Add(eventType, (BuffInstance buffInstance) => { }); } System.Action<BuffInstance> eventHandler = null; switch (eventType) { case "OnApply": eventHandler = buff.InvokeOnApply; break; case "OnFade": eventHandler = buff.InvokeOnFade; break; case "OnHit": eventHandler = buff.InvokeOnHit; break; } if (eventHandler != null) { eventHandlers[eventType] += eventHandler; } } } private void RemoveEventHandlers(Buff buff) { List<string> eventTypes = buff.GetEventTypes(); foreach (string eventType in eventTypes) { System.Action<BuffInstance> eventHandler = null; switch (eventType) { case "OnApply": eventHandler = buff.InvokeOnApply; break; case "OnFade": eventHandler = buff.InvokeOnFade; break; case "OnHit": eventHandler = buff.InvokeOnHit; break; } if (eventHandler != null) { eventHandlers[eventType] -= eventHandler; } } } public void CallEventHandlers(string eventType, BuffInstance buffInstance) { if (eventHandlers.ContainsKey(eventType)) { eventHandlers[eventType]?.Invoke(buffInstance); } } }
﻿using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class ButtonWithToolTip : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler { public SkillNode skillNode; public PlayerController playerController; public UIManager uiManager; public GameObject toolTipObject; public Text toolTipText; private Button button; private void Awake() { button = GetComponent<Button>(); button.onClick.AddListener(TryLearn); GetComponent<Image>().sprite = skillNode.icon; } public void OnPointerEnter(PointerEventData eventData) { ShowToolTip(); } public void OnPointerExit(PointerEventData eventData) { HideToolTip(); } private void ShowToolTip() { uiManager.OpenToolTipSkill(skillNode, gameObject.GetComponent<RectTransform>().position); } private void HideToolTip() { uiManager.CloseToolTipSkill(); } private void TryLearn() { playerController.TryUnlockSkillNode(skillNode); } }
﻿using UnityEngine; public class CharacterCombatController : MonoBehaviour, IStatsProvider { public CharacterStats characterStats; public AbilityController abilityController; public AnimationController animationController; private void Start() { characterStats = GetComponent<CharacterStats>(); } public void PerformAbility(Ability ability, GameObject target) { float damageAbility = ability.baseDamage + (ability.strengthScaling * characterStats.strength) + (ability.intelligenceScaling * characterStats.intelligence); float critChance = characterStats.criticalChance; if (Random.Range(0f, 1f) <= critChance) { damageAbility *= 2; } animationController.PlayAnimation(ability.animationName); AbilityData abilityData = new AbilityData { CasterStats = characterStats, Target = target, damage = damageAbility, CasterController = abilityController // ... other fields }; abilityController.CastAbility(ability, abilityData); } public CharacterStats GetCharacterStats() { return characterStats; } }
﻿using System; using UnityEngine; public class CharacterStats : MonoBehaviour { // MainStats public float strength; public float intelligence; public float dexterity; public float endurance; public float wisdom; // SubStats public float criticalChance; public float criticalDamage; public float attackSpeed; public float spellCriticalChance; public float spellCriticalDamage; public float cooldown; public float maxLife; public float maxMana; public float lifeRegen; public float manaRegen; public float armor; public float magicResistance; public float dodgeChance; public int unspentStatPoints; public event Action StatsChanged; private EquipManager equipManager; private SkillController skillController; private void Start() { // Initialize unspentStatPoints or load from saved game data unspentStatPoints = 10; equipManager = GetComponent<EquipManager>(); skillController = GetComponent<SkillController>(); } public void AddStatPoints(int amount) { unspentStatPoints += amount; StatsChanged?.Invoke(); } public void UpdateSubStats() { strength += equipManager.TotalStrength; intelligence += equipManager.TotalIntelligence; dexterity += equipManager.TotalDexterity; endurance += equipManager.TotalEndurance; wisdom += equipManager.TotalWisdom; criticalChance = 0.02f * dexterity; criticalDamage = 1.5f + (0.14f * dexterity); attackSpeed = 1 + (0.01f * strength * dexterity); spellCriticalChance = 0.02f * intelligence; spellCriticalDamage = 1.5f + (0.14f * intelligence); armor = 1.5f * endurance; magicResistance = 1.5f * endurance; // Calculate substats based on main stats + equipment bonuses. maxLife = 100 + 20 * endurance; maxMana = 100 + 20 * wisdom; lifeRegen = 1 + 0.25f * endurance; manaRegen = 0.5f + 0.25f * wisdom; dodgeChance = 0.009f * dexterity; AddStatBonuses(equipManager.TotalStatModier); AddStatBonuses(skillController.totalStatsModier); StatsChanged?.Invoke(); } public void AddStatBonuses(StatsModifier statModifier) { attackSpeed += statModifier.attackSpeed; criticalChance += statModifier.criticalChance; criticalDamage += statModifier.criticalDamage; spellCriticalChance += statModifier.spellCriticalChance; spellCriticalDamage += statModifier.spellCriticalDamage; cooldown += statModifier.cooldown; dodgeChance += statModifier.dodgeChance; armor += statModifier.armor; magicResistance += statModifier.magicResistance; maxLife += statModifier.maxLife; maxMana += statModifier.maxMana; lifeRegen += statModifier.lifeRegen; manaRegen += statModifier.manaRegen; } public void IncreaseStat(Archetype stateType, int amount) { if (unspentStatPoints >= amount) { switch (stateType) { case Archetype.Strength: strength += amount; break; case Archetype.Intelligence: intelligence += amount; break; case Archetype.Dexterity: dexterity += amount; break; case Archetype.Endurance: endurance += amount; break; case Archetype.Wisdom: wisdom += amount; break; default: Debug.LogWarning("Invalid stat name."); return; } unspentStatPoints -= amount; UpdateSubStats(); } else { Debug.LogWarning("Not enough stat points."); } } }
﻿using System.Collections.Generic; using UnityEngine; public class EquipManager : MonoBehaviour { public enum EquipmentType { Weapon, Shield, Helmet, ChestArmor, LegArmor, Boots, Ring, Wrist } public Dictionary<EquipmentType, EquipableItem> equippedItems = new Dictionary<EquipmentType, EquipableItem>(); // Properties to store the total stats from all equipped items. public StatsModifier TotalStatModier; public float TotalStrength; public float TotalIntelligence; public float TotalDexterity; public float TotalEndurance; public float TotalWisdom; // Add more stat properties as needed. public void EquipItem(EquipmentType type, EquipableItem item) { if (equippedItems.ContainsKey(type)) { UnequipItem(type); } equippedItems[type] = item; ApplyItemStats(item); } public void UnequipItem(EquipmentType type) { if (!equippedItems.ContainsKey(type)) return; EquipableItem item = equippedItems[type]; RemoveItemStats(item); equippedItems.Remove(type); } private void ApplyItemStats(EquipableItem item) { TotalStrength += item.strengthBonus; TotalIntelligence += item.intelligenceBonus; TotalDexterity += item.dexterityBonus; TotalEndurance += item.enduranceBonus; TotalWisdom += item.wisdomBonus; TotalStatModier.Add(item.subStatsModifier); // Add more stat effects as needed. } private void RemoveItemStats(EquipableItem item) { TotalStrength -= item.strengthBonus; TotalIntelligence -= item.intelligenceBonus; TotalDexterity -= item.dexterityBonus; TotalEndurance -= item.enduranceBonus; TotalWisdom -= item.wisdomBonus; TotalStatModier.Sub(item.subStatsModifier); // Remove more stat effects as needed. } }
﻿using System; public class ExperienceSystem { public int CurrentXP { get; private set; } public int Level { get; private set; } public int XpToNextLevel { get; private set; } public event Action LevelUpEvent; public event Action<int> ExperienceGained; public ExperienceSystem() { CurrentXP = 0; Level = 1; UpdateXpToNextLevel(); } public void AddExperience(int amount) { CurrentXP += amount; ExperienceGained?.Invoke(amount); while (CurrentXP >= XpToNextLevel) { CurrentXP -= XpToNextLevel; LevelUp(); } } private void LevelUp() { Level++; UpdateXpToNextLevel(); LevelUpEvent?.Invoke(); } private void UpdateXpToNextLevel() { XpToNextLevel = CalculateXpForLevel(Level); } private int CalculateXpForLevel(int level) { // Implement your custom XP calculation logic here return (int)Math.Floor(Math.Pow(level, 2) * 100); } }
using UnityEngine; public class HealthController : MonoBehaviour { public string Name; public int maxHealth; public float currentHealth; public GameObject damageTextPrefab; private QuestSystem questSystem; private void Start() { currentHealth = maxHealth; damageTextPrefab = GameObject.Find("DamageTextTemplate"); } public void TakeDamage(float damage) { currentHealth -= damage; ShowDamageNumbers(damage); if (currentHealth <= 0) { Die(); } } private void Die() { // Implement death behavior, such as playing death animation, dropping loot, etc. if (questSystem != null) { questSystem.UpdateQuestObjective("kill:"+Name); // Call UpdateQuestObjective method with enemyId } Destroy(gameObject); } public void ShowDamageNumbers(float damage) { if (WorldSpaceCanvasController.Instance == null) { Debug.LogError("WorldSpaceCanvasController instance is not present in the scene."); return; } WorldSpaceCanvasController.Instance.SpawnDamageNumber(damage, transform.position + Vector3.up * 2f); } }
