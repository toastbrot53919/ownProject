using System.Collections.Generic; using UnityEngine; public class AbilityController : MonoBehaviour { public Transform firePoint; public float projectileSpeed = 5f; public List<Ability> learnedAbilitys; private IStatsProvider statsProvider; private void Awake() { statsProvider = GetComponent<IStatsProvider>(); } public void CastAbility(Ability ability, AbilityData abilityData) { ability.Activate(abilityData); } }
using UnityEngine; public class AIController : MonoBehaviour { public AIState currentState; public IdleState idleState; public FollowState followState; public AssistState assistState; public PatrolState patrolState; public ChaseState chaseState; public AttackState attackState; public Transform target; private void Start() { currentState = idleState; PatrolStateMonoBehaviour patrolStateMonoBehaviour = GetComponent<PatrolStateMonoBehaviour>(); if (patrolStateMonoBehaviour != null) { patrolState.waypoints = new System.Collections.Generic.List<Transform>(); foreach (GameObject g in patrolStateMonoBehaviour.waypoints) { patrolState.waypoints.Add(g.transform); } } } private void Update() { currentState.UpdateState(this); } public void ChangeState(AIState newState) { currentState.ExitState(this); currentState = newState; newState.EnterState(this); } } public abstract class AIState : ScriptableObject { public abstract void EnterState(AIController aiController); public abstract void UpdateState(AIController aiController); public abstract void ExitState(AIController aiController); }

﻿using System.Collections.Generic; using UnityEngine; public class AnimationController : MonoBehaviour { [SerializeField] private Animator animator; [SerializeField] private List<VisualEffectData> visualEffectDataList; private Dictionary<string, GameObject> visualEffects; private void Awake() { // Initialize the visualEffects dictionary. visualEffects = new Dictionary<string, GameObject>(); foreach (VisualEffectData effectData in visualEffectDataList) { visualEffects.Add(effectData.name, effectData.visualEffectPrefab); } } public void PlayAnimation(string animationName) { // Play the specified animation. if (animationName == "attack") { animator.SetTrigger("attack"); return; } animator.Play(animationName); } public void ApplyVisualEffect(string effectName, Vector3 position, Quaternion rotation) { // Instantiate the specified visual effect at the given position and rotation. if (visualEffects.TryGetValue(effectName, out GameObject effectPrefab)) { Instantiate(effectPrefab, position, rotation); } else { Debug.LogWarning($"Visual effect '{effectName}' not found."); } } } [System.Serializable] public class VisualEffectData { public string name; public GameObject visualEffectPrefab; }
﻿using System.Collections.Generic; using UnityEngine; public class BuffSystem : MonoBehaviour { private Dictionary<string, BuffInstance> activeBuffs; private Dictionary<string, System.Action<BuffInstance>> eventHandlers; private void Awake() { activeBuffs = new Dictionary<string, BuffInstance>(); eventHandlers = new Dictionary<string, System.Action<BuffInstance>>(); } public void AddBuff(Buff buff, GameObject target) { if (activeBuffs.ContainsKey(buff.buffName)) { BuffInstance existingBuff = activeBuffs[buff.buffName]; if (buff.stackable && existingBuff.currentStacks < buff.maxStacks) { existingBuff.AddStack(); existingBuff.Refresh(buff.duration); } else { existingBuff.Refresh(buff.duration); } } else { BuffInstance newBuff = new BuffInstance(buff, target, 1, buff.duration); activeBuffs.Add(buff.buffName, newBuff); AddEventHandlers(buff); newBuff.OnBuffApply(); } } public void RemoveBuff(Buff buff) { if (activeBuffs.ContainsKey(buff.buffName)) { BuffInstance existingBuff = activeBuffs[buff.buffName]; existingBuff.RemoveStack(); if (existingBuff.currentStacks <= 0) { RemoveEventHandlers(buff); activeBuffs.Remove(buff.buffName); } } } public BuffInstance GetBuffInstance(string buffName) { if (activeBuffs.ContainsKey(buffName)) { return activeBuffs[buffName]; } return null; } private void AddEventHandlers(Buff buff) { List<string> eventTypes = buff.GetEventTypes(); foreach (string eventType in eventTypes) { if (!eventHandlers.ContainsKey(eventType)) { eventHandlers.Add(eventType, (BuffInstance buffInstance) => { }); } System.Action<BuffInstance> eventHandler = null; switch (eventType) { case "OnApply": eventHandler = buff.InvokeOnApply; break; case "OnFade": eventHandler = buff.InvokeOnFade; break; case "OnHit": eventHandler = buff.InvokeOnHit; break; } if (eventHandler != null) { eventHandlers[eventType] += eventHandler; } } } private void RemoveEventHandlers(Buff buff) { List<string> eventTypes = buff.GetEventTypes(); foreach (string eventType in eventTypes) { System.Action<BuffInstance> eventHandler = null; switch (eventType) { case "OnApply": eventHandler = buff.InvokeOnApply; break; case "OnFade": eventHandler = buff.InvokeOnFade; break; case "OnHit": eventHandler = buff.InvokeOnHit; break; } if (eventHandler != null) { eventHandlers[eventType] -= eventHandler; } } } public void CallEventHandlers(string eventType, BuffInstance buffInstance) { if (eventHandlers.ContainsKey(eventType)) { eventHandlers[eventType]?.Invoke(buffInstance); } } }
﻿using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class ButtonWithToolTip : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler { public SkillNode skillNode; public PlayerController playerController; public UIManager uiManager; public GameObject toolTipObject; public Text toolTipText; private Button button; private void Awake() { button = GetComponent<Button>(); button.onClick.AddListener(TryLearn); GetComponent<Image>().sprite = skillNode.icon; } public void OnPointerEnter(PointerEventData eventData) { ShowToolTip(); } public void OnPointerExit(PointerEventData eventData) { HideToolTip(); } private void ShowToolTip() { uiManager.OpenToolTipSkill(skillNode, gameObject.GetComponent<RectTransform>().position); } private void HideToolTip() { uiManager.CloseToolTipSkill(); } private void TryLearn() { playerController.TryUnlockSkillNode(skillNode); } }

﻿using UnityEngine; public class CharacterCombatController : MonoBehaviour, IStatsProvider { public CharacterStats characterStats; public AbilityController abilityController; public AnimationController animationController; private void Start() { characterStats = GetComponent<CharacterStats>(); } public void PerformAbility(Ability ability, GameObject target) { float damageAbility = ability.baseDamage + (ability.strengthScaling * characterStats.strength) + (ability.intelligenceScaling * characterStats.intelligence); float critChance = characterStats.criticalChance; if (Random.Range(0f, 1f) <= critChance) { damageAbility *= 2; } animationController.PlayAnimation(ability.animationName); AbilityData abilityData = new AbilityData { CasterStats = characterStats, Target = target, damage = damageAbility, CasterController = abilityController // ... other fields }; abilityController.CastAbility(ability, abilityData); } public CharacterStats GetCharacterStats() { return characterStats; } }
﻿using System; using UnityEngine; public class CharacterStats : MonoBehaviour { // MainStats public float strength; public float intelligence; public float dexterity; public float endurance; public float wisdom; // SubStats public float criticalChance; public float criticalDamage; public float attackSpeed; public float spellCriticalChance; public float spellCriticalDamage; public float cooldown; public float maxLife; public float maxMana; public float lifeRegen; public float manaRegen; public float armor; public float magicResistance; public float dodgeChance; public int unspentStatPoints; public event Action StatsChanged; private EquipManager equipManager; private SkillController skillController; private void Start() { // Initialize unspentStatPoints or load from saved game data unspentStatPoints = 10; equipManager = GetComponent<EquipManager>(); skillController = GetComponent<SkillController>(); } public void AddStatPoints(int amount) { unspentStatPoints += amount; StatsChanged?.Invoke(); } public void UpdateSubStats() { strength += equipManager.TotalStrength; intelligence += equipManager.TotalIntelligence; dexterity += equipManager.TotalDexterity; endurance += equipManager.TotalEndurance; wisdom += equipManager.TotalWisdom; criticalChance = 0.02f * dexterity; criticalDamage = 1.5f + (0.14f * dexterity); attackSpeed = 1 + (0.01f * strength * dexterity); spellCriticalChance = 0.02f * intelligence; spellCriticalDamage = 1.5f + (0.14f * intelligence); armor = 1.5f * endurance; magicResistance = 1.5f * endurance; // Calculate substats based on main stats + equipment bonuses. maxLife = 100 + 20 * endurance; maxMana = 100 + 20 * wisdom; lifeRegen = 1 + 0.25f * endurance; manaRegen = 0.5f + 0.25f * wisdom; dodgeChance = 0.009f * dexterity; AddStatBonuses(equipManager.TotalStatModier); AddStatBonuses(skillController.totalStatsModier); StatsChanged?.Invoke(); } public void AddStatBonuses(StatsModifier statModifier) { attackSpeed += statModifier.attackSpeed; criticalChance += statModifier.criticalChance; criticalDamage += statModifier.criticalDamage; spellCriticalChance += statModifier.spellCriticalChance; spellCriticalDamage += statModifier.spellCriticalDamage; cooldown += statModifier.cooldown; dodgeChance += statModifier.dodgeChance; armor += statModifier.armor; magicResistance += statModifier.magicResistance; maxLife += statModifier.maxLife; maxMana += statModifier.maxMana; lifeRegen += statModifier.lifeRegen; manaRegen += statModifier.manaRegen; } public void IncreaseStat(Archetype stateType, int amount) { if (unspentStatPoints >= amount) { switch (stateType) { case Archetype.Strength: strength += amount; break; case Archetype.Intelligence: intelligence += amount; break; case Archetype.Dexterity: dexterity += amount; break; case Archetype.Endurance: endurance += amount; break; case Archetype.Wisdom: wisdom += amount; break; default: Debug.LogWarning("Invalid stat name."); return; } unspentStatPoints -= amount; UpdateSubStats(); } else { Debug.LogWarning("Not enough stat points."); } } }
﻿using System.Collections.Generic; using UnityEngine; public class EquipManager : MonoBehaviour { public enum EquipmentType { Weapon, Shield, Helmet, ChestArmor, LegArmor, Boots, Ring, Wrist } public Dictionary<EquipmentType, EquipableItem> equippedItems = new Dictionary<EquipmentType, EquipableItem>(); // Properties to store the total stats from all equipped items. public StatsModifier TotalStatModier; public float TotalStrength; public float TotalIntelligence; public float TotalDexterity; public float TotalEndurance; public float TotalWisdom; // Add more stat properties as needed. public void EquipItem(EquipmentType type, EquipableItem item) { if (equippedItems.ContainsKey(type)) { UnequipItem(type); } equippedItems[type] = item; ApplyItemStats(item); } public void UnequipItem(EquipmentType type) { if (!equippedItems.ContainsKey(type)) return; EquipableItem item = equippedItems[type]; RemoveItemStats(item); equippedItems.Remove(type); } private void ApplyItemStats(EquipableItem item) { TotalStrength += item.strengthBonus; TotalIntelligence += item.intelligenceBonus; TotalDexterity += item.dexterityBonus; TotalEndurance += item.enduranceBonus; TotalWisdom += item.wisdomBonus; TotalStatModier.Add(item.subStatsModifier); // Add more stat effects as needed. } private void RemoveItemStats(EquipableItem item) { TotalStrength -= item.strengthBonus; TotalIntelligence -= item.intelligenceBonus; TotalDexterity -= item.dexterityBonus; TotalEndurance -= item.enduranceBonus; TotalWisdom -= item.wisdomBonus; TotalStatModier.Sub(item.subStatsModifier); // Remove more stat effects as needed. } }
﻿using System; public class ExperienceSystem { public int CurrentXP { get; private set; } public int Level { get; private set; } public int XpToNextLevel { get; private set; } public event Action LevelUpEvent; public event Action<int> ExperienceGained; public ExperienceSystem() { CurrentXP = 0; Level = 1; UpdateXpToNextLevel(); } public void AddExperience(int amount) { CurrentXP += amount; ExperienceGained?.Invoke(amount); while (CurrentXP >= XpToNextLevel) { CurrentXP -= XpToNextLevel; LevelUp(); } } private void LevelUp() { Level++; UpdateXpToNextLevel(); LevelUpEvent?.Invoke(); } private void UpdateXpToNextLevel() { XpToNextLevel = CalculateXpForLevel(Level); } private int CalculateXpForLevel(int level) { // Implement your custom XP calculation logic here return (int)Math.Floor(Math.Pow(level, 2) * 100); } }




using UnityEngine; public class HealthController : MonoBehaviour { public int maxHealth; public float currentHealth; public GameObject damageTextPrefab; private void Start() { currentHealth = maxHealth; damageTextPrefab = GameObject.Find("DamageTextTemplate"); } public void TakeDamage(float damage) { currentHealth -= damage; ShowDamageNumbers(damage); if (currentHealth <= 0) { Die(); } } private void Die() { // Implement death behavior, such as playing death animation, dropping loot, etc. Destroy(gameObject); } public void ShowDamageNumbers(float damage) { if (WorldSpaceCanvasController.Instance == null) { Debug.LogError("WorldSpaceCanvasController instance is not present in the scene."); return; } WorldSpaceCanvasController.Instance.SpawnDamageNumber(damage, transform.position + Vector3.up * 2f); } }
﻿using System.Collections.Generic; using UnityEngine; public class Inventory : MonoBehaviour { public List<Item> items; public void AddItem(Item item) { items.Add(item); } public void RemoveItem(Item item) { items.Remove(item); } public bool HasItem(Item item) { return items.Contains(item); } }
using UnityEngine; using UnityEngine.AI; public class MovementController : MonoBehaviour { public Transform target; public float stoppingDistance = 2f; private NavMeshAgent agent; private void Start() { agent = GetComponent<NavMeshAgent>(); } private void Update() { if (target != null) { agent.SetDestination(target.position); agent.stoppingDistance = stoppingDistance; } } }
using System.Collections.Generic; using UnityEngine; public class Hotkey { public Ability ability; } public class PlayerController : MonoBehaviour { [Header("Controller")] BuffSystem buffSystem; ExperienceSystem experienceSystem; CharacterStats characterStats; CharacterCombatController combatController; SkillController skillController; SkillTree skillTree; public Ability Ability1; public List<Hotkey> hotkeys; public Dictionary<KeyCode, Hotkey> hotkeyMapping; [Header("Movement")] public float moveSpeed = 5f; public float rotationSpeed = 720f; public float jumpForce = 1f; public LayerMask groundLayer; [Header("Camera")] public Transform cameraTarget; public float cameraDistance = 5f; public float cameraHeight = 2f; public float cameraRotationSpeed = 2f; private Rigidbody rb; private Animator animator; private Vector3 moveDirection; private bool isGrounded; private Transform mainCamera; private float cameraRotationY; private void Start() { combatController = GetComponent<CharacterCombatController>(); characterStats = GetComponent<CharacterStats>(); skillController = GetComponent<SkillController>(); //EDITOR CODE skillController.skillTree.resetAllNodes(); hotkeys = new List<Hotkey>(); for (int i = 0; i < 9; i++) { hotkeys.Add(new Hotkey()); } hotkeyMapping = new Dictionary<KeyCode, Hotkey> { { KeyCode.Alpha1, hotkeys[0] }, { KeyCode.Alpha2, hotkeys[1] }, { KeyCode.Alpha3, hotkeys[2] }, { KeyCode.Alpha4, hotkeys[3] }, { KeyCode.Alpha5, hotkeys[4] }, { KeyCode.Alpha6, hotkeys[5] }, { KeyCode.Alpha7, hotkeys[6] }, { KeyCode.Alpha8, hotkeys[7] }, { KeyCode.E, hotkeys[8] } }; rb = GetComponent<Rigidbody>(); animator = GetComponent<Animator>(); mainCamera = Camera.main.transform; Cursor.lockState = CursorLockMode.Locked; Cursor.visible = false; Hotkey hotkeyTest = new Hotkey(); hotkeyTest.ability = Ability1; hotkeys[0].ability = Ability1; skillController.OnSkillUnlocked += UpdateToSkillEvents; } private void Update() { HandleMovement(); HandleJump(); HandleCamera(); HandleHotkey(); } private void UpdateToSkillEvents(SkillNode node) { characterStats.UpdateSubStats(); } private void HandleHotkey() { foreach (KeyValuePair<KeyCode, Hotkey> entry in hotkeyMapping) { if (Input.GetKeyDown(entry.Key)) { Hotkey hotkey = entry.Value; if (hotkey.ability != null) { combatController.PerformAbility(hotkey.ability, this.gameObject); } // else if (hotkey.item != null) { // UseItem(hotkey.item); } } } } private void HandleMovement() { float horizontal = Input.GetAxis("Horizontal"); float vertical = Input.GetAxis("Vertical"); moveDirection = mainCamera.forward * vertical + mainCamera.right * horizontal; moveDirection.y = 0f; moveDirection.Normalize(); if (moveDirection != Vector3.zero) { Quaternion targetRotation = Quaternion.LookRotation(moveDirection); transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime); } animator.SetFloat("Speed", moveDirection.magnitude); } private void HandleJump() { isGrounded = Physics.Raycast(transform.position, Vector3.down, 0.4f, groundLayer); if (Input.GetButtonDown("Jump") && isGrounded) { rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse); } // animator.SetBool("IsGrounded", isGrounded); } private void HandleCamera() { float mouseX = Input.GetAxis("Mouse X"); float mouseY = Input.GetAxis("Mouse Y"); cameraRotationY -= mouseY * cameraRotationSpeed; cameraRotationY = Mathf.Clamp(cameraRotationY, -80f, 80f); mainCamera.RotateAround(cameraTarget.position, Vector3.up, mouseX * cameraRotationSpeed); mainCamera.localRotation = Quaternion.Euler(cameraRotationY, mainCamera.localEulerAngles.y, 0f); Vector3 cameraOffset = new Vector3(0f, cameraHeight, -cameraDistance); Vector3 targetPosition = cameraTarget.position + mainCamera.TransformDirection(cameraOffset); mainCamera.position = Vector3.Lerp(mainCamera.position, targetPosition, Time.deltaTime * rotationSpeed); mainCamera.LookAt(cameraTarget); } private void FixedUpdate() { rb.MovePosition(rb.position + moveDirection * moveSpeed * Time.fixedDeltaTime); } // Your existing code... public bool TryUnlockSkillNode(SkillNode skillNode) { if (skillNode == null) { Debug.LogWarning("Invalid skill node."); return false; } if (skillNode.isUnlocked) { Debug.LogWarning("Already learned."); return false; } // Check if the character has enough skill points to unlock the node. if (skillController.availableSkillPoints < skillNode.skillPointCost) { Debug.LogWarning("Not enough skill points."); return false; } // Check if the required main stat meets the node's requirement. bool statRequirementsMet = true; for (int i = 0; i < skillNode.mainStatRequirement.Count; i++) { Archetype statName = skillNode.mainStatRequirement[i]; int requiredValue = skillNode.mainStatValue[i]; switch (statName) { case Archetype.Strength: if (characterStats.strength < requiredValue) statRequirementsMet = false; break; case Archetype.Intelligence: if (characterStats.intelligence < requiredValue) statRequirementsMet = false; break; case Archetype.Dexterity: if (characterStats.dexterity < requiredValue) statRequirementsMet = false; break; case Archetype.Endurance: if (characterStats.endurance < requiredValue) statRequirementsMet = false; break; case Archetype.Wisdom: if (characterStats.wisdom < requiredValue) statRequirementsMet = false; break; default: Debug.LogWarning("Invalid stat name in the skill node."); break; } } if (!statRequirementsMet) { Debug.LogWarning("Main stat requirement not met."); return false; } // Check if the required prerequisite skill has been unlocked. if (skillNode.prerequisiteSkill != null && !skillNode.prerequisiteSkill.isUnlocked) { Debug.LogWarning("Prerequisite skill not unlocked."); return false; } // Check if the skill node is visible based on the fog of war mechanic. if (!skillController.skillTree.IsVisible(skillNode)) { Debug.LogWarning("Skill node is not visible."); return false; } // Unlock the skill node. skillNode.isUnlocked = true; skillController.LearnSkill(skillNode); return true; } public bool TryUnLearnSkillNode(SkillNode skillNode) { if (skillNode.isUnlocked == false) { return false; } skillNode.isUnlocked = false; skillController.UnlearnSkill(skillNode); return true; } }
﻿using System.Collections.Generic; using UnityEngine; class SkillController : MonoBehaviour { public List<Skill> activeSkills; public SkillTree skillTree; public int availableSkillPoints; public StatsModifier totalStatsModier; public delegate void SkillEvent(SkillNode skillNode); public event SkillEvent OnSkillUnlocked; public event SkillEvent OnSkillUnlearnd; public void LearnSkill(SkillNode skillNode) { // Call event to update the UI, etc. activeSkills.Add(skillNode.skill); totalStatsModier.Add(skillNode.skill.statModifier); availableSkillPoints -= skillNode.skillPointCost; OnSkillUnlocked?.Invoke(skillNode); } public void UnlearnSkill(SkillNode skillNode) { if (activeSkills.Remove(skillNode.skill)) { totalStatsModier.Sub(skillNode.skill.statModifier); } availableSkillPoints += skillNode.skillPointCost; OnSkillUnlearnd?.Invoke(skillNode); } }
﻿using UnityEngine; public class TargetingSystem : MonoBehaviour { public Camera playerCamera; public LayerMask targetLayerMask; public GameObject currentTarget; public GameObject crosshair; public float maxTargetingDistance = 100f; public Material highlightMaterial; private GameObject lastTarget; private Material originalMaterial; public OutlineHighlight outlineHighlightController; private void Update() { HandleCrosshairTargeting(); HandleMouseClickTargeting(); HighlightTarget(); } private void Start() { } private void HandleCrosshairTargeting() { RaycastHit hit; Ray ray = playerCamera.ScreenPointToRay(crosshair.transform.position); if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask)) { currentTarget = hit.collider.gameObject; } else { currentTarget = null; } } private void HandleMouseClickTargeting() { if (Input.GetMouseButtonDown(0)) { RaycastHit hit; Ray ray = playerCamera.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out hit, maxTargetingDistance, targetLayerMask)) { currentTarget = hit.collider.gameObject; } } } public GameObject GetTarget() { return currentTarget; } private void HighlightTarget() { if (currentTarget != null) { outlineHighlightController.target = currentTarget.transform; lastTarget = currentTarget; } else { outlineHighlightController.target = null; } } }
﻿using UnityEngine; using UnityEngine.UI; public class ToolTipUiController : MonoBehaviour { public Text SkillName; public Text SkillDescription; public Text AlreadySkilled; public Text SkillpointCost; public Text AttrbuteReq; public Image SkillIcon; private void Start() { } private void Awake() { Cursor.visible = true; Cursor.lockState = CursorLockMode.None; } public void UpdateUI(SkillNode node) { SkillName.text = node.skillName; SkillDescription.text = node.skillDescription; if (node.isUnlocked) { AlreadySkilled.gameObject.SetActive(true); } else { AlreadySkilled.gameObject.SetActive(false); } SkillpointCost.text = "Cost: " + node.skillPointCost; AttrbuteReq.text = "Requiment:"; for (int a = 0; a < node.mainStatRequirement.Count; a++) { AttrbuteReq.text += " " + node.mainStatRequirement[a] + ": " + node.mainStatValue[a]; } if (node.prerequisiteSkill != null) { AttrbuteReq.text += "Skill Requiment: " + node.prerequisiteSkill.skillName; } SkillIcon.sprite = node.icon; } }